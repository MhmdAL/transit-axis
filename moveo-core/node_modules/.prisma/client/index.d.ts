
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model UserAuth
 * 
 */
export type UserAuth = $Result.DefaultSelection<Prisma.$UserAuthPayload>
/**
 * Model UserActivation
 * 
 */
export type UserActivation = $Result.DefaultSelection<Prisma.$UserActivationPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Role
 * 
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>
/**
 * Model UserRole
 * 
 */
export type UserRole = $Result.DefaultSelection<Prisma.$UserRolePayload>
/**
 * Model Driver
 * 
 */
export type Driver = $Result.DefaultSelection<Prisma.$DriverPayload>
/**
 * Model VehicleModel
 * 
 */
export type VehicleModel = $Result.DefaultSelection<Prisma.$VehicleModelPayload>
/**
 * Model Vehicle
 * 
 */
export type Vehicle = $Result.DefaultSelection<Prisma.$VehiclePayload>
/**
 * Model Location
 * 
 */
export type Location = $Result.DefaultSelection<Prisma.$LocationPayload>
/**
 * Model Stop
 * 
 */
export type Stop = $Result.DefaultSelection<Prisma.$StopPayload>
/**
 * Model Route
 * 
 */
export type Route = $Result.DefaultSelection<Prisma.$RoutePayload>
/**
 * Model RouteStop
 * 
 */
export type RouteStop = $Result.DefaultSelection<Prisma.$RouteStopPayload>
/**
 * Model Trip
 * 
 */
export type Trip = $Result.DefaultSelection<Prisma.$TripPayload>
/**
 * Model TripStop
 * 
 */
export type TripStop = $Result.DefaultSelection<Prisma.$TripStopPayload>
/**
 * Model VehicleTelemetry
 * 
 */
export type VehicleTelemetry = $Result.DefaultSelection<Prisma.$VehicleTelemetryPayload>
/**
 * Model VehicleTelemetryHistory
 * 
 */
export type VehicleTelemetryHistory = $Result.DefaultSelection<Prisma.$VehicleTelemetryHistoryPayload>
/**
 * Model Shift
 * 
 */
export type Shift = $Result.DefaultSelection<Prisma.$ShiftPayload>
/**
 * Model ServiceSchedule
 * 
 */
export type ServiceSchedule = $Result.DefaultSelection<Prisma.$ServiceSchedulePayload>
/**
 * Model VehicleBlockTemplate
 * 
 */
export type VehicleBlockTemplate = $Result.DefaultSelection<Prisma.$VehicleBlockTemplatePayload>
/**
 * Model DriverRunTemplate
 * 
 */
export type DriverRunTemplate = $Result.DefaultSelection<Prisma.$DriverRunTemplatePayload>
/**
 * Model DutyTemplate
 * 
 */
export type DutyTemplate = $Result.DefaultSelection<Prisma.$DutyTemplatePayload>
/**
 * Model VehicleBlock
 * 
 */
export type VehicleBlock = $Result.DefaultSelection<Prisma.$VehicleBlockPayload>
/**
 * Model DriverRun
 * 
 */
export type DriverRun = $Result.DefaultSelection<Prisma.$DriverRunPayload>
/**
 * Model Duty
 * 
 */
export type Duty = $Result.DefaultSelection<Prisma.$DutyPayload>
/**
 * Model TripDuty
 * 
 */
export type TripDuty = $Result.DefaultSelection<Prisma.$TripDutyPayload>
/**
 * Model WashingDuty
 * 
 */
export type WashingDuty = $Result.DefaultSelection<Prisma.$WashingDutyPayload>
/**
 * Model MaintenanceDuty
 * 
 */
export type MaintenanceDuty = $Result.DefaultSelection<Prisma.$MaintenanceDutyPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const DutyType: {
  TRIP: 'TRIP',
  WASHING: 'WASHING',
  MAINTENANCE: 'MAINTENANCE'
};

export type DutyType = (typeof DutyType)[keyof typeof DutyType]

}

export type DutyType = $Enums.DutyType

export const DutyType: typeof $Enums.DutyType

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more UserAuths
 * const userAuths = await prisma.userAuth.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more UserAuths
   * const userAuths = await prisma.userAuth.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.userAuth`: Exposes CRUD operations for the **UserAuth** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserAuths
    * const userAuths = await prisma.userAuth.findMany()
    * ```
    */
  get userAuth(): Prisma.UserAuthDelegate<ExtArgs>;

  /**
   * `prisma.userActivation`: Exposes CRUD operations for the **UserActivation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserActivations
    * const userActivations = await prisma.userActivation.findMany()
    * ```
    */
  get userActivation(): Prisma.UserActivationDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<ExtArgs>;

  /**
   * `prisma.userRole`: Exposes CRUD operations for the **UserRole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserRoles
    * const userRoles = await prisma.userRole.findMany()
    * ```
    */
  get userRole(): Prisma.UserRoleDelegate<ExtArgs>;

  /**
   * `prisma.driver`: Exposes CRUD operations for the **Driver** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Drivers
    * const drivers = await prisma.driver.findMany()
    * ```
    */
  get driver(): Prisma.DriverDelegate<ExtArgs>;

  /**
   * `prisma.vehicleModel`: Exposes CRUD operations for the **VehicleModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VehicleModels
    * const vehicleModels = await prisma.vehicleModel.findMany()
    * ```
    */
  get vehicleModel(): Prisma.VehicleModelDelegate<ExtArgs>;

  /**
   * `prisma.vehicle`: Exposes CRUD operations for the **Vehicle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vehicles
    * const vehicles = await prisma.vehicle.findMany()
    * ```
    */
  get vehicle(): Prisma.VehicleDelegate<ExtArgs>;

  /**
   * `prisma.location`: Exposes CRUD operations for the **Location** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Locations
    * const locations = await prisma.location.findMany()
    * ```
    */
  get location(): Prisma.LocationDelegate<ExtArgs>;

  /**
   * `prisma.stop`: Exposes CRUD operations for the **Stop** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Stops
    * const stops = await prisma.stop.findMany()
    * ```
    */
  get stop(): Prisma.StopDelegate<ExtArgs>;

  /**
   * `prisma.route`: Exposes CRUD operations for the **Route** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Routes
    * const routes = await prisma.route.findMany()
    * ```
    */
  get route(): Prisma.RouteDelegate<ExtArgs>;

  /**
   * `prisma.routeStop`: Exposes CRUD operations for the **RouteStop** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RouteStops
    * const routeStops = await prisma.routeStop.findMany()
    * ```
    */
  get routeStop(): Prisma.RouteStopDelegate<ExtArgs>;

  /**
   * `prisma.trip`: Exposes CRUD operations for the **Trip** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Trips
    * const trips = await prisma.trip.findMany()
    * ```
    */
  get trip(): Prisma.TripDelegate<ExtArgs>;

  /**
   * `prisma.tripStop`: Exposes CRUD operations for the **TripStop** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TripStops
    * const tripStops = await prisma.tripStop.findMany()
    * ```
    */
  get tripStop(): Prisma.TripStopDelegate<ExtArgs>;

  /**
   * `prisma.vehicleTelemetry`: Exposes CRUD operations for the **VehicleTelemetry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VehicleTelemetries
    * const vehicleTelemetries = await prisma.vehicleTelemetry.findMany()
    * ```
    */
  get vehicleTelemetry(): Prisma.VehicleTelemetryDelegate<ExtArgs>;

  /**
   * `prisma.vehicleTelemetryHistory`: Exposes CRUD operations for the **VehicleTelemetryHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VehicleTelemetryHistories
    * const vehicleTelemetryHistories = await prisma.vehicleTelemetryHistory.findMany()
    * ```
    */
  get vehicleTelemetryHistory(): Prisma.VehicleTelemetryHistoryDelegate<ExtArgs>;

  /**
   * `prisma.shift`: Exposes CRUD operations for the **Shift** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Shifts
    * const shifts = await prisma.shift.findMany()
    * ```
    */
  get shift(): Prisma.ShiftDelegate<ExtArgs>;

  /**
   * `prisma.serviceSchedule`: Exposes CRUD operations for the **ServiceSchedule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceSchedules
    * const serviceSchedules = await prisma.serviceSchedule.findMany()
    * ```
    */
  get serviceSchedule(): Prisma.ServiceScheduleDelegate<ExtArgs>;

  /**
   * `prisma.vehicleBlockTemplate`: Exposes CRUD operations for the **VehicleBlockTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VehicleBlockTemplates
    * const vehicleBlockTemplates = await prisma.vehicleBlockTemplate.findMany()
    * ```
    */
  get vehicleBlockTemplate(): Prisma.VehicleBlockTemplateDelegate<ExtArgs>;

  /**
   * `prisma.driverRunTemplate`: Exposes CRUD operations for the **DriverRunTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DriverRunTemplates
    * const driverRunTemplates = await prisma.driverRunTemplate.findMany()
    * ```
    */
  get driverRunTemplate(): Prisma.DriverRunTemplateDelegate<ExtArgs>;

  /**
   * `prisma.dutyTemplate`: Exposes CRUD operations for the **DutyTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DutyTemplates
    * const dutyTemplates = await prisma.dutyTemplate.findMany()
    * ```
    */
  get dutyTemplate(): Prisma.DutyTemplateDelegate<ExtArgs>;

  /**
   * `prisma.vehicleBlock`: Exposes CRUD operations for the **VehicleBlock** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VehicleBlocks
    * const vehicleBlocks = await prisma.vehicleBlock.findMany()
    * ```
    */
  get vehicleBlock(): Prisma.VehicleBlockDelegate<ExtArgs>;

  /**
   * `prisma.driverRun`: Exposes CRUD operations for the **DriverRun** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DriverRuns
    * const driverRuns = await prisma.driverRun.findMany()
    * ```
    */
  get driverRun(): Prisma.DriverRunDelegate<ExtArgs>;

  /**
   * `prisma.duty`: Exposes CRUD operations for the **Duty** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Duties
    * const duties = await prisma.duty.findMany()
    * ```
    */
  get duty(): Prisma.DutyDelegate<ExtArgs>;

  /**
   * `prisma.tripDuty`: Exposes CRUD operations for the **TripDuty** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TripDuties
    * const tripDuties = await prisma.tripDuty.findMany()
    * ```
    */
  get tripDuty(): Prisma.TripDutyDelegate<ExtArgs>;

  /**
   * `prisma.washingDuty`: Exposes CRUD operations for the **WashingDuty** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WashingDuties
    * const washingDuties = await prisma.washingDuty.findMany()
    * ```
    */
  get washingDuty(): Prisma.WashingDutyDelegate<ExtArgs>;

  /**
   * `prisma.maintenanceDuty`: Exposes CRUD operations for the **MaintenanceDuty** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MaintenanceDuties
    * const maintenanceDuties = await prisma.maintenanceDuty.findMany()
    * ```
    */
  get maintenanceDuty(): Prisma.MaintenanceDutyDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    UserAuth: 'UserAuth',
    UserActivation: 'UserActivation',
    User: 'User',
    Role: 'Role',
    UserRole: 'UserRole',
    Driver: 'Driver',
    VehicleModel: 'VehicleModel',
    Vehicle: 'Vehicle',
    Location: 'Location',
    Stop: 'Stop',
    Route: 'Route',
    RouteStop: 'RouteStop',
    Trip: 'Trip',
    TripStop: 'TripStop',
    VehicleTelemetry: 'VehicleTelemetry',
    VehicleTelemetryHistory: 'VehicleTelemetryHistory',
    Shift: 'Shift',
    ServiceSchedule: 'ServiceSchedule',
    VehicleBlockTemplate: 'VehicleBlockTemplate',
    DriverRunTemplate: 'DriverRunTemplate',
    DutyTemplate: 'DutyTemplate',
    VehicleBlock: 'VehicleBlock',
    DriverRun: 'DriverRun',
    Duty: 'Duty',
    TripDuty: 'TripDuty',
    WashingDuty: 'WashingDuty',
    MaintenanceDuty: 'MaintenanceDuty'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "userAuth" | "userActivation" | "user" | "role" | "userRole" | "driver" | "vehicleModel" | "vehicle" | "location" | "stop" | "route" | "routeStop" | "trip" | "tripStop" | "vehicleTelemetry" | "vehicleTelemetryHistory" | "shift" | "serviceSchedule" | "vehicleBlockTemplate" | "driverRunTemplate" | "dutyTemplate" | "vehicleBlock" | "driverRun" | "duty" | "tripDuty" | "washingDuty" | "maintenanceDuty"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      UserAuth: {
        payload: Prisma.$UserAuthPayload<ExtArgs>
        fields: Prisma.UserAuthFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserAuthFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAuthPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserAuthFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAuthPayload>
          }
          findFirst: {
            args: Prisma.UserAuthFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAuthPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserAuthFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAuthPayload>
          }
          findMany: {
            args: Prisma.UserAuthFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAuthPayload>[]
          }
          create: {
            args: Prisma.UserAuthCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAuthPayload>
          }
          createMany: {
            args: Prisma.UserAuthCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserAuthCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAuthPayload>[]
          }
          delete: {
            args: Prisma.UserAuthDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAuthPayload>
          }
          update: {
            args: Prisma.UserAuthUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAuthPayload>
          }
          deleteMany: {
            args: Prisma.UserAuthDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserAuthUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserAuthUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAuthPayload>
          }
          aggregate: {
            args: Prisma.UserAuthAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserAuth>
          }
          groupBy: {
            args: Prisma.UserAuthGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserAuthGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserAuthCountArgs<ExtArgs>
            result: $Utils.Optional<UserAuthCountAggregateOutputType> | number
          }
        }
      }
      UserActivation: {
        payload: Prisma.$UserActivationPayload<ExtArgs>
        fields: Prisma.UserActivationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserActivationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserActivationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserActivationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserActivationPayload>
          }
          findFirst: {
            args: Prisma.UserActivationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserActivationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserActivationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserActivationPayload>
          }
          findMany: {
            args: Prisma.UserActivationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserActivationPayload>[]
          }
          create: {
            args: Prisma.UserActivationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserActivationPayload>
          }
          createMany: {
            args: Prisma.UserActivationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserActivationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserActivationPayload>[]
          }
          delete: {
            args: Prisma.UserActivationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserActivationPayload>
          }
          update: {
            args: Prisma.UserActivationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserActivationPayload>
          }
          deleteMany: {
            args: Prisma.UserActivationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserActivationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserActivationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserActivationPayload>
          }
          aggregate: {
            args: Prisma.UserActivationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserActivation>
          }
          groupBy: {
            args: Prisma.UserActivationGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserActivationGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserActivationCountArgs<ExtArgs>
            result: $Utils.Optional<UserActivationCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>
        fields: Prisma.RoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      UserRole: {
        payload: Prisma.$UserRolePayload<ExtArgs>
        fields: Prisma.UserRoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserRoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserRoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          findFirst: {
            args: Prisma.UserRoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserRoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          findMany: {
            args: Prisma.UserRoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          create: {
            args: Prisma.UserRoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          createMany: {
            args: Prisma.UserRoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserRoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          delete: {
            args: Prisma.UserRoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          update: {
            args: Prisma.UserRoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          deleteMany: {
            args: Prisma.UserRoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserRoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserRoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          aggregate: {
            args: Prisma.UserRoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserRole>
          }
          groupBy: {
            args: Prisma.UserRoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserRoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserRoleCountArgs<ExtArgs>
            result: $Utils.Optional<UserRoleCountAggregateOutputType> | number
          }
        }
      }
      Driver: {
        payload: Prisma.$DriverPayload<ExtArgs>
        fields: Prisma.DriverFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DriverFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DriverFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>
          }
          findFirst: {
            args: Prisma.DriverFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DriverFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>
          }
          findMany: {
            args: Prisma.DriverFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>[]
          }
          create: {
            args: Prisma.DriverCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>
          }
          createMany: {
            args: Prisma.DriverCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DriverCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>[]
          }
          delete: {
            args: Prisma.DriverDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>
          }
          update: {
            args: Prisma.DriverUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>
          }
          deleteMany: {
            args: Prisma.DriverDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DriverUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DriverUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>
          }
          aggregate: {
            args: Prisma.DriverAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDriver>
          }
          groupBy: {
            args: Prisma.DriverGroupByArgs<ExtArgs>
            result: $Utils.Optional<DriverGroupByOutputType>[]
          }
          count: {
            args: Prisma.DriverCountArgs<ExtArgs>
            result: $Utils.Optional<DriverCountAggregateOutputType> | number
          }
        }
      }
      VehicleModel: {
        payload: Prisma.$VehicleModelPayload<ExtArgs>
        fields: Prisma.VehicleModelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VehicleModelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleModelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VehicleModelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleModelPayload>
          }
          findFirst: {
            args: Prisma.VehicleModelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleModelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VehicleModelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleModelPayload>
          }
          findMany: {
            args: Prisma.VehicleModelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleModelPayload>[]
          }
          create: {
            args: Prisma.VehicleModelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleModelPayload>
          }
          createMany: {
            args: Prisma.VehicleModelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VehicleModelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleModelPayload>[]
          }
          delete: {
            args: Prisma.VehicleModelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleModelPayload>
          }
          update: {
            args: Prisma.VehicleModelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleModelPayload>
          }
          deleteMany: {
            args: Prisma.VehicleModelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VehicleModelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VehicleModelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleModelPayload>
          }
          aggregate: {
            args: Prisma.VehicleModelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVehicleModel>
          }
          groupBy: {
            args: Prisma.VehicleModelGroupByArgs<ExtArgs>
            result: $Utils.Optional<VehicleModelGroupByOutputType>[]
          }
          count: {
            args: Prisma.VehicleModelCountArgs<ExtArgs>
            result: $Utils.Optional<VehicleModelCountAggregateOutputType> | number
          }
        }
      }
      Vehicle: {
        payload: Prisma.$VehiclePayload<ExtArgs>
        fields: Prisma.VehicleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VehicleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VehicleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          findFirst: {
            args: Prisma.VehicleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VehicleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          findMany: {
            args: Prisma.VehicleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>[]
          }
          create: {
            args: Prisma.VehicleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          createMany: {
            args: Prisma.VehicleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VehicleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>[]
          }
          delete: {
            args: Prisma.VehicleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          update: {
            args: Prisma.VehicleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          deleteMany: {
            args: Prisma.VehicleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VehicleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VehicleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          aggregate: {
            args: Prisma.VehicleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVehicle>
          }
          groupBy: {
            args: Prisma.VehicleGroupByArgs<ExtArgs>
            result: $Utils.Optional<VehicleGroupByOutputType>[]
          }
          count: {
            args: Prisma.VehicleCountArgs<ExtArgs>
            result: $Utils.Optional<VehicleCountAggregateOutputType> | number
          }
        }
      }
      Location: {
        payload: Prisma.$LocationPayload<ExtArgs>
        fields: Prisma.LocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LocationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LocationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          findFirst: {
            args: Prisma.LocationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LocationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          findMany: {
            args: Prisma.LocationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          create: {
            args: Prisma.LocationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          createMany: {
            args: Prisma.LocationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LocationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          delete: {
            args: Prisma.LocationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          update: {
            args: Prisma.LocationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          deleteMany: {
            args: Prisma.LocationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LocationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LocationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          aggregate: {
            args: Prisma.LocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLocation>
          }
          groupBy: {
            args: Prisma.LocationGroupByArgs<ExtArgs>
            result: $Utils.Optional<LocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.LocationCountArgs<ExtArgs>
            result: $Utils.Optional<LocationCountAggregateOutputType> | number
          }
        }
      }
      Stop: {
        payload: Prisma.$StopPayload<ExtArgs>
        fields: Prisma.StopFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StopFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StopPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StopFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StopPayload>
          }
          findFirst: {
            args: Prisma.StopFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StopPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StopFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StopPayload>
          }
          findMany: {
            args: Prisma.StopFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StopPayload>[]
          }
          create: {
            args: Prisma.StopCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StopPayload>
          }
          createMany: {
            args: Prisma.StopCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StopCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StopPayload>[]
          }
          delete: {
            args: Prisma.StopDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StopPayload>
          }
          update: {
            args: Prisma.StopUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StopPayload>
          }
          deleteMany: {
            args: Prisma.StopDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StopUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StopUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StopPayload>
          }
          aggregate: {
            args: Prisma.StopAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStop>
          }
          groupBy: {
            args: Prisma.StopGroupByArgs<ExtArgs>
            result: $Utils.Optional<StopGroupByOutputType>[]
          }
          count: {
            args: Prisma.StopCountArgs<ExtArgs>
            result: $Utils.Optional<StopCountAggregateOutputType> | number
          }
        }
      }
      Route: {
        payload: Prisma.$RoutePayload<ExtArgs>
        fields: Prisma.RouteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RouteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RouteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutePayload>
          }
          findFirst: {
            args: Prisma.RouteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RouteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutePayload>
          }
          findMany: {
            args: Prisma.RouteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutePayload>[]
          }
          create: {
            args: Prisma.RouteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutePayload>
          }
          createMany: {
            args: Prisma.RouteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RouteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutePayload>[]
          }
          delete: {
            args: Prisma.RouteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutePayload>
          }
          update: {
            args: Prisma.RouteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutePayload>
          }
          deleteMany: {
            args: Prisma.RouteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RouteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RouteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutePayload>
          }
          aggregate: {
            args: Prisma.RouteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoute>
          }
          groupBy: {
            args: Prisma.RouteGroupByArgs<ExtArgs>
            result: $Utils.Optional<RouteGroupByOutputType>[]
          }
          count: {
            args: Prisma.RouteCountArgs<ExtArgs>
            result: $Utils.Optional<RouteCountAggregateOutputType> | number
          }
        }
      }
      RouteStop: {
        payload: Prisma.$RouteStopPayload<ExtArgs>
        fields: Prisma.RouteStopFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RouteStopFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteStopPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RouteStopFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteStopPayload>
          }
          findFirst: {
            args: Prisma.RouteStopFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteStopPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RouteStopFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteStopPayload>
          }
          findMany: {
            args: Prisma.RouteStopFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteStopPayload>[]
          }
          create: {
            args: Prisma.RouteStopCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteStopPayload>
          }
          createMany: {
            args: Prisma.RouteStopCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RouteStopCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteStopPayload>[]
          }
          delete: {
            args: Prisma.RouteStopDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteStopPayload>
          }
          update: {
            args: Prisma.RouteStopUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteStopPayload>
          }
          deleteMany: {
            args: Prisma.RouteStopDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RouteStopUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RouteStopUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteStopPayload>
          }
          aggregate: {
            args: Prisma.RouteStopAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRouteStop>
          }
          groupBy: {
            args: Prisma.RouteStopGroupByArgs<ExtArgs>
            result: $Utils.Optional<RouteStopGroupByOutputType>[]
          }
          count: {
            args: Prisma.RouteStopCountArgs<ExtArgs>
            result: $Utils.Optional<RouteStopCountAggregateOutputType> | number
          }
        }
      }
      Trip: {
        payload: Prisma.$TripPayload<ExtArgs>
        fields: Prisma.TripFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TripFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TripFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload>
          }
          findFirst: {
            args: Prisma.TripFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TripFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload>
          }
          findMany: {
            args: Prisma.TripFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload>[]
          }
          create: {
            args: Prisma.TripCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload>
          }
          createMany: {
            args: Prisma.TripCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TripCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload>[]
          }
          delete: {
            args: Prisma.TripDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload>
          }
          update: {
            args: Prisma.TripUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload>
          }
          deleteMany: {
            args: Prisma.TripDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TripUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TripUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload>
          }
          aggregate: {
            args: Prisma.TripAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrip>
          }
          groupBy: {
            args: Prisma.TripGroupByArgs<ExtArgs>
            result: $Utils.Optional<TripGroupByOutputType>[]
          }
          count: {
            args: Prisma.TripCountArgs<ExtArgs>
            result: $Utils.Optional<TripCountAggregateOutputType> | number
          }
        }
      }
      TripStop: {
        payload: Prisma.$TripStopPayload<ExtArgs>
        fields: Prisma.TripStopFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TripStopFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripStopPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TripStopFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripStopPayload>
          }
          findFirst: {
            args: Prisma.TripStopFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripStopPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TripStopFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripStopPayload>
          }
          findMany: {
            args: Prisma.TripStopFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripStopPayload>[]
          }
          create: {
            args: Prisma.TripStopCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripStopPayload>
          }
          createMany: {
            args: Prisma.TripStopCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TripStopCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripStopPayload>[]
          }
          delete: {
            args: Prisma.TripStopDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripStopPayload>
          }
          update: {
            args: Prisma.TripStopUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripStopPayload>
          }
          deleteMany: {
            args: Prisma.TripStopDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TripStopUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TripStopUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripStopPayload>
          }
          aggregate: {
            args: Prisma.TripStopAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTripStop>
          }
          groupBy: {
            args: Prisma.TripStopGroupByArgs<ExtArgs>
            result: $Utils.Optional<TripStopGroupByOutputType>[]
          }
          count: {
            args: Prisma.TripStopCountArgs<ExtArgs>
            result: $Utils.Optional<TripStopCountAggregateOutputType> | number
          }
        }
      }
      VehicleTelemetry: {
        payload: Prisma.$VehicleTelemetryPayload<ExtArgs>
        fields: Prisma.VehicleTelemetryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VehicleTelemetryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleTelemetryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VehicleTelemetryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleTelemetryPayload>
          }
          findFirst: {
            args: Prisma.VehicleTelemetryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleTelemetryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VehicleTelemetryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleTelemetryPayload>
          }
          findMany: {
            args: Prisma.VehicleTelemetryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleTelemetryPayload>[]
          }
          create: {
            args: Prisma.VehicleTelemetryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleTelemetryPayload>
          }
          createMany: {
            args: Prisma.VehicleTelemetryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VehicleTelemetryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleTelemetryPayload>[]
          }
          delete: {
            args: Prisma.VehicleTelemetryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleTelemetryPayload>
          }
          update: {
            args: Prisma.VehicleTelemetryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleTelemetryPayload>
          }
          deleteMany: {
            args: Prisma.VehicleTelemetryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VehicleTelemetryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VehicleTelemetryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleTelemetryPayload>
          }
          aggregate: {
            args: Prisma.VehicleTelemetryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVehicleTelemetry>
          }
          groupBy: {
            args: Prisma.VehicleTelemetryGroupByArgs<ExtArgs>
            result: $Utils.Optional<VehicleTelemetryGroupByOutputType>[]
          }
          count: {
            args: Prisma.VehicleTelemetryCountArgs<ExtArgs>
            result: $Utils.Optional<VehicleTelemetryCountAggregateOutputType> | number
          }
        }
      }
      VehicleTelemetryHistory: {
        payload: Prisma.$VehicleTelemetryHistoryPayload<ExtArgs>
        fields: Prisma.VehicleTelemetryHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VehicleTelemetryHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleTelemetryHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VehicleTelemetryHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleTelemetryHistoryPayload>
          }
          findFirst: {
            args: Prisma.VehicleTelemetryHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleTelemetryHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VehicleTelemetryHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleTelemetryHistoryPayload>
          }
          findMany: {
            args: Prisma.VehicleTelemetryHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleTelemetryHistoryPayload>[]
          }
          create: {
            args: Prisma.VehicleTelemetryHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleTelemetryHistoryPayload>
          }
          createMany: {
            args: Prisma.VehicleTelemetryHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VehicleTelemetryHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleTelemetryHistoryPayload>[]
          }
          delete: {
            args: Prisma.VehicleTelemetryHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleTelemetryHistoryPayload>
          }
          update: {
            args: Prisma.VehicleTelemetryHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleTelemetryHistoryPayload>
          }
          deleteMany: {
            args: Prisma.VehicleTelemetryHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VehicleTelemetryHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VehicleTelemetryHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleTelemetryHistoryPayload>
          }
          aggregate: {
            args: Prisma.VehicleTelemetryHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVehicleTelemetryHistory>
          }
          groupBy: {
            args: Prisma.VehicleTelemetryHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<VehicleTelemetryHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.VehicleTelemetryHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<VehicleTelemetryHistoryCountAggregateOutputType> | number
          }
        }
      }
      Shift: {
        payload: Prisma.$ShiftPayload<ExtArgs>
        fields: Prisma.ShiftFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShiftFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShiftFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          findFirst: {
            args: Prisma.ShiftFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShiftFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          findMany: {
            args: Prisma.ShiftFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>[]
          }
          create: {
            args: Prisma.ShiftCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          createMany: {
            args: Prisma.ShiftCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ShiftCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>[]
          }
          delete: {
            args: Prisma.ShiftDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          update: {
            args: Prisma.ShiftUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          deleteMany: {
            args: Prisma.ShiftDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShiftUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ShiftUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          aggregate: {
            args: Prisma.ShiftAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShift>
          }
          groupBy: {
            args: Prisma.ShiftGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShiftGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShiftCountArgs<ExtArgs>
            result: $Utils.Optional<ShiftCountAggregateOutputType> | number
          }
        }
      }
      ServiceSchedule: {
        payload: Prisma.$ServiceSchedulePayload<ExtArgs>
        fields: Prisma.ServiceScheduleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceScheduleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceSchedulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceScheduleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceSchedulePayload>
          }
          findFirst: {
            args: Prisma.ServiceScheduleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceSchedulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceScheduleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceSchedulePayload>
          }
          findMany: {
            args: Prisma.ServiceScheduleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceSchedulePayload>[]
          }
          create: {
            args: Prisma.ServiceScheduleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceSchedulePayload>
          }
          createMany: {
            args: Prisma.ServiceScheduleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceScheduleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceSchedulePayload>[]
          }
          delete: {
            args: Prisma.ServiceScheduleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceSchedulePayload>
          }
          update: {
            args: Prisma.ServiceScheduleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceSchedulePayload>
          }
          deleteMany: {
            args: Prisma.ServiceScheduleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceScheduleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ServiceScheduleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceSchedulePayload>
          }
          aggregate: {
            args: Prisma.ServiceScheduleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceSchedule>
          }
          groupBy: {
            args: Prisma.ServiceScheduleGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceScheduleGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceScheduleCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceScheduleCountAggregateOutputType> | number
          }
        }
      }
      VehicleBlockTemplate: {
        payload: Prisma.$VehicleBlockTemplatePayload<ExtArgs>
        fields: Prisma.VehicleBlockTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VehicleBlockTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleBlockTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VehicleBlockTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleBlockTemplatePayload>
          }
          findFirst: {
            args: Prisma.VehicleBlockTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleBlockTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VehicleBlockTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleBlockTemplatePayload>
          }
          findMany: {
            args: Prisma.VehicleBlockTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleBlockTemplatePayload>[]
          }
          create: {
            args: Prisma.VehicleBlockTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleBlockTemplatePayload>
          }
          createMany: {
            args: Prisma.VehicleBlockTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VehicleBlockTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleBlockTemplatePayload>[]
          }
          delete: {
            args: Prisma.VehicleBlockTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleBlockTemplatePayload>
          }
          update: {
            args: Prisma.VehicleBlockTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleBlockTemplatePayload>
          }
          deleteMany: {
            args: Prisma.VehicleBlockTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VehicleBlockTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VehicleBlockTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleBlockTemplatePayload>
          }
          aggregate: {
            args: Prisma.VehicleBlockTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVehicleBlockTemplate>
          }
          groupBy: {
            args: Prisma.VehicleBlockTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<VehicleBlockTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.VehicleBlockTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<VehicleBlockTemplateCountAggregateOutputType> | number
          }
        }
      }
      DriverRunTemplate: {
        payload: Prisma.$DriverRunTemplatePayload<ExtArgs>
        fields: Prisma.DriverRunTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DriverRunTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverRunTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DriverRunTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverRunTemplatePayload>
          }
          findFirst: {
            args: Prisma.DriverRunTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverRunTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DriverRunTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverRunTemplatePayload>
          }
          findMany: {
            args: Prisma.DriverRunTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverRunTemplatePayload>[]
          }
          create: {
            args: Prisma.DriverRunTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverRunTemplatePayload>
          }
          createMany: {
            args: Prisma.DriverRunTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DriverRunTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverRunTemplatePayload>[]
          }
          delete: {
            args: Prisma.DriverRunTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverRunTemplatePayload>
          }
          update: {
            args: Prisma.DriverRunTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverRunTemplatePayload>
          }
          deleteMany: {
            args: Prisma.DriverRunTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DriverRunTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DriverRunTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverRunTemplatePayload>
          }
          aggregate: {
            args: Prisma.DriverRunTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDriverRunTemplate>
          }
          groupBy: {
            args: Prisma.DriverRunTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<DriverRunTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.DriverRunTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<DriverRunTemplateCountAggregateOutputType> | number
          }
        }
      }
      DutyTemplate: {
        payload: Prisma.$DutyTemplatePayload<ExtArgs>
        fields: Prisma.DutyTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DutyTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DutyTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DutyTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DutyTemplatePayload>
          }
          findFirst: {
            args: Prisma.DutyTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DutyTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DutyTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DutyTemplatePayload>
          }
          findMany: {
            args: Prisma.DutyTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DutyTemplatePayload>[]
          }
          create: {
            args: Prisma.DutyTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DutyTemplatePayload>
          }
          createMany: {
            args: Prisma.DutyTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DutyTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DutyTemplatePayload>[]
          }
          delete: {
            args: Prisma.DutyTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DutyTemplatePayload>
          }
          update: {
            args: Prisma.DutyTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DutyTemplatePayload>
          }
          deleteMany: {
            args: Prisma.DutyTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DutyTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DutyTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DutyTemplatePayload>
          }
          aggregate: {
            args: Prisma.DutyTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDutyTemplate>
          }
          groupBy: {
            args: Prisma.DutyTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<DutyTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.DutyTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<DutyTemplateCountAggregateOutputType> | number
          }
        }
      }
      VehicleBlock: {
        payload: Prisma.$VehicleBlockPayload<ExtArgs>
        fields: Prisma.VehicleBlockFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VehicleBlockFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleBlockPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VehicleBlockFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleBlockPayload>
          }
          findFirst: {
            args: Prisma.VehicleBlockFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleBlockPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VehicleBlockFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleBlockPayload>
          }
          findMany: {
            args: Prisma.VehicleBlockFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleBlockPayload>[]
          }
          create: {
            args: Prisma.VehicleBlockCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleBlockPayload>
          }
          createMany: {
            args: Prisma.VehicleBlockCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VehicleBlockCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleBlockPayload>[]
          }
          delete: {
            args: Prisma.VehicleBlockDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleBlockPayload>
          }
          update: {
            args: Prisma.VehicleBlockUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleBlockPayload>
          }
          deleteMany: {
            args: Prisma.VehicleBlockDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VehicleBlockUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VehicleBlockUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleBlockPayload>
          }
          aggregate: {
            args: Prisma.VehicleBlockAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVehicleBlock>
          }
          groupBy: {
            args: Prisma.VehicleBlockGroupByArgs<ExtArgs>
            result: $Utils.Optional<VehicleBlockGroupByOutputType>[]
          }
          count: {
            args: Prisma.VehicleBlockCountArgs<ExtArgs>
            result: $Utils.Optional<VehicleBlockCountAggregateOutputType> | number
          }
        }
      }
      DriverRun: {
        payload: Prisma.$DriverRunPayload<ExtArgs>
        fields: Prisma.DriverRunFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DriverRunFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverRunPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DriverRunFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverRunPayload>
          }
          findFirst: {
            args: Prisma.DriverRunFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverRunPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DriverRunFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverRunPayload>
          }
          findMany: {
            args: Prisma.DriverRunFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverRunPayload>[]
          }
          create: {
            args: Prisma.DriverRunCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverRunPayload>
          }
          createMany: {
            args: Prisma.DriverRunCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DriverRunCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverRunPayload>[]
          }
          delete: {
            args: Prisma.DriverRunDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverRunPayload>
          }
          update: {
            args: Prisma.DriverRunUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverRunPayload>
          }
          deleteMany: {
            args: Prisma.DriverRunDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DriverRunUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DriverRunUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverRunPayload>
          }
          aggregate: {
            args: Prisma.DriverRunAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDriverRun>
          }
          groupBy: {
            args: Prisma.DriverRunGroupByArgs<ExtArgs>
            result: $Utils.Optional<DriverRunGroupByOutputType>[]
          }
          count: {
            args: Prisma.DriverRunCountArgs<ExtArgs>
            result: $Utils.Optional<DriverRunCountAggregateOutputType> | number
          }
        }
      }
      Duty: {
        payload: Prisma.$DutyPayload<ExtArgs>
        fields: Prisma.DutyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DutyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DutyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DutyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DutyPayload>
          }
          findFirst: {
            args: Prisma.DutyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DutyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DutyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DutyPayload>
          }
          findMany: {
            args: Prisma.DutyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DutyPayload>[]
          }
          create: {
            args: Prisma.DutyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DutyPayload>
          }
          createMany: {
            args: Prisma.DutyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DutyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DutyPayload>[]
          }
          delete: {
            args: Prisma.DutyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DutyPayload>
          }
          update: {
            args: Prisma.DutyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DutyPayload>
          }
          deleteMany: {
            args: Prisma.DutyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DutyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DutyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DutyPayload>
          }
          aggregate: {
            args: Prisma.DutyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDuty>
          }
          groupBy: {
            args: Prisma.DutyGroupByArgs<ExtArgs>
            result: $Utils.Optional<DutyGroupByOutputType>[]
          }
          count: {
            args: Prisma.DutyCountArgs<ExtArgs>
            result: $Utils.Optional<DutyCountAggregateOutputType> | number
          }
        }
      }
      TripDuty: {
        payload: Prisma.$TripDutyPayload<ExtArgs>
        fields: Prisma.TripDutyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TripDutyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripDutyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TripDutyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripDutyPayload>
          }
          findFirst: {
            args: Prisma.TripDutyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripDutyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TripDutyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripDutyPayload>
          }
          findMany: {
            args: Prisma.TripDutyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripDutyPayload>[]
          }
          create: {
            args: Prisma.TripDutyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripDutyPayload>
          }
          createMany: {
            args: Prisma.TripDutyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TripDutyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripDutyPayload>[]
          }
          delete: {
            args: Prisma.TripDutyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripDutyPayload>
          }
          update: {
            args: Prisma.TripDutyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripDutyPayload>
          }
          deleteMany: {
            args: Prisma.TripDutyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TripDutyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TripDutyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripDutyPayload>
          }
          aggregate: {
            args: Prisma.TripDutyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTripDuty>
          }
          groupBy: {
            args: Prisma.TripDutyGroupByArgs<ExtArgs>
            result: $Utils.Optional<TripDutyGroupByOutputType>[]
          }
          count: {
            args: Prisma.TripDutyCountArgs<ExtArgs>
            result: $Utils.Optional<TripDutyCountAggregateOutputType> | number
          }
        }
      }
      WashingDuty: {
        payload: Prisma.$WashingDutyPayload<ExtArgs>
        fields: Prisma.WashingDutyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WashingDutyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WashingDutyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WashingDutyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WashingDutyPayload>
          }
          findFirst: {
            args: Prisma.WashingDutyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WashingDutyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WashingDutyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WashingDutyPayload>
          }
          findMany: {
            args: Prisma.WashingDutyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WashingDutyPayload>[]
          }
          create: {
            args: Prisma.WashingDutyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WashingDutyPayload>
          }
          createMany: {
            args: Prisma.WashingDutyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WashingDutyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WashingDutyPayload>[]
          }
          delete: {
            args: Prisma.WashingDutyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WashingDutyPayload>
          }
          update: {
            args: Prisma.WashingDutyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WashingDutyPayload>
          }
          deleteMany: {
            args: Prisma.WashingDutyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WashingDutyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WashingDutyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WashingDutyPayload>
          }
          aggregate: {
            args: Prisma.WashingDutyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWashingDuty>
          }
          groupBy: {
            args: Prisma.WashingDutyGroupByArgs<ExtArgs>
            result: $Utils.Optional<WashingDutyGroupByOutputType>[]
          }
          count: {
            args: Prisma.WashingDutyCountArgs<ExtArgs>
            result: $Utils.Optional<WashingDutyCountAggregateOutputType> | number
          }
        }
      }
      MaintenanceDuty: {
        payload: Prisma.$MaintenanceDutyPayload<ExtArgs>
        fields: Prisma.MaintenanceDutyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MaintenanceDutyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceDutyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MaintenanceDutyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceDutyPayload>
          }
          findFirst: {
            args: Prisma.MaintenanceDutyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceDutyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MaintenanceDutyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceDutyPayload>
          }
          findMany: {
            args: Prisma.MaintenanceDutyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceDutyPayload>[]
          }
          create: {
            args: Prisma.MaintenanceDutyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceDutyPayload>
          }
          createMany: {
            args: Prisma.MaintenanceDutyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MaintenanceDutyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceDutyPayload>[]
          }
          delete: {
            args: Prisma.MaintenanceDutyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceDutyPayload>
          }
          update: {
            args: Prisma.MaintenanceDutyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceDutyPayload>
          }
          deleteMany: {
            args: Prisma.MaintenanceDutyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MaintenanceDutyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MaintenanceDutyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceDutyPayload>
          }
          aggregate: {
            args: Prisma.MaintenanceDutyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMaintenanceDuty>
          }
          groupBy: {
            args: Prisma.MaintenanceDutyGroupByArgs<ExtArgs>
            result: $Utils.Optional<MaintenanceDutyGroupByOutputType>[]
          }
          count: {
            args: Prisma.MaintenanceDutyCountArgs<ExtArgs>
            result: $Utils.Optional<MaintenanceDutyCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    roles: number
    userActivations: number
    userAuths: number
    drivers: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | UserCountOutputTypeCountRolesArgs
    userActivations?: boolean | UserCountOutputTypeCountUserActivationsArgs
    userAuths?: boolean | UserCountOutputTypeCountUserAuthsArgs
    drivers?: boolean | UserCountOutputTypeCountDriversArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserActivationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserActivationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserAuthsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAuthWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDriversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DriverWhereInput
  }


  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    users: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | RoleCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
  }


  /**
   * Count Type DriverCountOutputType
   */

  export type DriverCountOutputType = {
    trips: number
    shifts: number
    Duty: number
  }

  export type DriverCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trips?: boolean | DriverCountOutputTypeCountTripsArgs
    shifts?: boolean | DriverCountOutputTypeCountShiftsArgs
    Duty?: boolean | DriverCountOutputTypeCountDutyArgs
  }

  // Custom InputTypes
  /**
   * DriverCountOutputType without action
   */
  export type DriverCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverCountOutputType
     */
    select?: DriverCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DriverCountOutputType without action
   */
  export type DriverCountOutputTypeCountTripsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TripWhereInput
  }

  /**
   * DriverCountOutputType without action
   */
  export type DriverCountOutputTypeCountShiftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShiftWhereInput
  }

  /**
   * DriverCountOutputType without action
   */
  export type DriverCountOutputTypeCountDutyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DutyWhereInput
  }


  /**
   * Count Type VehicleModelCountOutputType
   */

  export type VehicleModelCountOutputType = {
    vehicles: number
  }

  export type VehicleModelCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vehicles?: boolean | VehicleModelCountOutputTypeCountVehiclesArgs
  }

  // Custom InputTypes
  /**
   * VehicleModelCountOutputType without action
   */
  export type VehicleModelCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleModelCountOutputType
     */
    select?: VehicleModelCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VehicleModelCountOutputType without action
   */
  export type VehicleModelCountOutputTypeCountVehiclesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VehicleWhereInput
  }


  /**
   * Count Type VehicleCountOutputType
   */

  export type VehicleCountOutputType = {
    trips: number
    shifts: number
    telemetry: number
    telemetryHistory: number
    Duty: number
  }

  export type VehicleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trips?: boolean | VehicleCountOutputTypeCountTripsArgs
    shifts?: boolean | VehicleCountOutputTypeCountShiftsArgs
    telemetry?: boolean | VehicleCountOutputTypeCountTelemetryArgs
    telemetryHistory?: boolean | VehicleCountOutputTypeCountTelemetryHistoryArgs
    Duty?: boolean | VehicleCountOutputTypeCountDutyArgs
  }

  // Custom InputTypes
  /**
   * VehicleCountOutputType without action
   */
  export type VehicleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleCountOutputType
     */
    select?: VehicleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VehicleCountOutputType without action
   */
  export type VehicleCountOutputTypeCountTripsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TripWhereInput
  }

  /**
   * VehicleCountOutputType without action
   */
  export type VehicleCountOutputTypeCountShiftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShiftWhereInput
  }

  /**
   * VehicleCountOutputType without action
   */
  export type VehicleCountOutputTypeCountTelemetryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VehicleTelemetryWhereInput
  }

  /**
   * VehicleCountOutputType without action
   */
  export type VehicleCountOutputTypeCountTelemetryHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VehicleTelemetryHistoryWhereInput
  }

  /**
   * VehicleCountOutputType without action
   */
  export type VehicleCountOutputTypeCountDutyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DutyWhereInput
  }


  /**
   * Count Type LocationCountOutputType
   */

  export type LocationCountOutputType = {
    stops: number
  }

  export type LocationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stops?: boolean | LocationCountOutputTypeCountStopsArgs
  }

  // Custom InputTypes
  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationCountOutputType
     */
    select?: LocationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountStopsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StopWhereInput
  }


  /**
   * Count Type StopCountOutputType
   */

  export type StopCountOutputType = {
    routeStops: number
    tripStops: number
  }

  export type StopCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    routeStops?: boolean | StopCountOutputTypeCountRouteStopsArgs
    tripStops?: boolean | StopCountOutputTypeCountTripStopsArgs
  }

  // Custom InputTypes
  /**
   * StopCountOutputType without action
   */
  export type StopCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StopCountOutputType
     */
    select?: StopCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StopCountOutputType without action
   */
  export type StopCountOutputTypeCountRouteStopsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RouteStopWhereInput
  }

  /**
   * StopCountOutputType without action
   */
  export type StopCountOutputTypeCountTripStopsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TripStopWhereInput
  }


  /**
   * Count Type RouteCountOutputType
   */

  export type RouteCountOutputType = {
    routeStops: number
    trips: number
    TripDuty: number
  }

  export type RouteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    routeStops?: boolean | RouteCountOutputTypeCountRouteStopsArgs
    trips?: boolean | RouteCountOutputTypeCountTripsArgs
    TripDuty?: boolean | RouteCountOutputTypeCountTripDutyArgs
  }

  // Custom InputTypes
  /**
   * RouteCountOutputType without action
   */
  export type RouteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteCountOutputType
     */
    select?: RouteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RouteCountOutputType without action
   */
  export type RouteCountOutputTypeCountRouteStopsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RouteStopWhereInput
  }

  /**
   * RouteCountOutputType without action
   */
  export type RouteCountOutputTypeCountTripsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TripWhereInput
  }

  /**
   * RouteCountOutputType without action
   */
  export type RouteCountOutputTypeCountTripDutyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TripDutyWhereInput
  }


  /**
   * Count Type TripCountOutputType
   */

  export type TripCountOutputType = {
    tripStops: number
  }

  export type TripCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tripStops?: boolean | TripCountOutputTypeCountTripStopsArgs
  }

  // Custom InputTypes
  /**
   * TripCountOutputType without action
   */
  export type TripCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripCountOutputType
     */
    select?: TripCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TripCountOutputType without action
   */
  export type TripCountOutputTypeCountTripStopsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TripStopWhereInput
  }


  /**
   * Count Type ServiceScheduleCountOutputType
   */

  export type ServiceScheduleCountOutputType = {
    dutyTemplates: number
    vehicleBlockTemplates: number
    driverRunTemplates: number
  }

  export type ServiceScheduleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dutyTemplates?: boolean | ServiceScheduleCountOutputTypeCountDutyTemplatesArgs
    vehicleBlockTemplates?: boolean | ServiceScheduleCountOutputTypeCountVehicleBlockTemplatesArgs
    driverRunTemplates?: boolean | ServiceScheduleCountOutputTypeCountDriverRunTemplatesArgs
  }

  // Custom InputTypes
  /**
   * ServiceScheduleCountOutputType without action
   */
  export type ServiceScheduleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceScheduleCountOutputType
     */
    select?: ServiceScheduleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceScheduleCountOutputType without action
   */
  export type ServiceScheduleCountOutputTypeCountDutyTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DutyTemplateWhereInput
  }

  /**
   * ServiceScheduleCountOutputType without action
   */
  export type ServiceScheduleCountOutputTypeCountVehicleBlockTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VehicleBlockTemplateWhereInput
  }

  /**
   * ServiceScheduleCountOutputType without action
   */
  export type ServiceScheduleCountOutputTypeCountDriverRunTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DriverRunTemplateWhereInput
  }


  /**
   * Count Type VehicleBlockTemplateCountOutputType
   */

  export type VehicleBlockTemplateCountOutputType = {
    DutyTemplate: number
    VehicleBlock: number
  }

  export type VehicleBlockTemplateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DutyTemplate?: boolean | VehicleBlockTemplateCountOutputTypeCountDutyTemplateArgs
    VehicleBlock?: boolean | VehicleBlockTemplateCountOutputTypeCountVehicleBlockArgs
  }

  // Custom InputTypes
  /**
   * VehicleBlockTemplateCountOutputType without action
   */
  export type VehicleBlockTemplateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleBlockTemplateCountOutputType
     */
    select?: VehicleBlockTemplateCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VehicleBlockTemplateCountOutputType without action
   */
  export type VehicleBlockTemplateCountOutputTypeCountDutyTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DutyTemplateWhereInput
  }

  /**
   * VehicleBlockTemplateCountOutputType without action
   */
  export type VehicleBlockTemplateCountOutputTypeCountVehicleBlockArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VehicleBlockWhereInput
  }


  /**
   * Count Type DriverRunTemplateCountOutputType
   */

  export type DriverRunTemplateCountOutputType = {
    DutyTemplate: number
    DriverRun: number
  }

  export type DriverRunTemplateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DutyTemplate?: boolean | DriverRunTemplateCountOutputTypeCountDutyTemplateArgs
    DriverRun?: boolean | DriverRunTemplateCountOutputTypeCountDriverRunArgs
  }

  // Custom InputTypes
  /**
   * DriverRunTemplateCountOutputType without action
   */
  export type DriverRunTemplateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverRunTemplateCountOutputType
     */
    select?: DriverRunTemplateCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DriverRunTemplateCountOutputType without action
   */
  export type DriverRunTemplateCountOutputTypeCountDutyTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DutyTemplateWhereInput
  }

  /**
   * DriverRunTemplateCountOutputType without action
   */
  export type DriverRunTemplateCountOutputTypeCountDriverRunArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DriverRunWhereInput
  }


  /**
   * Count Type VehicleBlockCountOutputType
   */

  export type VehicleBlockCountOutputType = {
    Duty: number
  }

  export type VehicleBlockCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Duty?: boolean | VehicleBlockCountOutputTypeCountDutyArgs
  }

  // Custom InputTypes
  /**
   * VehicleBlockCountOutputType without action
   */
  export type VehicleBlockCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleBlockCountOutputType
     */
    select?: VehicleBlockCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VehicleBlockCountOutputType without action
   */
  export type VehicleBlockCountOutputTypeCountDutyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DutyWhereInput
  }


  /**
   * Count Type DriverRunCountOutputType
   */

  export type DriverRunCountOutputType = {
    Duty: number
  }

  export type DriverRunCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Duty?: boolean | DriverRunCountOutputTypeCountDutyArgs
  }

  // Custom InputTypes
  /**
   * DriverRunCountOutputType without action
   */
  export type DriverRunCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverRunCountOutputType
     */
    select?: DriverRunCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DriverRunCountOutputType without action
   */
  export type DriverRunCountOutputTypeCountDutyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DutyWhereInput
  }


  /**
   * Count Type DutyCountOutputType
   */

  export type DutyCountOutputType = {
    tripDuties: number
    washingDuties: number
    maintenanceDuties: number
  }

  export type DutyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tripDuties?: boolean | DutyCountOutputTypeCountTripDutiesArgs
    washingDuties?: boolean | DutyCountOutputTypeCountWashingDutiesArgs
    maintenanceDuties?: boolean | DutyCountOutputTypeCountMaintenanceDutiesArgs
  }

  // Custom InputTypes
  /**
   * DutyCountOutputType without action
   */
  export type DutyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DutyCountOutputType
     */
    select?: DutyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DutyCountOutputType without action
   */
  export type DutyCountOutputTypeCountTripDutiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TripDutyWhereInput
  }

  /**
   * DutyCountOutputType without action
   */
  export type DutyCountOutputTypeCountWashingDutiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WashingDutyWhereInput
  }

  /**
   * DutyCountOutputType without action
   */
  export type DutyCountOutputTypeCountMaintenanceDutiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaintenanceDutyWhereInput
  }


  /**
   * Models
   */

  /**
   * Model UserAuth
   */

  export type AggregateUserAuth = {
    _count: UserAuthCountAggregateOutputType | null
    _avg: UserAuthAvgAggregateOutputType | null
    _sum: UserAuthSumAggregateOutputType | null
    _min: UserAuthMinAggregateOutputType | null
    _max: UserAuthMaxAggregateOutputType | null
  }

  export type UserAuthAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type UserAuthSumAggregateOutputType = {
    id: bigint | null
    userId: bigint | null
  }

  export type UserAuthMinAggregateOutputType = {
    id: bigint | null
    userId: bigint | null
    userType: string | null
    provider: string | null
    identifier: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserAuthMaxAggregateOutputType = {
    id: bigint | null
    userId: bigint | null
    userType: string | null
    provider: string | null
    identifier: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserAuthCountAggregateOutputType = {
    id: number
    userId: number
    userType: number
    provider: number
    identifier: number
    password: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAuthAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type UserAuthSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type UserAuthMinAggregateInputType = {
    id?: true
    userId?: true
    userType?: true
    provider?: true
    identifier?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserAuthMaxAggregateInputType = {
    id?: true
    userId?: true
    userType?: true
    provider?: true
    identifier?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserAuthCountAggregateInputType = {
    id?: true
    userId?: true
    userType?: true
    provider?: true
    identifier?: true
    password?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAuthAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAuth to aggregate.
     */
    where?: UserAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAuths to fetch.
     */
    orderBy?: UserAuthOrderByWithRelationInput | UserAuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAuths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserAuths
    **/
    _count?: true | UserAuthCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAuthAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserAuthSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserAuthMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserAuthMaxAggregateInputType
  }

  export type GetUserAuthAggregateType<T extends UserAuthAggregateArgs> = {
        [P in keyof T & keyof AggregateUserAuth]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserAuth[P]>
      : GetScalarType<T[P], AggregateUserAuth[P]>
  }




  export type UserAuthGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAuthWhereInput
    orderBy?: UserAuthOrderByWithAggregationInput | UserAuthOrderByWithAggregationInput[]
    by: UserAuthScalarFieldEnum[] | UserAuthScalarFieldEnum
    having?: UserAuthScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserAuthCountAggregateInputType | true
    _avg?: UserAuthAvgAggregateInputType
    _sum?: UserAuthSumAggregateInputType
    _min?: UserAuthMinAggregateInputType
    _max?: UserAuthMaxAggregateInputType
  }

  export type UserAuthGroupByOutputType = {
    id: bigint
    userId: bigint
    userType: string
    provider: string
    identifier: string
    password: string
    createdAt: Date
    updatedAt: Date
    _count: UserAuthCountAggregateOutputType | null
    _avg: UserAuthAvgAggregateOutputType | null
    _sum: UserAuthSumAggregateOutputType | null
    _min: UserAuthMinAggregateOutputType | null
    _max: UserAuthMaxAggregateOutputType | null
  }

  type GetUserAuthGroupByPayload<T extends UserAuthGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserAuthGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserAuthGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserAuthGroupByOutputType[P]>
            : GetScalarType<T[P], UserAuthGroupByOutputType[P]>
        }
      >
    >


  export type UserAuthSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    userType?: boolean
    provider?: boolean
    identifier?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAuth"]>

  export type UserAuthSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    userType?: boolean
    provider?: boolean
    identifier?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAuth"]>

  export type UserAuthSelectScalar = {
    id?: boolean
    userId?: boolean
    userType?: boolean
    provider?: boolean
    identifier?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserAuthInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserAuthIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserAuthPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserAuth"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      userId: bigint
      userType: string
      provider: string
      identifier: string
      password: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userAuth"]>
    composites: {}
  }

  type UserAuthGetPayload<S extends boolean | null | undefined | UserAuthDefaultArgs> = $Result.GetResult<Prisma.$UserAuthPayload, S>

  type UserAuthCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserAuthFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserAuthCountAggregateInputType | true
    }

  export interface UserAuthDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserAuth'], meta: { name: 'UserAuth' } }
    /**
     * Find zero or one UserAuth that matches the filter.
     * @param {UserAuthFindUniqueArgs} args - Arguments to find a UserAuth
     * @example
     * // Get one UserAuth
     * const userAuth = await prisma.userAuth.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserAuthFindUniqueArgs>(args: SelectSubset<T, UserAuthFindUniqueArgs<ExtArgs>>): Prisma__UserAuthClient<$Result.GetResult<Prisma.$UserAuthPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserAuth that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserAuthFindUniqueOrThrowArgs} args - Arguments to find a UserAuth
     * @example
     * // Get one UserAuth
     * const userAuth = await prisma.userAuth.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserAuthFindUniqueOrThrowArgs>(args: SelectSubset<T, UserAuthFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserAuthClient<$Result.GetResult<Prisma.$UserAuthPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserAuth that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAuthFindFirstArgs} args - Arguments to find a UserAuth
     * @example
     * // Get one UserAuth
     * const userAuth = await prisma.userAuth.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserAuthFindFirstArgs>(args?: SelectSubset<T, UserAuthFindFirstArgs<ExtArgs>>): Prisma__UserAuthClient<$Result.GetResult<Prisma.$UserAuthPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserAuth that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAuthFindFirstOrThrowArgs} args - Arguments to find a UserAuth
     * @example
     * // Get one UserAuth
     * const userAuth = await prisma.userAuth.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserAuthFindFirstOrThrowArgs>(args?: SelectSubset<T, UserAuthFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserAuthClient<$Result.GetResult<Prisma.$UserAuthPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserAuths that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAuthFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserAuths
     * const userAuths = await prisma.userAuth.findMany()
     * 
     * // Get first 10 UserAuths
     * const userAuths = await prisma.userAuth.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userAuthWithIdOnly = await prisma.userAuth.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserAuthFindManyArgs>(args?: SelectSubset<T, UserAuthFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAuthPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserAuth.
     * @param {UserAuthCreateArgs} args - Arguments to create a UserAuth.
     * @example
     * // Create one UserAuth
     * const UserAuth = await prisma.userAuth.create({
     *   data: {
     *     // ... data to create a UserAuth
     *   }
     * })
     * 
     */
    create<T extends UserAuthCreateArgs>(args: SelectSubset<T, UserAuthCreateArgs<ExtArgs>>): Prisma__UserAuthClient<$Result.GetResult<Prisma.$UserAuthPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserAuths.
     * @param {UserAuthCreateManyArgs} args - Arguments to create many UserAuths.
     * @example
     * // Create many UserAuths
     * const userAuth = await prisma.userAuth.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserAuthCreateManyArgs>(args?: SelectSubset<T, UserAuthCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserAuths and returns the data saved in the database.
     * @param {UserAuthCreateManyAndReturnArgs} args - Arguments to create many UserAuths.
     * @example
     * // Create many UserAuths
     * const userAuth = await prisma.userAuth.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserAuths and only return the `id`
     * const userAuthWithIdOnly = await prisma.userAuth.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserAuthCreateManyAndReturnArgs>(args?: SelectSubset<T, UserAuthCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAuthPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserAuth.
     * @param {UserAuthDeleteArgs} args - Arguments to delete one UserAuth.
     * @example
     * // Delete one UserAuth
     * const UserAuth = await prisma.userAuth.delete({
     *   where: {
     *     // ... filter to delete one UserAuth
     *   }
     * })
     * 
     */
    delete<T extends UserAuthDeleteArgs>(args: SelectSubset<T, UserAuthDeleteArgs<ExtArgs>>): Prisma__UserAuthClient<$Result.GetResult<Prisma.$UserAuthPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserAuth.
     * @param {UserAuthUpdateArgs} args - Arguments to update one UserAuth.
     * @example
     * // Update one UserAuth
     * const userAuth = await prisma.userAuth.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserAuthUpdateArgs>(args: SelectSubset<T, UserAuthUpdateArgs<ExtArgs>>): Prisma__UserAuthClient<$Result.GetResult<Prisma.$UserAuthPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserAuths.
     * @param {UserAuthDeleteManyArgs} args - Arguments to filter UserAuths to delete.
     * @example
     * // Delete a few UserAuths
     * const { count } = await prisma.userAuth.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserAuthDeleteManyArgs>(args?: SelectSubset<T, UserAuthDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAuths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAuthUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserAuths
     * const userAuth = await prisma.userAuth.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserAuthUpdateManyArgs>(args: SelectSubset<T, UserAuthUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserAuth.
     * @param {UserAuthUpsertArgs} args - Arguments to update or create a UserAuth.
     * @example
     * // Update or create a UserAuth
     * const userAuth = await prisma.userAuth.upsert({
     *   create: {
     *     // ... data to create a UserAuth
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserAuth we want to update
     *   }
     * })
     */
    upsert<T extends UserAuthUpsertArgs>(args: SelectSubset<T, UserAuthUpsertArgs<ExtArgs>>): Prisma__UserAuthClient<$Result.GetResult<Prisma.$UserAuthPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserAuths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAuthCountArgs} args - Arguments to filter UserAuths to count.
     * @example
     * // Count the number of UserAuths
     * const count = await prisma.userAuth.count({
     *   where: {
     *     // ... the filter for the UserAuths we want to count
     *   }
     * })
    **/
    count<T extends UserAuthCountArgs>(
      args?: Subset<T, UserAuthCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserAuthCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserAuth.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAuthAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAuthAggregateArgs>(args: Subset<T, UserAuthAggregateArgs>): Prisma.PrismaPromise<GetUserAuthAggregateType<T>>

    /**
     * Group by UserAuth.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAuthGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserAuthGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserAuthGroupByArgs['orderBy'] }
        : { orderBy?: UserAuthGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserAuthGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserAuthGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserAuth model
   */
  readonly fields: UserAuthFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserAuth.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserAuthClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserAuth model
   */ 
  interface UserAuthFieldRefs {
    readonly id: FieldRef<"UserAuth", 'BigInt'>
    readonly userId: FieldRef<"UserAuth", 'BigInt'>
    readonly userType: FieldRef<"UserAuth", 'String'>
    readonly provider: FieldRef<"UserAuth", 'String'>
    readonly identifier: FieldRef<"UserAuth", 'String'>
    readonly password: FieldRef<"UserAuth", 'String'>
    readonly createdAt: FieldRef<"UserAuth", 'DateTime'>
    readonly updatedAt: FieldRef<"UserAuth", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserAuth findUnique
   */
  export type UserAuthFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAuth
     */
    select?: UserAuthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAuthInclude<ExtArgs> | null
    /**
     * Filter, which UserAuth to fetch.
     */
    where: UserAuthWhereUniqueInput
  }

  /**
   * UserAuth findUniqueOrThrow
   */
  export type UserAuthFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAuth
     */
    select?: UserAuthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAuthInclude<ExtArgs> | null
    /**
     * Filter, which UserAuth to fetch.
     */
    where: UserAuthWhereUniqueInput
  }

  /**
   * UserAuth findFirst
   */
  export type UserAuthFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAuth
     */
    select?: UserAuthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAuthInclude<ExtArgs> | null
    /**
     * Filter, which UserAuth to fetch.
     */
    where?: UserAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAuths to fetch.
     */
    orderBy?: UserAuthOrderByWithRelationInput | UserAuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAuths.
     */
    cursor?: UserAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAuths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAuths.
     */
    distinct?: UserAuthScalarFieldEnum | UserAuthScalarFieldEnum[]
  }

  /**
   * UserAuth findFirstOrThrow
   */
  export type UserAuthFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAuth
     */
    select?: UserAuthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAuthInclude<ExtArgs> | null
    /**
     * Filter, which UserAuth to fetch.
     */
    where?: UserAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAuths to fetch.
     */
    orderBy?: UserAuthOrderByWithRelationInput | UserAuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAuths.
     */
    cursor?: UserAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAuths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAuths.
     */
    distinct?: UserAuthScalarFieldEnum | UserAuthScalarFieldEnum[]
  }

  /**
   * UserAuth findMany
   */
  export type UserAuthFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAuth
     */
    select?: UserAuthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAuthInclude<ExtArgs> | null
    /**
     * Filter, which UserAuths to fetch.
     */
    where?: UserAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAuths to fetch.
     */
    orderBy?: UserAuthOrderByWithRelationInput | UserAuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserAuths.
     */
    cursor?: UserAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAuths.
     */
    skip?: number
    distinct?: UserAuthScalarFieldEnum | UserAuthScalarFieldEnum[]
  }

  /**
   * UserAuth create
   */
  export type UserAuthCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAuth
     */
    select?: UserAuthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAuthInclude<ExtArgs> | null
    /**
     * The data needed to create a UserAuth.
     */
    data: XOR<UserAuthCreateInput, UserAuthUncheckedCreateInput>
  }

  /**
   * UserAuth createMany
   */
  export type UserAuthCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserAuths.
     */
    data: UserAuthCreateManyInput | UserAuthCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserAuth createManyAndReturn
   */
  export type UserAuthCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAuth
     */
    select?: UserAuthSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserAuths.
     */
    data: UserAuthCreateManyInput | UserAuthCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAuthIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserAuth update
   */
  export type UserAuthUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAuth
     */
    select?: UserAuthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAuthInclude<ExtArgs> | null
    /**
     * The data needed to update a UserAuth.
     */
    data: XOR<UserAuthUpdateInput, UserAuthUncheckedUpdateInput>
    /**
     * Choose, which UserAuth to update.
     */
    where: UserAuthWhereUniqueInput
  }

  /**
   * UserAuth updateMany
   */
  export type UserAuthUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserAuths.
     */
    data: XOR<UserAuthUpdateManyMutationInput, UserAuthUncheckedUpdateManyInput>
    /**
     * Filter which UserAuths to update
     */
    where?: UserAuthWhereInput
  }

  /**
   * UserAuth upsert
   */
  export type UserAuthUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAuth
     */
    select?: UserAuthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAuthInclude<ExtArgs> | null
    /**
     * The filter to search for the UserAuth to update in case it exists.
     */
    where: UserAuthWhereUniqueInput
    /**
     * In case the UserAuth found by the `where` argument doesn't exist, create a new UserAuth with this data.
     */
    create: XOR<UserAuthCreateInput, UserAuthUncheckedCreateInput>
    /**
     * In case the UserAuth was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserAuthUpdateInput, UserAuthUncheckedUpdateInput>
  }

  /**
   * UserAuth delete
   */
  export type UserAuthDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAuth
     */
    select?: UserAuthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAuthInclude<ExtArgs> | null
    /**
     * Filter which UserAuth to delete.
     */
    where: UserAuthWhereUniqueInput
  }

  /**
   * UserAuth deleteMany
   */
  export type UserAuthDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAuths to delete
     */
    where?: UserAuthWhereInput
  }

  /**
   * UserAuth without action
   */
  export type UserAuthDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAuth
     */
    select?: UserAuthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAuthInclude<ExtArgs> | null
  }


  /**
   * Model UserActivation
   */

  export type AggregateUserActivation = {
    _count: UserActivationCountAggregateOutputType | null
    _avg: UserActivationAvgAggregateOutputType | null
    _sum: UserActivationSumAggregateOutputType | null
    _min: UserActivationMinAggregateOutputType | null
    _max: UserActivationMaxAggregateOutputType | null
  }

  export type UserActivationAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type UserActivationSumAggregateOutputType = {
    id: bigint | null
    userId: bigint | null
  }

  export type UserActivationMinAggregateOutputType = {
    id: bigint | null
    userId: bigint | null
    activationCode: string | null
    expiresAt: Date | null
    isUsed: boolean | null
    createdAt: Date | null
  }

  export type UserActivationMaxAggregateOutputType = {
    id: bigint | null
    userId: bigint | null
    activationCode: string | null
    expiresAt: Date | null
    isUsed: boolean | null
    createdAt: Date | null
  }

  export type UserActivationCountAggregateOutputType = {
    id: number
    userId: number
    activationCode: number
    expiresAt: number
    isUsed: number
    createdAt: number
    _all: number
  }


  export type UserActivationAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type UserActivationSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type UserActivationMinAggregateInputType = {
    id?: true
    userId?: true
    activationCode?: true
    expiresAt?: true
    isUsed?: true
    createdAt?: true
  }

  export type UserActivationMaxAggregateInputType = {
    id?: true
    userId?: true
    activationCode?: true
    expiresAt?: true
    isUsed?: true
    createdAt?: true
  }

  export type UserActivationCountAggregateInputType = {
    id?: true
    userId?: true
    activationCode?: true
    expiresAt?: true
    isUsed?: true
    createdAt?: true
    _all?: true
  }

  export type UserActivationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserActivation to aggregate.
     */
    where?: UserActivationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserActivations to fetch.
     */
    orderBy?: UserActivationOrderByWithRelationInput | UserActivationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserActivationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserActivations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserActivations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserActivations
    **/
    _count?: true | UserActivationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserActivationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserActivationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserActivationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserActivationMaxAggregateInputType
  }

  export type GetUserActivationAggregateType<T extends UserActivationAggregateArgs> = {
        [P in keyof T & keyof AggregateUserActivation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserActivation[P]>
      : GetScalarType<T[P], AggregateUserActivation[P]>
  }




  export type UserActivationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserActivationWhereInput
    orderBy?: UserActivationOrderByWithAggregationInput | UserActivationOrderByWithAggregationInput[]
    by: UserActivationScalarFieldEnum[] | UserActivationScalarFieldEnum
    having?: UserActivationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserActivationCountAggregateInputType | true
    _avg?: UserActivationAvgAggregateInputType
    _sum?: UserActivationSumAggregateInputType
    _min?: UserActivationMinAggregateInputType
    _max?: UserActivationMaxAggregateInputType
  }

  export type UserActivationGroupByOutputType = {
    id: bigint
    userId: bigint
    activationCode: string
    expiresAt: Date
    isUsed: boolean
    createdAt: Date
    _count: UserActivationCountAggregateOutputType | null
    _avg: UserActivationAvgAggregateOutputType | null
    _sum: UserActivationSumAggregateOutputType | null
    _min: UserActivationMinAggregateOutputType | null
    _max: UserActivationMaxAggregateOutputType | null
  }

  type GetUserActivationGroupByPayload<T extends UserActivationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserActivationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserActivationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserActivationGroupByOutputType[P]>
            : GetScalarType<T[P], UserActivationGroupByOutputType[P]>
        }
      >
    >


  export type UserActivationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    activationCode?: boolean
    expiresAt?: boolean
    isUsed?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userActivation"]>

  export type UserActivationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    activationCode?: boolean
    expiresAt?: boolean
    isUsed?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userActivation"]>

  export type UserActivationSelectScalar = {
    id?: boolean
    userId?: boolean
    activationCode?: boolean
    expiresAt?: boolean
    isUsed?: boolean
    createdAt?: boolean
  }

  export type UserActivationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserActivationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserActivationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserActivation"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      userId: bigint
      activationCode: string
      expiresAt: Date
      isUsed: boolean
      createdAt: Date
    }, ExtArgs["result"]["userActivation"]>
    composites: {}
  }

  type UserActivationGetPayload<S extends boolean | null | undefined | UserActivationDefaultArgs> = $Result.GetResult<Prisma.$UserActivationPayload, S>

  type UserActivationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserActivationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserActivationCountAggregateInputType | true
    }

  export interface UserActivationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserActivation'], meta: { name: 'UserActivation' } }
    /**
     * Find zero or one UserActivation that matches the filter.
     * @param {UserActivationFindUniqueArgs} args - Arguments to find a UserActivation
     * @example
     * // Get one UserActivation
     * const userActivation = await prisma.userActivation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserActivationFindUniqueArgs>(args: SelectSubset<T, UserActivationFindUniqueArgs<ExtArgs>>): Prisma__UserActivationClient<$Result.GetResult<Prisma.$UserActivationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserActivation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserActivationFindUniqueOrThrowArgs} args - Arguments to find a UserActivation
     * @example
     * // Get one UserActivation
     * const userActivation = await prisma.userActivation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserActivationFindUniqueOrThrowArgs>(args: SelectSubset<T, UserActivationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserActivationClient<$Result.GetResult<Prisma.$UserActivationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserActivation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserActivationFindFirstArgs} args - Arguments to find a UserActivation
     * @example
     * // Get one UserActivation
     * const userActivation = await prisma.userActivation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserActivationFindFirstArgs>(args?: SelectSubset<T, UserActivationFindFirstArgs<ExtArgs>>): Prisma__UserActivationClient<$Result.GetResult<Prisma.$UserActivationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserActivation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserActivationFindFirstOrThrowArgs} args - Arguments to find a UserActivation
     * @example
     * // Get one UserActivation
     * const userActivation = await prisma.userActivation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserActivationFindFirstOrThrowArgs>(args?: SelectSubset<T, UserActivationFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserActivationClient<$Result.GetResult<Prisma.$UserActivationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserActivations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserActivationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserActivations
     * const userActivations = await prisma.userActivation.findMany()
     * 
     * // Get first 10 UserActivations
     * const userActivations = await prisma.userActivation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userActivationWithIdOnly = await prisma.userActivation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserActivationFindManyArgs>(args?: SelectSubset<T, UserActivationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserActivationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserActivation.
     * @param {UserActivationCreateArgs} args - Arguments to create a UserActivation.
     * @example
     * // Create one UserActivation
     * const UserActivation = await prisma.userActivation.create({
     *   data: {
     *     // ... data to create a UserActivation
     *   }
     * })
     * 
     */
    create<T extends UserActivationCreateArgs>(args: SelectSubset<T, UserActivationCreateArgs<ExtArgs>>): Prisma__UserActivationClient<$Result.GetResult<Prisma.$UserActivationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserActivations.
     * @param {UserActivationCreateManyArgs} args - Arguments to create many UserActivations.
     * @example
     * // Create many UserActivations
     * const userActivation = await prisma.userActivation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserActivationCreateManyArgs>(args?: SelectSubset<T, UserActivationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserActivations and returns the data saved in the database.
     * @param {UserActivationCreateManyAndReturnArgs} args - Arguments to create many UserActivations.
     * @example
     * // Create many UserActivations
     * const userActivation = await prisma.userActivation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserActivations and only return the `id`
     * const userActivationWithIdOnly = await prisma.userActivation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserActivationCreateManyAndReturnArgs>(args?: SelectSubset<T, UserActivationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserActivationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserActivation.
     * @param {UserActivationDeleteArgs} args - Arguments to delete one UserActivation.
     * @example
     * // Delete one UserActivation
     * const UserActivation = await prisma.userActivation.delete({
     *   where: {
     *     // ... filter to delete one UserActivation
     *   }
     * })
     * 
     */
    delete<T extends UserActivationDeleteArgs>(args: SelectSubset<T, UserActivationDeleteArgs<ExtArgs>>): Prisma__UserActivationClient<$Result.GetResult<Prisma.$UserActivationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserActivation.
     * @param {UserActivationUpdateArgs} args - Arguments to update one UserActivation.
     * @example
     * // Update one UserActivation
     * const userActivation = await prisma.userActivation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserActivationUpdateArgs>(args: SelectSubset<T, UserActivationUpdateArgs<ExtArgs>>): Prisma__UserActivationClient<$Result.GetResult<Prisma.$UserActivationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserActivations.
     * @param {UserActivationDeleteManyArgs} args - Arguments to filter UserActivations to delete.
     * @example
     * // Delete a few UserActivations
     * const { count } = await prisma.userActivation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserActivationDeleteManyArgs>(args?: SelectSubset<T, UserActivationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserActivations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserActivationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserActivations
     * const userActivation = await prisma.userActivation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserActivationUpdateManyArgs>(args: SelectSubset<T, UserActivationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserActivation.
     * @param {UserActivationUpsertArgs} args - Arguments to update or create a UserActivation.
     * @example
     * // Update or create a UserActivation
     * const userActivation = await prisma.userActivation.upsert({
     *   create: {
     *     // ... data to create a UserActivation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserActivation we want to update
     *   }
     * })
     */
    upsert<T extends UserActivationUpsertArgs>(args: SelectSubset<T, UserActivationUpsertArgs<ExtArgs>>): Prisma__UserActivationClient<$Result.GetResult<Prisma.$UserActivationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserActivations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserActivationCountArgs} args - Arguments to filter UserActivations to count.
     * @example
     * // Count the number of UserActivations
     * const count = await prisma.userActivation.count({
     *   where: {
     *     // ... the filter for the UserActivations we want to count
     *   }
     * })
    **/
    count<T extends UserActivationCountArgs>(
      args?: Subset<T, UserActivationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserActivationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserActivation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserActivationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserActivationAggregateArgs>(args: Subset<T, UserActivationAggregateArgs>): Prisma.PrismaPromise<GetUserActivationAggregateType<T>>

    /**
     * Group by UserActivation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserActivationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserActivationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserActivationGroupByArgs['orderBy'] }
        : { orderBy?: UserActivationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserActivationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserActivationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserActivation model
   */
  readonly fields: UserActivationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserActivation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserActivationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserActivation model
   */ 
  interface UserActivationFieldRefs {
    readonly id: FieldRef<"UserActivation", 'BigInt'>
    readonly userId: FieldRef<"UserActivation", 'BigInt'>
    readonly activationCode: FieldRef<"UserActivation", 'String'>
    readonly expiresAt: FieldRef<"UserActivation", 'DateTime'>
    readonly isUsed: FieldRef<"UserActivation", 'Boolean'>
    readonly createdAt: FieldRef<"UserActivation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserActivation findUnique
   */
  export type UserActivationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivation
     */
    select?: UserActivationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserActivationInclude<ExtArgs> | null
    /**
     * Filter, which UserActivation to fetch.
     */
    where: UserActivationWhereUniqueInput
  }

  /**
   * UserActivation findUniqueOrThrow
   */
  export type UserActivationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivation
     */
    select?: UserActivationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserActivationInclude<ExtArgs> | null
    /**
     * Filter, which UserActivation to fetch.
     */
    where: UserActivationWhereUniqueInput
  }

  /**
   * UserActivation findFirst
   */
  export type UserActivationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivation
     */
    select?: UserActivationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserActivationInclude<ExtArgs> | null
    /**
     * Filter, which UserActivation to fetch.
     */
    where?: UserActivationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserActivations to fetch.
     */
    orderBy?: UserActivationOrderByWithRelationInput | UserActivationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserActivations.
     */
    cursor?: UserActivationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserActivations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserActivations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserActivations.
     */
    distinct?: UserActivationScalarFieldEnum | UserActivationScalarFieldEnum[]
  }

  /**
   * UserActivation findFirstOrThrow
   */
  export type UserActivationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivation
     */
    select?: UserActivationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserActivationInclude<ExtArgs> | null
    /**
     * Filter, which UserActivation to fetch.
     */
    where?: UserActivationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserActivations to fetch.
     */
    orderBy?: UserActivationOrderByWithRelationInput | UserActivationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserActivations.
     */
    cursor?: UserActivationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserActivations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserActivations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserActivations.
     */
    distinct?: UserActivationScalarFieldEnum | UserActivationScalarFieldEnum[]
  }

  /**
   * UserActivation findMany
   */
  export type UserActivationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivation
     */
    select?: UserActivationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserActivationInclude<ExtArgs> | null
    /**
     * Filter, which UserActivations to fetch.
     */
    where?: UserActivationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserActivations to fetch.
     */
    orderBy?: UserActivationOrderByWithRelationInput | UserActivationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserActivations.
     */
    cursor?: UserActivationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserActivations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserActivations.
     */
    skip?: number
    distinct?: UserActivationScalarFieldEnum | UserActivationScalarFieldEnum[]
  }

  /**
   * UserActivation create
   */
  export type UserActivationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivation
     */
    select?: UserActivationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserActivationInclude<ExtArgs> | null
    /**
     * The data needed to create a UserActivation.
     */
    data: XOR<UserActivationCreateInput, UserActivationUncheckedCreateInput>
  }

  /**
   * UserActivation createMany
   */
  export type UserActivationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserActivations.
     */
    data: UserActivationCreateManyInput | UserActivationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserActivation createManyAndReturn
   */
  export type UserActivationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivation
     */
    select?: UserActivationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserActivations.
     */
    data: UserActivationCreateManyInput | UserActivationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserActivationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserActivation update
   */
  export type UserActivationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivation
     */
    select?: UserActivationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserActivationInclude<ExtArgs> | null
    /**
     * The data needed to update a UserActivation.
     */
    data: XOR<UserActivationUpdateInput, UserActivationUncheckedUpdateInput>
    /**
     * Choose, which UserActivation to update.
     */
    where: UserActivationWhereUniqueInput
  }

  /**
   * UserActivation updateMany
   */
  export type UserActivationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserActivations.
     */
    data: XOR<UserActivationUpdateManyMutationInput, UserActivationUncheckedUpdateManyInput>
    /**
     * Filter which UserActivations to update
     */
    where?: UserActivationWhereInput
  }

  /**
   * UserActivation upsert
   */
  export type UserActivationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivation
     */
    select?: UserActivationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserActivationInclude<ExtArgs> | null
    /**
     * The filter to search for the UserActivation to update in case it exists.
     */
    where: UserActivationWhereUniqueInput
    /**
     * In case the UserActivation found by the `where` argument doesn't exist, create a new UserActivation with this data.
     */
    create: XOR<UserActivationCreateInput, UserActivationUncheckedCreateInput>
    /**
     * In case the UserActivation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserActivationUpdateInput, UserActivationUncheckedUpdateInput>
  }

  /**
   * UserActivation delete
   */
  export type UserActivationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivation
     */
    select?: UserActivationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserActivationInclude<ExtArgs> | null
    /**
     * Filter which UserActivation to delete.
     */
    where: UserActivationWhereUniqueInput
  }

  /**
   * UserActivation deleteMany
   */
  export type UserActivationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserActivations to delete
     */
    where?: UserActivationWhereInput
  }

  /**
   * UserActivation without action
   */
  export type UserActivationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivation
     */
    select?: UserActivationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserActivationInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    userType: number | null
  }

  export type UserSumAggregateOutputType = {
    id: bigint | null
    userType: number | null
  }

  export type UserMinAggregateOutputType = {
    id: bigint | null
    name: string | null
    email: string | null
    phone: string | null
    qid: string | null
    userType: number | null
    isActive: boolean | null
  }

  export type UserMaxAggregateOutputType = {
    id: bigint | null
    name: string | null
    email: string | null
    phone: string | null
    qid: string | null
    userType: number | null
    isActive: boolean | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    phone: number
    qid: number
    userType: number
    isActive: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    userType?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    userType?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    qid?: true
    userType?: true
    isActive?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    qid?: true
    userType?: true
    isActive?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    qid?: true
    userType?: true
    isActive?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: bigint
    name: string
    email: string
    phone: string
    qid: string | null
    userType: number
    isActive: boolean
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    qid?: boolean
    userType?: boolean
    isActive?: boolean
    roles?: boolean | User$rolesArgs<ExtArgs>
    userActivations?: boolean | User$userActivationsArgs<ExtArgs>
    userAuths?: boolean | User$userAuthsArgs<ExtArgs>
    drivers?: boolean | User$driversArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    qid?: boolean
    userType?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    qid?: boolean
    userType?: boolean
    isActive?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | User$rolesArgs<ExtArgs>
    userActivations?: boolean | User$userActivationsArgs<ExtArgs>
    userAuths?: boolean | User$userAuthsArgs<ExtArgs>
    drivers?: boolean | User$driversArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      roles: Prisma.$UserRolePayload<ExtArgs>[]
      userActivations: Prisma.$UserActivationPayload<ExtArgs>[]
      userAuths: Prisma.$UserAuthPayload<ExtArgs>[]
      drivers: Prisma.$DriverPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      name: string
      email: string
      phone: string
      qid: string | null
      userType: number
      isActive: boolean
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    roles<T extends User$rolesArgs<ExtArgs> = {}>(args?: Subset<T, User$rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany"> | Null>
    userActivations<T extends User$userActivationsArgs<ExtArgs> = {}>(args?: Subset<T, User$userActivationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserActivationPayload<ExtArgs>, T, "findMany"> | Null>
    userAuths<T extends User$userAuthsArgs<ExtArgs> = {}>(args?: Subset<T, User$userAuthsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAuthPayload<ExtArgs>, T, "findMany"> | Null>
    drivers<T extends User$driversArgs<ExtArgs> = {}>(args?: Subset<T, User$driversArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'BigInt'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly qid: FieldRef<"User", 'String'>
    readonly userType: FieldRef<"User", 'Int'>
    readonly isActive: FieldRef<"User", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.roles
   */
  export type User$rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    cursor?: UserRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * User.userActivations
   */
  export type User$userActivationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivation
     */
    select?: UserActivationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserActivationInclude<ExtArgs> | null
    where?: UserActivationWhereInput
    orderBy?: UserActivationOrderByWithRelationInput | UserActivationOrderByWithRelationInput[]
    cursor?: UserActivationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserActivationScalarFieldEnum | UserActivationScalarFieldEnum[]
  }

  /**
   * User.userAuths
   */
  export type User$userAuthsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAuth
     */
    select?: UserAuthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAuthInclude<ExtArgs> | null
    where?: UserAuthWhereInput
    orderBy?: UserAuthOrderByWithRelationInput | UserAuthOrderByWithRelationInput[]
    cursor?: UserAuthWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserAuthScalarFieldEnum | UserAuthScalarFieldEnum[]
  }

  /**
   * User.drivers
   */
  export type User$driversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    where?: DriverWhereInput
    orderBy?: DriverOrderByWithRelationInput | DriverOrderByWithRelationInput[]
    cursor?: DriverWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DriverScalarFieldEnum | DriverScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleAvgAggregateOutputType = {
    id: number | null
  }

  export type RoleSumAggregateOutputType = {
    id: bigint | null
  }

  export type RoleMinAggregateOutputType = {
    id: bigint | null
    name: string | null
  }

  export type RoleMaxAggregateOutputType = {
    id: bigint | null
    name: string | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type RoleAvgAggregateInputType = {
    id?: true
  }

  export type RoleSumAggregateInputType = {
    id?: true
  }

  export type RoleMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _avg?: RoleAvgAggregateInputType
    _sum?: RoleSumAggregateInputType
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    id: bigint
    name: string
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    users?: boolean | Role$usersArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type RoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type RoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Role$usersArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Role"
    objects: {
      users: Prisma.$UserRolePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      name: string
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<Prisma.$RolePayload, S>

  type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RoleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role'], meta: { name: 'Role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleFindManyArgs>(args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends RoleCreateArgs>(args: SelectSubset<T, RoleCreateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleCreateManyArgs>(args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {RoleCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoleCreateManyAndReturnArgs>(args?: SelectSubset<T, RoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends RoleDeleteArgs>(args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleUpdateArgs>(args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleDeleteManyArgs>(args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleUpdateManyArgs>(args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Role model
   */
  readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Role$usersArgs<ExtArgs> = {}>(args?: Subset<T, Role$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Role model
   */ 
  interface RoleFieldRefs {
    readonly id: FieldRef<"Role", 'BigInt'>
    readonly name: FieldRef<"Role", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role createManyAndReturn
   */
  export type RoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
  }

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }

  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
  }

  /**
   * Role.users
   */
  export type Role$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    cursor?: UserRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * Role without action
   */
  export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
  }


  /**
   * Model UserRole
   */

  export type AggregateUserRole = {
    _count: UserRoleCountAggregateOutputType | null
    _avg: UserRoleAvgAggregateOutputType | null
    _sum: UserRoleSumAggregateOutputType | null
    _min: UserRoleMinAggregateOutputType | null
    _max: UserRoleMaxAggregateOutputType | null
  }

  export type UserRoleAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    roleId: number | null
  }

  export type UserRoleSumAggregateOutputType = {
    id: bigint | null
    userId: bigint | null
    roleId: bigint | null
  }

  export type UserRoleMinAggregateOutputType = {
    id: bigint | null
    userId: bigint | null
    roleId: bigint | null
  }

  export type UserRoleMaxAggregateOutputType = {
    id: bigint | null
    userId: bigint | null
    roleId: bigint | null
  }

  export type UserRoleCountAggregateOutputType = {
    id: number
    userId: number
    roleId: number
    _all: number
  }


  export type UserRoleAvgAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
  }

  export type UserRoleSumAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
  }

  export type UserRoleMinAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
  }

  export type UserRoleMaxAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
  }

  export type UserRoleCountAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
    _all?: true
  }

  export type UserRoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRole to aggregate.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserRoles
    **/
    _count?: true | UserRoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserRoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserRoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserRoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserRoleMaxAggregateInputType
  }

  export type GetUserRoleAggregateType<T extends UserRoleAggregateArgs> = {
        [P in keyof T & keyof AggregateUserRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserRole[P]>
      : GetScalarType<T[P], AggregateUserRole[P]>
  }




  export type UserRoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithAggregationInput | UserRoleOrderByWithAggregationInput[]
    by: UserRoleScalarFieldEnum[] | UserRoleScalarFieldEnum
    having?: UserRoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserRoleCountAggregateInputType | true
    _avg?: UserRoleAvgAggregateInputType
    _sum?: UserRoleSumAggregateInputType
    _min?: UserRoleMinAggregateInputType
    _max?: UserRoleMaxAggregateInputType
  }

  export type UserRoleGroupByOutputType = {
    id: bigint
    userId: bigint
    roleId: bigint
    _count: UserRoleCountAggregateOutputType | null
    _avg: UserRoleAvgAggregateOutputType | null
    _sum: UserRoleSumAggregateOutputType | null
    _min: UserRoleMinAggregateOutputType | null
    _max: UserRoleMaxAggregateOutputType | null
  }

  type GetUserRoleGroupByPayload<T extends UserRoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserRoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserRoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserRoleGroupByOutputType[P]>
            : GetScalarType<T[P], UserRoleGroupByOutputType[P]>
        }
      >
    >


  export type UserRoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    roleId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRole"]>

  export type UserRoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    roleId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRole"]>

  export type UserRoleSelectScalar = {
    id?: boolean
    userId?: boolean
    roleId?: boolean
  }

  export type UserRoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }
  export type UserRoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }

  export type $UserRolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserRole"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      role: Prisma.$RolePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      userId: bigint
      roleId: bigint
    }, ExtArgs["result"]["userRole"]>
    composites: {}
  }

  type UserRoleGetPayload<S extends boolean | null | undefined | UserRoleDefaultArgs> = $Result.GetResult<Prisma.$UserRolePayload, S>

  type UserRoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserRoleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserRoleCountAggregateInputType | true
    }

  export interface UserRoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserRole'], meta: { name: 'UserRole' } }
    /**
     * Find zero or one UserRole that matches the filter.
     * @param {UserRoleFindUniqueArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserRoleFindUniqueArgs>(args: SelectSubset<T, UserRoleFindUniqueArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserRole that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserRoleFindUniqueOrThrowArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserRoleFindUniqueOrThrowArgs>(args: SelectSubset<T, UserRoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserRole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindFirstArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserRoleFindFirstArgs>(args?: SelectSubset<T, UserRoleFindFirstArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserRole that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindFirstOrThrowArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserRoleFindFirstOrThrowArgs>(args?: SelectSubset<T, UserRoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserRoles
     * const userRoles = await prisma.userRole.findMany()
     * 
     * // Get first 10 UserRoles
     * const userRoles = await prisma.userRole.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userRoleWithIdOnly = await prisma.userRole.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserRoleFindManyArgs>(args?: SelectSubset<T, UserRoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserRole.
     * @param {UserRoleCreateArgs} args - Arguments to create a UserRole.
     * @example
     * // Create one UserRole
     * const UserRole = await prisma.userRole.create({
     *   data: {
     *     // ... data to create a UserRole
     *   }
     * })
     * 
     */
    create<T extends UserRoleCreateArgs>(args: SelectSubset<T, UserRoleCreateArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserRoles.
     * @param {UserRoleCreateManyArgs} args - Arguments to create many UserRoles.
     * @example
     * // Create many UserRoles
     * const userRole = await prisma.userRole.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserRoleCreateManyArgs>(args?: SelectSubset<T, UserRoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserRoles and returns the data saved in the database.
     * @param {UserRoleCreateManyAndReturnArgs} args - Arguments to create many UserRoles.
     * @example
     * // Create many UserRoles
     * const userRole = await prisma.userRole.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserRoles and only return the `id`
     * const userRoleWithIdOnly = await prisma.userRole.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserRoleCreateManyAndReturnArgs>(args?: SelectSubset<T, UserRoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserRole.
     * @param {UserRoleDeleteArgs} args - Arguments to delete one UserRole.
     * @example
     * // Delete one UserRole
     * const UserRole = await prisma.userRole.delete({
     *   where: {
     *     // ... filter to delete one UserRole
     *   }
     * })
     * 
     */
    delete<T extends UserRoleDeleteArgs>(args: SelectSubset<T, UserRoleDeleteArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserRole.
     * @param {UserRoleUpdateArgs} args - Arguments to update one UserRole.
     * @example
     * // Update one UserRole
     * const userRole = await prisma.userRole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserRoleUpdateArgs>(args: SelectSubset<T, UserRoleUpdateArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserRoles.
     * @param {UserRoleDeleteManyArgs} args - Arguments to filter UserRoles to delete.
     * @example
     * // Delete a few UserRoles
     * const { count } = await prisma.userRole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserRoleDeleteManyArgs>(args?: SelectSubset<T, UserRoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserRoles
     * const userRole = await prisma.userRole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserRoleUpdateManyArgs>(args: SelectSubset<T, UserRoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserRole.
     * @param {UserRoleUpsertArgs} args - Arguments to update or create a UserRole.
     * @example
     * // Update or create a UserRole
     * const userRole = await prisma.userRole.upsert({
     *   create: {
     *     // ... data to create a UserRole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserRole we want to update
     *   }
     * })
     */
    upsert<T extends UserRoleUpsertArgs>(args: SelectSubset<T, UserRoleUpsertArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleCountArgs} args - Arguments to filter UserRoles to count.
     * @example
     * // Count the number of UserRoles
     * const count = await prisma.userRole.count({
     *   where: {
     *     // ... the filter for the UserRoles we want to count
     *   }
     * })
    **/
    count<T extends UserRoleCountArgs>(
      args?: Subset<T, UserRoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserRoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserRoleAggregateArgs>(args: Subset<T, UserRoleAggregateArgs>): Prisma.PrismaPromise<GetUserRoleAggregateType<T>>

    /**
     * Group by UserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserRoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserRoleGroupByArgs['orderBy'] }
        : { orderBy?: UserRoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserRoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserRole model
   */
  readonly fields: UserRoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserRole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserRoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserRole model
   */ 
  interface UserRoleFieldRefs {
    readonly id: FieldRef<"UserRole", 'BigInt'>
    readonly userId: FieldRef<"UserRole", 'BigInt'>
    readonly roleId: FieldRef<"UserRole", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * UserRole findUnique
   */
  export type UserRoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole findUniqueOrThrow
   */
  export type UserRoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole findFirst
   */
  export type UserRoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoles.
     */
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole findFirstOrThrow
   */
  export type UserRoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoles.
     */
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole findMany
   */
  export type UserRoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRoles to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole create
   */
  export type UserRoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The data needed to create a UserRole.
     */
    data: XOR<UserRoleCreateInput, UserRoleUncheckedCreateInput>
  }

  /**
   * UserRole createMany
   */
  export type UserRoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserRoles.
     */
    data: UserRoleCreateManyInput | UserRoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserRole createManyAndReturn
   */
  export type UserRoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserRoles.
     */
    data: UserRoleCreateManyInput | UserRoleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserRole update
   */
  export type UserRoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The data needed to update a UserRole.
     */
    data: XOR<UserRoleUpdateInput, UserRoleUncheckedUpdateInput>
    /**
     * Choose, which UserRole to update.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole updateMany
   */
  export type UserRoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserRoles.
     */
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyInput>
    /**
     * Filter which UserRoles to update
     */
    where?: UserRoleWhereInput
  }

  /**
   * UserRole upsert
   */
  export type UserRoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The filter to search for the UserRole to update in case it exists.
     */
    where: UserRoleWhereUniqueInput
    /**
     * In case the UserRole found by the `where` argument doesn't exist, create a new UserRole with this data.
     */
    create: XOR<UserRoleCreateInput, UserRoleUncheckedCreateInput>
    /**
     * In case the UserRole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserRoleUpdateInput, UserRoleUncheckedUpdateInput>
  }

  /**
   * UserRole delete
   */
  export type UserRoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter which UserRole to delete.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole deleteMany
   */
  export type UserRoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRoles to delete
     */
    where?: UserRoleWhereInput
  }

  /**
   * UserRole without action
   */
  export type UserRoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
  }


  /**
   * Model Driver
   */

  export type AggregateDriver = {
    _count: DriverCountAggregateOutputType | null
    _avg: DriverAvgAggregateOutputType | null
    _sum: DriverSumAggregateOutputType | null
    _min: DriverMinAggregateOutputType | null
    _max: DriverMaxAggregateOutputType | null
  }

  export type DriverAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type DriverSumAggregateOutputType = {
    id: bigint | null
    userId: bigint | null
  }

  export type DriverMinAggregateOutputType = {
    id: bigint | null
    userId: bigint | null
    licenseExpiry: Date | null
  }

  export type DriverMaxAggregateOutputType = {
    id: bigint | null
    userId: bigint | null
    licenseExpiry: Date | null
  }

  export type DriverCountAggregateOutputType = {
    id: number
    userId: number
    licenseExpiry: number
    _all: number
  }


  export type DriverAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type DriverSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type DriverMinAggregateInputType = {
    id?: true
    userId?: true
    licenseExpiry?: true
  }

  export type DriverMaxAggregateInputType = {
    id?: true
    userId?: true
    licenseExpiry?: true
  }

  export type DriverCountAggregateInputType = {
    id?: true
    userId?: true
    licenseExpiry?: true
    _all?: true
  }

  export type DriverAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Driver to aggregate.
     */
    where?: DriverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Drivers to fetch.
     */
    orderBy?: DriverOrderByWithRelationInput | DriverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DriverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Drivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Drivers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Drivers
    **/
    _count?: true | DriverCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DriverAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DriverSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DriverMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DriverMaxAggregateInputType
  }

  export type GetDriverAggregateType<T extends DriverAggregateArgs> = {
        [P in keyof T & keyof AggregateDriver]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDriver[P]>
      : GetScalarType<T[P], AggregateDriver[P]>
  }




  export type DriverGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DriverWhereInput
    orderBy?: DriverOrderByWithAggregationInput | DriverOrderByWithAggregationInput[]
    by: DriverScalarFieldEnum[] | DriverScalarFieldEnum
    having?: DriverScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DriverCountAggregateInputType | true
    _avg?: DriverAvgAggregateInputType
    _sum?: DriverSumAggregateInputType
    _min?: DriverMinAggregateInputType
    _max?: DriverMaxAggregateInputType
  }

  export type DriverGroupByOutputType = {
    id: bigint
    userId: bigint
    licenseExpiry: Date | null
    _count: DriverCountAggregateOutputType | null
    _avg: DriverAvgAggregateOutputType | null
    _sum: DriverSumAggregateOutputType | null
    _min: DriverMinAggregateOutputType | null
    _max: DriverMaxAggregateOutputType | null
  }

  type GetDriverGroupByPayload<T extends DriverGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DriverGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DriverGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DriverGroupByOutputType[P]>
            : GetScalarType<T[P], DriverGroupByOutputType[P]>
        }
      >
    >


  export type DriverSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    licenseExpiry?: boolean
    trips?: boolean | Driver$tripsArgs<ExtArgs>
    shifts?: boolean | Driver$shiftsArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    Duty?: boolean | Driver$DutyArgs<ExtArgs>
    _count?: boolean | DriverCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["driver"]>

  export type DriverSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    licenseExpiry?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["driver"]>

  export type DriverSelectScalar = {
    id?: boolean
    userId?: boolean
    licenseExpiry?: boolean
  }

  export type DriverInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trips?: boolean | Driver$tripsArgs<ExtArgs>
    shifts?: boolean | Driver$shiftsArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    Duty?: boolean | Driver$DutyArgs<ExtArgs>
    _count?: boolean | DriverCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DriverIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DriverPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Driver"
    objects: {
      trips: Prisma.$TripPayload<ExtArgs>[]
      shifts: Prisma.$ShiftPayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs>
      Duty: Prisma.$DutyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      userId: bigint
      licenseExpiry: Date | null
    }, ExtArgs["result"]["driver"]>
    composites: {}
  }

  type DriverGetPayload<S extends boolean | null | undefined | DriverDefaultArgs> = $Result.GetResult<Prisma.$DriverPayload, S>

  type DriverCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DriverFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DriverCountAggregateInputType | true
    }

  export interface DriverDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Driver'], meta: { name: 'Driver' } }
    /**
     * Find zero or one Driver that matches the filter.
     * @param {DriverFindUniqueArgs} args - Arguments to find a Driver
     * @example
     * // Get one Driver
     * const driver = await prisma.driver.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DriverFindUniqueArgs>(args: SelectSubset<T, DriverFindUniqueArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Driver that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DriverFindUniqueOrThrowArgs} args - Arguments to find a Driver
     * @example
     * // Get one Driver
     * const driver = await prisma.driver.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DriverFindUniqueOrThrowArgs>(args: SelectSubset<T, DriverFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Driver that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverFindFirstArgs} args - Arguments to find a Driver
     * @example
     * // Get one Driver
     * const driver = await prisma.driver.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DriverFindFirstArgs>(args?: SelectSubset<T, DriverFindFirstArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Driver that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverFindFirstOrThrowArgs} args - Arguments to find a Driver
     * @example
     * // Get one Driver
     * const driver = await prisma.driver.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DriverFindFirstOrThrowArgs>(args?: SelectSubset<T, DriverFindFirstOrThrowArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Drivers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Drivers
     * const drivers = await prisma.driver.findMany()
     * 
     * // Get first 10 Drivers
     * const drivers = await prisma.driver.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const driverWithIdOnly = await prisma.driver.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DriverFindManyArgs>(args?: SelectSubset<T, DriverFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Driver.
     * @param {DriverCreateArgs} args - Arguments to create a Driver.
     * @example
     * // Create one Driver
     * const Driver = await prisma.driver.create({
     *   data: {
     *     // ... data to create a Driver
     *   }
     * })
     * 
     */
    create<T extends DriverCreateArgs>(args: SelectSubset<T, DriverCreateArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Drivers.
     * @param {DriverCreateManyArgs} args - Arguments to create many Drivers.
     * @example
     * // Create many Drivers
     * const driver = await prisma.driver.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DriverCreateManyArgs>(args?: SelectSubset<T, DriverCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Drivers and returns the data saved in the database.
     * @param {DriverCreateManyAndReturnArgs} args - Arguments to create many Drivers.
     * @example
     * // Create many Drivers
     * const driver = await prisma.driver.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Drivers and only return the `id`
     * const driverWithIdOnly = await prisma.driver.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DriverCreateManyAndReturnArgs>(args?: SelectSubset<T, DriverCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Driver.
     * @param {DriverDeleteArgs} args - Arguments to delete one Driver.
     * @example
     * // Delete one Driver
     * const Driver = await prisma.driver.delete({
     *   where: {
     *     // ... filter to delete one Driver
     *   }
     * })
     * 
     */
    delete<T extends DriverDeleteArgs>(args: SelectSubset<T, DriverDeleteArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Driver.
     * @param {DriverUpdateArgs} args - Arguments to update one Driver.
     * @example
     * // Update one Driver
     * const driver = await prisma.driver.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DriverUpdateArgs>(args: SelectSubset<T, DriverUpdateArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Drivers.
     * @param {DriverDeleteManyArgs} args - Arguments to filter Drivers to delete.
     * @example
     * // Delete a few Drivers
     * const { count } = await prisma.driver.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DriverDeleteManyArgs>(args?: SelectSubset<T, DriverDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Drivers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Drivers
     * const driver = await prisma.driver.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DriverUpdateManyArgs>(args: SelectSubset<T, DriverUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Driver.
     * @param {DriverUpsertArgs} args - Arguments to update or create a Driver.
     * @example
     * // Update or create a Driver
     * const driver = await prisma.driver.upsert({
     *   create: {
     *     // ... data to create a Driver
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Driver we want to update
     *   }
     * })
     */
    upsert<T extends DriverUpsertArgs>(args: SelectSubset<T, DriverUpsertArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Drivers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverCountArgs} args - Arguments to filter Drivers to count.
     * @example
     * // Count the number of Drivers
     * const count = await prisma.driver.count({
     *   where: {
     *     // ... the filter for the Drivers we want to count
     *   }
     * })
    **/
    count<T extends DriverCountArgs>(
      args?: Subset<T, DriverCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DriverCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Driver.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DriverAggregateArgs>(args: Subset<T, DriverAggregateArgs>): Prisma.PrismaPromise<GetDriverAggregateType<T>>

    /**
     * Group by Driver.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DriverGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DriverGroupByArgs['orderBy'] }
        : { orderBy?: DriverGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DriverGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDriverGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Driver model
   */
  readonly fields: DriverFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Driver.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DriverClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    trips<T extends Driver$tripsArgs<ExtArgs> = {}>(args?: Subset<T, Driver$tripsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "findMany"> | Null>
    shifts<T extends Driver$shiftsArgs<ExtArgs> = {}>(args?: Subset<T, Driver$shiftsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findMany"> | Null>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Duty<T extends Driver$DutyArgs<ExtArgs> = {}>(args?: Subset<T, Driver$DutyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DutyPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Driver model
   */ 
  interface DriverFieldRefs {
    readonly id: FieldRef<"Driver", 'BigInt'>
    readonly userId: FieldRef<"Driver", 'BigInt'>
    readonly licenseExpiry: FieldRef<"Driver", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Driver findUnique
   */
  export type DriverFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    /**
     * Filter, which Driver to fetch.
     */
    where: DriverWhereUniqueInput
  }

  /**
   * Driver findUniqueOrThrow
   */
  export type DriverFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    /**
     * Filter, which Driver to fetch.
     */
    where: DriverWhereUniqueInput
  }

  /**
   * Driver findFirst
   */
  export type DriverFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    /**
     * Filter, which Driver to fetch.
     */
    where?: DriverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Drivers to fetch.
     */
    orderBy?: DriverOrderByWithRelationInput | DriverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Drivers.
     */
    cursor?: DriverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Drivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Drivers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Drivers.
     */
    distinct?: DriverScalarFieldEnum | DriverScalarFieldEnum[]
  }

  /**
   * Driver findFirstOrThrow
   */
  export type DriverFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    /**
     * Filter, which Driver to fetch.
     */
    where?: DriverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Drivers to fetch.
     */
    orderBy?: DriverOrderByWithRelationInput | DriverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Drivers.
     */
    cursor?: DriverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Drivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Drivers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Drivers.
     */
    distinct?: DriverScalarFieldEnum | DriverScalarFieldEnum[]
  }

  /**
   * Driver findMany
   */
  export type DriverFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    /**
     * Filter, which Drivers to fetch.
     */
    where?: DriverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Drivers to fetch.
     */
    orderBy?: DriverOrderByWithRelationInput | DriverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Drivers.
     */
    cursor?: DriverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Drivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Drivers.
     */
    skip?: number
    distinct?: DriverScalarFieldEnum | DriverScalarFieldEnum[]
  }

  /**
   * Driver create
   */
  export type DriverCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    /**
     * The data needed to create a Driver.
     */
    data: XOR<DriverCreateInput, DriverUncheckedCreateInput>
  }

  /**
   * Driver createMany
   */
  export type DriverCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Drivers.
     */
    data: DriverCreateManyInput | DriverCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Driver createManyAndReturn
   */
  export type DriverCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Drivers.
     */
    data: DriverCreateManyInput | DriverCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Driver update
   */
  export type DriverUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    /**
     * The data needed to update a Driver.
     */
    data: XOR<DriverUpdateInput, DriverUncheckedUpdateInput>
    /**
     * Choose, which Driver to update.
     */
    where: DriverWhereUniqueInput
  }

  /**
   * Driver updateMany
   */
  export type DriverUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Drivers.
     */
    data: XOR<DriverUpdateManyMutationInput, DriverUncheckedUpdateManyInput>
    /**
     * Filter which Drivers to update
     */
    where?: DriverWhereInput
  }

  /**
   * Driver upsert
   */
  export type DriverUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    /**
     * The filter to search for the Driver to update in case it exists.
     */
    where: DriverWhereUniqueInput
    /**
     * In case the Driver found by the `where` argument doesn't exist, create a new Driver with this data.
     */
    create: XOR<DriverCreateInput, DriverUncheckedCreateInput>
    /**
     * In case the Driver was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DriverUpdateInput, DriverUncheckedUpdateInput>
  }

  /**
   * Driver delete
   */
  export type DriverDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    /**
     * Filter which Driver to delete.
     */
    where: DriverWhereUniqueInput
  }

  /**
   * Driver deleteMany
   */
  export type DriverDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Drivers to delete
     */
    where?: DriverWhereInput
  }

  /**
   * Driver.trips
   */
  export type Driver$tripsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    where?: TripWhereInput
    orderBy?: TripOrderByWithRelationInput | TripOrderByWithRelationInput[]
    cursor?: TripWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TripScalarFieldEnum | TripScalarFieldEnum[]
  }

  /**
   * Driver.shifts
   */
  export type Driver$shiftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    where?: ShiftWhereInput
    orderBy?: ShiftOrderByWithRelationInput | ShiftOrderByWithRelationInput[]
    cursor?: ShiftWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShiftScalarFieldEnum | ShiftScalarFieldEnum[]
  }

  /**
   * Driver.Duty
   */
  export type Driver$DutyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Duty
     */
    select?: DutySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DutyInclude<ExtArgs> | null
    where?: DutyWhereInput
    orderBy?: DutyOrderByWithRelationInput | DutyOrderByWithRelationInput[]
    cursor?: DutyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DutyScalarFieldEnum | DutyScalarFieldEnum[]
  }

  /**
   * Driver without action
   */
  export type DriverDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
  }


  /**
   * Model VehicleModel
   */

  export type AggregateVehicleModel = {
    _count: VehicleModelCountAggregateOutputType | null
    _avg: VehicleModelAvgAggregateOutputType | null
    _sum: VehicleModelSumAggregateOutputType | null
    _min: VehicleModelMinAggregateOutputType | null
    _max: VehicleModelMaxAggregateOutputType | null
  }

  export type VehicleModelAvgAggregateOutputType = {
    id: number | null
    year: number | null
    capacity: number | null
  }

  export type VehicleModelSumAggregateOutputType = {
    id: bigint | null
    year: number | null
    capacity: number | null
  }

  export type VehicleModelMinAggregateOutputType = {
    id: bigint | null
    make: string | null
    year: number | null
    manufacturer: string | null
    capacity: number | null
  }

  export type VehicleModelMaxAggregateOutputType = {
    id: bigint | null
    make: string | null
    year: number | null
    manufacturer: string | null
    capacity: number | null
  }

  export type VehicleModelCountAggregateOutputType = {
    id: number
    make: number
    year: number
    manufacturer: number
    capacity: number
    _all: number
  }


  export type VehicleModelAvgAggregateInputType = {
    id?: true
    year?: true
    capacity?: true
  }

  export type VehicleModelSumAggregateInputType = {
    id?: true
    year?: true
    capacity?: true
  }

  export type VehicleModelMinAggregateInputType = {
    id?: true
    make?: true
    year?: true
    manufacturer?: true
    capacity?: true
  }

  export type VehicleModelMaxAggregateInputType = {
    id?: true
    make?: true
    year?: true
    manufacturer?: true
    capacity?: true
  }

  export type VehicleModelCountAggregateInputType = {
    id?: true
    make?: true
    year?: true
    manufacturer?: true
    capacity?: true
    _all?: true
  }

  export type VehicleModelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VehicleModel to aggregate.
     */
    where?: VehicleModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleModels to fetch.
     */
    orderBy?: VehicleModelOrderByWithRelationInput | VehicleModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VehicleModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VehicleModels
    **/
    _count?: true | VehicleModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VehicleModelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VehicleModelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VehicleModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VehicleModelMaxAggregateInputType
  }

  export type GetVehicleModelAggregateType<T extends VehicleModelAggregateArgs> = {
        [P in keyof T & keyof AggregateVehicleModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVehicleModel[P]>
      : GetScalarType<T[P], AggregateVehicleModel[P]>
  }




  export type VehicleModelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VehicleModelWhereInput
    orderBy?: VehicleModelOrderByWithAggregationInput | VehicleModelOrderByWithAggregationInput[]
    by: VehicleModelScalarFieldEnum[] | VehicleModelScalarFieldEnum
    having?: VehicleModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VehicleModelCountAggregateInputType | true
    _avg?: VehicleModelAvgAggregateInputType
    _sum?: VehicleModelSumAggregateInputType
    _min?: VehicleModelMinAggregateInputType
    _max?: VehicleModelMaxAggregateInputType
  }

  export type VehicleModelGroupByOutputType = {
    id: bigint
    make: string
    year: number
    manufacturer: string
    capacity: number
    _count: VehicleModelCountAggregateOutputType | null
    _avg: VehicleModelAvgAggregateOutputType | null
    _sum: VehicleModelSumAggregateOutputType | null
    _min: VehicleModelMinAggregateOutputType | null
    _max: VehicleModelMaxAggregateOutputType | null
  }

  type GetVehicleModelGroupByPayload<T extends VehicleModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VehicleModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VehicleModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VehicleModelGroupByOutputType[P]>
            : GetScalarType<T[P], VehicleModelGroupByOutputType[P]>
        }
      >
    >


  export type VehicleModelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    make?: boolean
    year?: boolean
    manufacturer?: boolean
    capacity?: boolean
    vehicles?: boolean | VehicleModel$vehiclesArgs<ExtArgs>
    _count?: boolean | VehicleModelCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicleModel"]>

  export type VehicleModelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    make?: boolean
    year?: boolean
    manufacturer?: boolean
    capacity?: boolean
  }, ExtArgs["result"]["vehicleModel"]>

  export type VehicleModelSelectScalar = {
    id?: boolean
    make?: boolean
    year?: boolean
    manufacturer?: boolean
    capacity?: boolean
  }

  export type VehicleModelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vehicles?: boolean | VehicleModel$vehiclesArgs<ExtArgs>
    _count?: boolean | VehicleModelCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VehicleModelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $VehicleModelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VehicleModel"
    objects: {
      vehicles: Prisma.$VehiclePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      make: string
      year: number
      manufacturer: string
      capacity: number
    }, ExtArgs["result"]["vehicleModel"]>
    composites: {}
  }

  type VehicleModelGetPayload<S extends boolean | null | undefined | VehicleModelDefaultArgs> = $Result.GetResult<Prisma.$VehicleModelPayload, S>

  type VehicleModelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VehicleModelFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VehicleModelCountAggregateInputType | true
    }

  export interface VehicleModelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VehicleModel'], meta: { name: 'VehicleModel' } }
    /**
     * Find zero or one VehicleModel that matches the filter.
     * @param {VehicleModelFindUniqueArgs} args - Arguments to find a VehicleModel
     * @example
     * // Get one VehicleModel
     * const vehicleModel = await prisma.vehicleModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VehicleModelFindUniqueArgs>(args: SelectSubset<T, VehicleModelFindUniqueArgs<ExtArgs>>): Prisma__VehicleModelClient<$Result.GetResult<Prisma.$VehicleModelPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one VehicleModel that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VehicleModelFindUniqueOrThrowArgs} args - Arguments to find a VehicleModel
     * @example
     * // Get one VehicleModel
     * const vehicleModel = await prisma.vehicleModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VehicleModelFindUniqueOrThrowArgs>(args: SelectSubset<T, VehicleModelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VehicleModelClient<$Result.GetResult<Prisma.$VehicleModelPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first VehicleModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleModelFindFirstArgs} args - Arguments to find a VehicleModel
     * @example
     * // Get one VehicleModel
     * const vehicleModel = await prisma.vehicleModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VehicleModelFindFirstArgs>(args?: SelectSubset<T, VehicleModelFindFirstArgs<ExtArgs>>): Prisma__VehicleModelClient<$Result.GetResult<Prisma.$VehicleModelPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first VehicleModel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleModelFindFirstOrThrowArgs} args - Arguments to find a VehicleModel
     * @example
     * // Get one VehicleModel
     * const vehicleModel = await prisma.vehicleModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VehicleModelFindFirstOrThrowArgs>(args?: SelectSubset<T, VehicleModelFindFirstOrThrowArgs<ExtArgs>>): Prisma__VehicleModelClient<$Result.GetResult<Prisma.$VehicleModelPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more VehicleModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleModelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VehicleModels
     * const vehicleModels = await prisma.vehicleModel.findMany()
     * 
     * // Get first 10 VehicleModels
     * const vehicleModels = await prisma.vehicleModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vehicleModelWithIdOnly = await prisma.vehicleModel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VehicleModelFindManyArgs>(args?: SelectSubset<T, VehicleModelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehicleModelPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a VehicleModel.
     * @param {VehicleModelCreateArgs} args - Arguments to create a VehicleModel.
     * @example
     * // Create one VehicleModel
     * const VehicleModel = await prisma.vehicleModel.create({
     *   data: {
     *     // ... data to create a VehicleModel
     *   }
     * })
     * 
     */
    create<T extends VehicleModelCreateArgs>(args: SelectSubset<T, VehicleModelCreateArgs<ExtArgs>>): Prisma__VehicleModelClient<$Result.GetResult<Prisma.$VehicleModelPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many VehicleModels.
     * @param {VehicleModelCreateManyArgs} args - Arguments to create many VehicleModels.
     * @example
     * // Create many VehicleModels
     * const vehicleModel = await prisma.vehicleModel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VehicleModelCreateManyArgs>(args?: SelectSubset<T, VehicleModelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VehicleModels and returns the data saved in the database.
     * @param {VehicleModelCreateManyAndReturnArgs} args - Arguments to create many VehicleModels.
     * @example
     * // Create many VehicleModels
     * const vehicleModel = await prisma.vehicleModel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VehicleModels and only return the `id`
     * const vehicleModelWithIdOnly = await prisma.vehicleModel.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VehicleModelCreateManyAndReturnArgs>(args?: SelectSubset<T, VehicleModelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehicleModelPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a VehicleModel.
     * @param {VehicleModelDeleteArgs} args - Arguments to delete one VehicleModel.
     * @example
     * // Delete one VehicleModel
     * const VehicleModel = await prisma.vehicleModel.delete({
     *   where: {
     *     // ... filter to delete one VehicleModel
     *   }
     * })
     * 
     */
    delete<T extends VehicleModelDeleteArgs>(args: SelectSubset<T, VehicleModelDeleteArgs<ExtArgs>>): Prisma__VehicleModelClient<$Result.GetResult<Prisma.$VehicleModelPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one VehicleModel.
     * @param {VehicleModelUpdateArgs} args - Arguments to update one VehicleModel.
     * @example
     * // Update one VehicleModel
     * const vehicleModel = await prisma.vehicleModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VehicleModelUpdateArgs>(args: SelectSubset<T, VehicleModelUpdateArgs<ExtArgs>>): Prisma__VehicleModelClient<$Result.GetResult<Prisma.$VehicleModelPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more VehicleModels.
     * @param {VehicleModelDeleteManyArgs} args - Arguments to filter VehicleModels to delete.
     * @example
     * // Delete a few VehicleModels
     * const { count } = await prisma.vehicleModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VehicleModelDeleteManyArgs>(args?: SelectSubset<T, VehicleModelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VehicleModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VehicleModels
     * const vehicleModel = await prisma.vehicleModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VehicleModelUpdateManyArgs>(args: SelectSubset<T, VehicleModelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VehicleModel.
     * @param {VehicleModelUpsertArgs} args - Arguments to update or create a VehicleModel.
     * @example
     * // Update or create a VehicleModel
     * const vehicleModel = await prisma.vehicleModel.upsert({
     *   create: {
     *     // ... data to create a VehicleModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VehicleModel we want to update
     *   }
     * })
     */
    upsert<T extends VehicleModelUpsertArgs>(args: SelectSubset<T, VehicleModelUpsertArgs<ExtArgs>>): Prisma__VehicleModelClient<$Result.GetResult<Prisma.$VehicleModelPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of VehicleModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleModelCountArgs} args - Arguments to filter VehicleModels to count.
     * @example
     * // Count the number of VehicleModels
     * const count = await prisma.vehicleModel.count({
     *   where: {
     *     // ... the filter for the VehicleModels we want to count
     *   }
     * })
    **/
    count<T extends VehicleModelCountArgs>(
      args?: Subset<T, VehicleModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VehicleModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VehicleModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VehicleModelAggregateArgs>(args: Subset<T, VehicleModelAggregateArgs>): Prisma.PrismaPromise<GetVehicleModelAggregateType<T>>

    /**
     * Group by VehicleModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VehicleModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VehicleModelGroupByArgs['orderBy'] }
        : { orderBy?: VehicleModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VehicleModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVehicleModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VehicleModel model
   */
  readonly fields: VehicleModelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VehicleModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VehicleModelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vehicles<T extends VehicleModel$vehiclesArgs<ExtArgs> = {}>(args?: Subset<T, VehicleModel$vehiclesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VehicleModel model
   */ 
  interface VehicleModelFieldRefs {
    readonly id: FieldRef<"VehicleModel", 'BigInt'>
    readonly make: FieldRef<"VehicleModel", 'String'>
    readonly year: FieldRef<"VehicleModel", 'Int'>
    readonly manufacturer: FieldRef<"VehicleModel", 'String'>
    readonly capacity: FieldRef<"VehicleModel", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * VehicleModel findUnique
   */
  export type VehicleModelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleModel
     */
    select?: VehicleModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleModelInclude<ExtArgs> | null
    /**
     * Filter, which VehicleModel to fetch.
     */
    where: VehicleModelWhereUniqueInput
  }

  /**
   * VehicleModel findUniqueOrThrow
   */
  export type VehicleModelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleModel
     */
    select?: VehicleModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleModelInclude<ExtArgs> | null
    /**
     * Filter, which VehicleModel to fetch.
     */
    where: VehicleModelWhereUniqueInput
  }

  /**
   * VehicleModel findFirst
   */
  export type VehicleModelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleModel
     */
    select?: VehicleModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleModelInclude<ExtArgs> | null
    /**
     * Filter, which VehicleModel to fetch.
     */
    where?: VehicleModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleModels to fetch.
     */
    orderBy?: VehicleModelOrderByWithRelationInput | VehicleModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VehicleModels.
     */
    cursor?: VehicleModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VehicleModels.
     */
    distinct?: VehicleModelScalarFieldEnum | VehicleModelScalarFieldEnum[]
  }

  /**
   * VehicleModel findFirstOrThrow
   */
  export type VehicleModelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleModel
     */
    select?: VehicleModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleModelInclude<ExtArgs> | null
    /**
     * Filter, which VehicleModel to fetch.
     */
    where?: VehicleModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleModels to fetch.
     */
    orderBy?: VehicleModelOrderByWithRelationInput | VehicleModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VehicleModels.
     */
    cursor?: VehicleModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VehicleModels.
     */
    distinct?: VehicleModelScalarFieldEnum | VehicleModelScalarFieldEnum[]
  }

  /**
   * VehicleModel findMany
   */
  export type VehicleModelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleModel
     */
    select?: VehicleModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleModelInclude<ExtArgs> | null
    /**
     * Filter, which VehicleModels to fetch.
     */
    where?: VehicleModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleModels to fetch.
     */
    orderBy?: VehicleModelOrderByWithRelationInput | VehicleModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VehicleModels.
     */
    cursor?: VehicleModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleModels.
     */
    skip?: number
    distinct?: VehicleModelScalarFieldEnum | VehicleModelScalarFieldEnum[]
  }

  /**
   * VehicleModel create
   */
  export type VehicleModelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleModel
     */
    select?: VehicleModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleModelInclude<ExtArgs> | null
    /**
     * The data needed to create a VehicleModel.
     */
    data: XOR<VehicleModelCreateInput, VehicleModelUncheckedCreateInput>
  }

  /**
   * VehicleModel createMany
   */
  export type VehicleModelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VehicleModels.
     */
    data: VehicleModelCreateManyInput | VehicleModelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VehicleModel createManyAndReturn
   */
  export type VehicleModelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleModel
     */
    select?: VehicleModelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many VehicleModels.
     */
    data: VehicleModelCreateManyInput | VehicleModelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VehicleModel update
   */
  export type VehicleModelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleModel
     */
    select?: VehicleModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleModelInclude<ExtArgs> | null
    /**
     * The data needed to update a VehicleModel.
     */
    data: XOR<VehicleModelUpdateInput, VehicleModelUncheckedUpdateInput>
    /**
     * Choose, which VehicleModel to update.
     */
    where: VehicleModelWhereUniqueInput
  }

  /**
   * VehicleModel updateMany
   */
  export type VehicleModelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VehicleModels.
     */
    data: XOR<VehicleModelUpdateManyMutationInput, VehicleModelUncheckedUpdateManyInput>
    /**
     * Filter which VehicleModels to update
     */
    where?: VehicleModelWhereInput
  }

  /**
   * VehicleModel upsert
   */
  export type VehicleModelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleModel
     */
    select?: VehicleModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleModelInclude<ExtArgs> | null
    /**
     * The filter to search for the VehicleModel to update in case it exists.
     */
    where: VehicleModelWhereUniqueInput
    /**
     * In case the VehicleModel found by the `where` argument doesn't exist, create a new VehicleModel with this data.
     */
    create: XOR<VehicleModelCreateInput, VehicleModelUncheckedCreateInput>
    /**
     * In case the VehicleModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VehicleModelUpdateInput, VehicleModelUncheckedUpdateInput>
  }

  /**
   * VehicleModel delete
   */
  export type VehicleModelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleModel
     */
    select?: VehicleModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleModelInclude<ExtArgs> | null
    /**
     * Filter which VehicleModel to delete.
     */
    where: VehicleModelWhereUniqueInput
  }

  /**
   * VehicleModel deleteMany
   */
  export type VehicleModelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VehicleModels to delete
     */
    where?: VehicleModelWhereInput
  }

  /**
   * VehicleModel.vehicles
   */
  export type VehicleModel$vehiclesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    where?: VehicleWhereInput
    orderBy?: VehicleOrderByWithRelationInput | VehicleOrderByWithRelationInput[]
    cursor?: VehicleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VehicleScalarFieldEnum | VehicleScalarFieldEnum[]
  }

  /**
   * VehicleModel without action
   */
  export type VehicleModelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleModel
     */
    select?: VehicleModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleModelInclude<ExtArgs> | null
  }


  /**
   * Model Vehicle
   */

  export type AggregateVehicle = {
    _count: VehicleCountAggregateOutputType | null
    _avg: VehicleAvgAggregateOutputType | null
    _sum: VehicleSumAggregateOutputType | null
    _min: VehicleMinAggregateOutputType | null
    _max: VehicleMaxAggregateOutputType | null
  }

  export type VehicleAvgAggregateOutputType = {
    id: number | null
    modelId: number | null
  }

  export type VehicleSumAggregateOutputType = {
    id: bigint | null
    modelId: bigint | null
  }

  export type VehicleMinAggregateOutputType = {
    id: bigint | null
    plateNo: string | null
    fleetNo: string | null
    modelId: bigint | null
  }

  export type VehicleMaxAggregateOutputType = {
    id: bigint | null
    plateNo: string | null
    fleetNo: string | null
    modelId: bigint | null
  }

  export type VehicleCountAggregateOutputType = {
    id: number
    plateNo: number
    fleetNo: number
    modelId: number
    _all: number
  }


  export type VehicleAvgAggregateInputType = {
    id?: true
    modelId?: true
  }

  export type VehicleSumAggregateInputType = {
    id?: true
    modelId?: true
  }

  export type VehicleMinAggregateInputType = {
    id?: true
    plateNo?: true
    fleetNo?: true
    modelId?: true
  }

  export type VehicleMaxAggregateInputType = {
    id?: true
    plateNo?: true
    fleetNo?: true
    modelId?: true
  }

  export type VehicleCountAggregateInputType = {
    id?: true
    plateNo?: true
    fleetNo?: true
    modelId?: true
    _all?: true
  }

  export type VehicleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vehicle to aggregate.
     */
    where?: VehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vehicles to fetch.
     */
    orderBy?: VehicleOrderByWithRelationInput | VehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vehicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Vehicles
    **/
    _count?: true | VehicleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VehicleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VehicleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VehicleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VehicleMaxAggregateInputType
  }

  export type GetVehicleAggregateType<T extends VehicleAggregateArgs> = {
        [P in keyof T & keyof AggregateVehicle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVehicle[P]>
      : GetScalarType<T[P], AggregateVehicle[P]>
  }




  export type VehicleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VehicleWhereInput
    orderBy?: VehicleOrderByWithAggregationInput | VehicleOrderByWithAggregationInput[]
    by: VehicleScalarFieldEnum[] | VehicleScalarFieldEnum
    having?: VehicleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VehicleCountAggregateInputType | true
    _avg?: VehicleAvgAggregateInputType
    _sum?: VehicleSumAggregateInputType
    _min?: VehicleMinAggregateInputType
    _max?: VehicleMaxAggregateInputType
  }

  export type VehicleGroupByOutputType = {
    id: bigint
    plateNo: string
    fleetNo: string
    modelId: bigint
    _count: VehicleCountAggregateOutputType | null
    _avg: VehicleAvgAggregateOutputType | null
    _sum: VehicleSumAggregateOutputType | null
    _min: VehicleMinAggregateOutputType | null
    _max: VehicleMaxAggregateOutputType | null
  }

  type GetVehicleGroupByPayload<T extends VehicleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VehicleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VehicleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VehicleGroupByOutputType[P]>
            : GetScalarType<T[P], VehicleGroupByOutputType[P]>
        }
      >
    >


  export type VehicleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    plateNo?: boolean
    fleetNo?: boolean
    modelId?: boolean
    model?: boolean | VehicleModelDefaultArgs<ExtArgs>
    trips?: boolean | Vehicle$tripsArgs<ExtArgs>
    shifts?: boolean | Vehicle$shiftsArgs<ExtArgs>
    telemetry?: boolean | Vehicle$telemetryArgs<ExtArgs>
    telemetryHistory?: boolean | Vehicle$telemetryHistoryArgs<ExtArgs>
    Duty?: boolean | Vehicle$DutyArgs<ExtArgs>
    _count?: boolean | VehicleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicle"]>

  export type VehicleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    plateNo?: boolean
    fleetNo?: boolean
    modelId?: boolean
    model?: boolean | VehicleModelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicle"]>

  export type VehicleSelectScalar = {
    id?: boolean
    plateNo?: boolean
    fleetNo?: boolean
    modelId?: boolean
  }

  export type VehicleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    model?: boolean | VehicleModelDefaultArgs<ExtArgs>
    trips?: boolean | Vehicle$tripsArgs<ExtArgs>
    shifts?: boolean | Vehicle$shiftsArgs<ExtArgs>
    telemetry?: boolean | Vehicle$telemetryArgs<ExtArgs>
    telemetryHistory?: boolean | Vehicle$telemetryHistoryArgs<ExtArgs>
    Duty?: boolean | Vehicle$DutyArgs<ExtArgs>
    _count?: boolean | VehicleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VehicleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    model?: boolean | VehicleModelDefaultArgs<ExtArgs>
  }

  export type $VehiclePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Vehicle"
    objects: {
      model: Prisma.$VehicleModelPayload<ExtArgs>
      trips: Prisma.$TripPayload<ExtArgs>[]
      shifts: Prisma.$ShiftPayload<ExtArgs>[]
      telemetry: Prisma.$VehicleTelemetryPayload<ExtArgs>[]
      telemetryHistory: Prisma.$VehicleTelemetryHistoryPayload<ExtArgs>[]
      Duty: Prisma.$DutyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      plateNo: string
      fleetNo: string
      modelId: bigint
    }, ExtArgs["result"]["vehicle"]>
    composites: {}
  }

  type VehicleGetPayload<S extends boolean | null | undefined | VehicleDefaultArgs> = $Result.GetResult<Prisma.$VehiclePayload, S>

  type VehicleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VehicleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VehicleCountAggregateInputType | true
    }

  export interface VehicleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Vehicle'], meta: { name: 'Vehicle' } }
    /**
     * Find zero or one Vehicle that matches the filter.
     * @param {VehicleFindUniqueArgs} args - Arguments to find a Vehicle
     * @example
     * // Get one Vehicle
     * const vehicle = await prisma.vehicle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VehicleFindUniqueArgs>(args: SelectSubset<T, VehicleFindUniqueArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Vehicle that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VehicleFindUniqueOrThrowArgs} args - Arguments to find a Vehicle
     * @example
     * // Get one Vehicle
     * const vehicle = await prisma.vehicle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VehicleFindUniqueOrThrowArgs>(args: SelectSubset<T, VehicleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Vehicle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleFindFirstArgs} args - Arguments to find a Vehicle
     * @example
     * // Get one Vehicle
     * const vehicle = await prisma.vehicle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VehicleFindFirstArgs>(args?: SelectSubset<T, VehicleFindFirstArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Vehicle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleFindFirstOrThrowArgs} args - Arguments to find a Vehicle
     * @example
     * // Get one Vehicle
     * const vehicle = await prisma.vehicle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VehicleFindFirstOrThrowArgs>(args?: SelectSubset<T, VehicleFindFirstOrThrowArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Vehicles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vehicles
     * const vehicles = await prisma.vehicle.findMany()
     * 
     * // Get first 10 Vehicles
     * const vehicles = await prisma.vehicle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vehicleWithIdOnly = await prisma.vehicle.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VehicleFindManyArgs>(args?: SelectSubset<T, VehicleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Vehicle.
     * @param {VehicleCreateArgs} args - Arguments to create a Vehicle.
     * @example
     * // Create one Vehicle
     * const Vehicle = await prisma.vehicle.create({
     *   data: {
     *     // ... data to create a Vehicle
     *   }
     * })
     * 
     */
    create<T extends VehicleCreateArgs>(args: SelectSubset<T, VehicleCreateArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Vehicles.
     * @param {VehicleCreateManyArgs} args - Arguments to create many Vehicles.
     * @example
     * // Create many Vehicles
     * const vehicle = await prisma.vehicle.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VehicleCreateManyArgs>(args?: SelectSubset<T, VehicleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Vehicles and returns the data saved in the database.
     * @param {VehicleCreateManyAndReturnArgs} args - Arguments to create many Vehicles.
     * @example
     * // Create many Vehicles
     * const vehicle = await prisma.vehicle.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Vehicles and only return the `id`
     * const vehicleWithIdOnly = await prisma.vehicle.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VehicleCreateManyAndReturnArgs>(args?: SelectSubset<T, VehicleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Vehicle.
     * @param {VehicleDeleteArgs} args - Arguments to delete one Vehicle.
     * @example
     * // Delete one Vehicle
     * const Vehicle = await prisma.vehicle.delete({
     *   where: {
     *     // ... filter to delete one Vehicle
     *   }
     * })
     * 
     */
    delete<T extends VehicleDeleteArgs>(args: SelectSubset<T, VehicleDeleteArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Vehicle.
     * @param {VehicleUpdateArgs} args - Arguments to update one Vehicle.
     * @example
     * // Update one Vehicle
     * const vehicle = await prisma.vehicle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VehicleUpdateArgs>(args: SelectSubset<T, VehicleUpdateArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Vehicles.
     * @param {VehicleDeleteManyArgs} args - Arguments to filter Vehicles to delete.
     * @example
     * // Delete a few Vehicles
     * const { count } = await prisma.vehicle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VehicleDeleteManyArgs>(args?: SelectSubset<T, VehicleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vehicles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vehicles
     * const vehicle = await prisma.vehicle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VehicleUpdateManyArgs>(args: SelectSubset<T, VehicleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Vehicle.
     * @param {VehicleUpsertArgs} args - Arguments to update or create a Vehicle.
     * @example
     * // Update or create a Vehicle
     * const vehicle = await prisma.vehicle.upsert({
     *   create: {
     *     // ... data to create a Vehicle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vehicle we want to update
     *   }
     * })
     */
    upsert<T extends VehicleUpsertArgs>(args: SelectSubset<T, VehicleUpsertArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Vehicles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleCountArgs} args - Arguments to filter Vehicles to count.
     * @example
     * // Count the number of Vehicles
     * const count = await prisma.vehicle.count({
     *   where: {
     *     // ... the filter for the Vehicles we want to count
     *   }
     * })
    **/
    count<T extends VehicleCountArgs>(
      args?: Subset<T, VehicleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VehicleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vehicle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VehicleAggregateArgs>(args: Subset<T, VehicleAggregateArgs>): Prisma.PrismaPromise<GetVehicleAggregateType<T>>

    /**
     * Group by Vehicle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VehicleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VehicleGroupByArgs['orderBy'] }
        : { orderBy?: VehicleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VehicleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVehicleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Vehicle model
   */
  readonly fields: VehicleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Vehicle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VehicleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    model<T extends VehicleModelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VehicleModelDefaultArgs<ExtArgs>>): Prisma__VehicleModelClient<$Result.GetResult<Prisma.$VehicleModelPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    trips<T extends Vehicle$tripsArgs<ExtArgs> = {}>(args?: Subset<T, Vehicle$tripsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "findMany"> | Null>
    shifts<T extends Vehicle$shiftsArgs<ExtArgs> = {}>(args?: Subset<T, Vehicle$shiftsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findMany"> | Null>
    telemetry<T extends Vehicle$telemetryArgs<ExtArgs> = {}>(args?: Subset<T, Vehicle$telemetryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehicleTelemetryPayload<ExtArgs>, T, "findMany"> | Null>
    telemetryHistory<T extends Vehicle$telemetryHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Vehicle$telemetryHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehicleTelemetryHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    Duty<T extends Vehicle$DutyArgs<ExtArgs> = {}>(args?: Subset<T, Vehicle$DutyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DutyPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Vehicle model
   */ 
  interface VehicleFieldRefs {
    readonly id: FieldRef<"Vehicle", 'BigInt'>
    readonly plateNo: FieldRef<"Vehicle", 'String'>
    readonly fleetNo: FieldRef<"Vehicle", 'String'>
    readonly modelId: FieldRef<"Vehicle", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * Vehicle findUnique
   */
  export type VehicleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter, which Vehicle to fetch.
     */
    where: VehicleWhereUniqueInput
  }

  /**
   * Vehicle findUniqueOrThrow
   */
  export type VehicleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter, which Vehicle to fetch.
     */
    where: VehicleWhereUniqueInput
  }

  /**
   * Vehicle findFirst
   */
  export type VehicleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter, which Vehicle to fetch.
     */
    where?: VehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vehicles to fetch.
     */
    orderBy?: VehicleOrderByWithRelationInput | VehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vehicles.
     */
    cursor?: VehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vehicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vehicles.
     */
    distinct?: VehicleScalarFieldEnum | VehicleScalarFieldEnum[]
  }

  /**
   * Vehicle findFirstOrThrow
   */
  export type VehicleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter, which Vehicle to fetch.
     */
    where?: VehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vehicles to fetch.
     */
    orderBy?: VehicleOrderByWithRelationInput | VehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vehicles.
     */
    cursor?: VehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vehicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vehicles.
     */
    distinct?: VehicleScalarFieldEnum | VehicleScalarFieldEnum[]
  }

  /**
   * Vehicle findMany
   */
  export type VehicleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter, which Vehicles to fetch.
     */
    where?: VehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vehicles to fetch.
     */
    orderBy?: VehicleOrderByWithRelationInput | VehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Vehicles.
     */
    cursor?: VehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vehicles.
     */
    skip?: number
    distinct?: VehicleScalarFieldEnum | VehicleScalarFieldEnum[]
  }

  /**
   * Vehicle create
   */
  export type VehicleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * The data needed to create a Vehicle.
     */
    data: XOR<VehicleCreateInput, VehicleUncheckedCreateInput>
  }

  /**
   * Vehicle createMany
   */
  export type VehicleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Vehicles.
     */
    data: VehicleCreateManyInput | VehicleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Vehicle createManyAndReturn
   */
  export type VehicleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Vehicles.
     */
    data: VehicleCreateManyInput | VehicleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Vehicle update
   */
  export type VehicleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * The data needed to update a Vehicle.
     */
    data: XOR<VehicleUpdateInput, VehicleUncheckedUpdateInput>
    /**
     * Choose, which Vehicle to update.
     */
    where: VehicleWhereUniqueInput
  }

  /**
   * Vehicle updateMany
   */
  export type VehicleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Vehicles.
     */
    data: XOR<VehicleUpdateManyMutationInput, VehicleUncheckedUpdateManyInput>
    /**
     * Filter which Vehicles to update
     */
    where?: VehicleWhereInput
  }

  /**
   * Vehicle upsert
   */
  export type VehicleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * The filter to search for the Vehicle to update in case it exists.
     */
    where: VehicleWhereUniqueInput
    /**
     * In case the Vehicle found by the `where` argument doesn't exist, create a new Vehicle with this data.
     */
    create: XOR<VehicleCreateInput, VehicleUncheckedCreateInput>
    /**
     * In case the Vehicle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VehicleUpdateInput, VehicleUncheckedUpdateInput>
  }

  /**
   * Vehicle delete
   */
  export type VehicleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter which Vehicle to delete.
     */
    where: VehicleWhereUniqueInput
  }

  /**
   * Vehicle deleteMany
   */
  export type VehicleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vehicles to delete
     */
    where?: VehicleWhereInput
  }

  /**
   * Vehicle.trips
   */
  export type Vehicle$tripsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    where?: TripWhereInput
    orderBy?: TripOrderByWithRelationInput | TripOrderByWithRelationInput[]
    cursor?: TripWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TripScalarFieldEnum | TripScalarFieldEnum[]
  }

  /**
   * Vehicle.shifts
   */
  export type Vehicle$shiftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    where?: ShiftWhereInput
    orderBy?: ShiftOrderByWithRelationInput | ShiftOrderByWithRelationInput[]
    cursor?: ShiftWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShiftScalarFieldEnum | ShiftScalarFieldEnum[]
  }

  /**
   * Vehicle.telemetry
   */
  export type Vehicle$telemetryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleTelemetry
     */
    select?: VehicleTelemetrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleTelemetryInclude<ExtArgs> | null
    where?: VehicleTelemetryWhereInput
    orderBy?: VehicleTelemetryOrderByWithRelationInput | VehicleTelemetryOrderByWithRelationInput[]
    cursor?: VehicleTelemetryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VehicleTelemetryScalarFieldEnum | VehicleTelemetryScalarFieldEnum[]
  }

  /**
   * Vehicle.telemetryHistory
   */
  export type Vehicle$telemetryHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleTelemetryHistory
     */
    select?: VehicleTelemetryHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleTelemetryHistoryInclude<ExtArgs> | null
    where?: VehicleTelemetryHistoryWhereInput
    orderBy?: VehicleTelemetryHistoryOrderByWithRelationInput | VehicleTelemetryHistoryOrderByWithRelationInput[]
    cursor?: VehicleTelemetryHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VehicleTelemetryHistoryScalarFieldEnum | VehicleTelemetryHistoryScalarFieldEnum[]
  }

  /**
   * Vehicle.Duty
   */
  export type Vehicle$DutyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Duty
     */
    select?: DutySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DutyInclude<ExtArgs> | null
    where?: DutyWhereInput
    orderBy?: DutyOrderByWithRelationInput | DutyOrderByWithRelationInput[]
    cursor?: DutyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DutyScalarFieldEnum | DutyScalarFieldEnum[]
  }

  /**
   * Vehicle without action
   */
  export type VehicleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
  }


  /**
   * Model Location
   */

  export type AggregateLocation = {
    _count: LocationCountAggregateOutputType | null
    _avg: LocationAvgAggregateOutputType | null
    _sum: LocationSumAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  export type LocationAvgAggregateOutputType = {
    id: number | null
    lat: Decimal | null
    lon: Decimal | null
  }

  export type LocationSumAggregateOutputType = {
    id: bigint | null
    lat: Decimal | null
    lon: Decimal | null
  }

  export type LocationMinAggregateOutputType = {
    id: bigint | null
    lat: Decimal | null
    lon: Decimal | null
  }

  export type LocationMaxAggregateOutputType = {
    id: bigint | null
    lat: Decimal | null
    lon: Decimal | null
  }

  export type LocationCountAggregateOutputType = {
    id: number
    lat: number
    lon: number
    _all: number
  }


  export type LocationAvgAggregateInputType = {
    id?: true
    lat?: true
    lon?: true
  }

  export type LocationSumAggregateInputType = {
    id?: true
    lat?: true
    lon?: true
  }

  export type LocationMinAggregateInputType = {
    id?: true
    lat?: true
    lon?: true
  }

  export type LocationMaxAggregateInputType = {
    id?: true
    lat?: true
    lon?: true
  }

  export type LocationCountAggregateInputType = {
    id?: true
    lat?: true
    lon?: true
    _all?: true
  }

  export type LocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Location to aggregate.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Locations
    **/
    _count?: true | LocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LocationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LocationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocationMaxAggregateInputType
  }

  export type GetLocationAggregateType<T extends LocationAggregateArgs> = {
        [P in keyof T & keyof AggregateLocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocation[P]>
      : GetScalarType<T[P], AggregateLocation[P]>
  }




  export type LocationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationWhereInput
    orderBy?: LocationOrderByWithAggregationInput | LocationOrderByWithAggregationInput[]
    by: LocationScalarFieldEnum[] | LocationScalarFieldEnum
    having?: LocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocationCountAggregateInputType | true
    _avg?: LocationAvgAggregateInputType
    _sum?: LocationSumAggregateInputType
    _min?: LocationMinAggregateInputType
    _max?: LocationMaxAggregateInputType
  }

  export type LocationGroupByOutputType = {
    id: bigint
    lat: Decimal
    lon: Decimal
    _count: LocationCountAggregateOutputType | null
    _avg: LocationAvgAggregateOutputType | null
    _sum: LocationSumAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  type GetLocationGroupByPayload<T extends LocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocationGroupByOutputType[P]>
            : GetScalarType<T[P], LocationGroupByOutputType[P]>
        }
      >
    >


  export type LocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lat?: boolean
    lon?: boolean
    stops?: boolean | Location$stopsArgs<ExtArgs>
    _count?: boolean | LocationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["location"]>

  export type LocationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lat?: boolean
    lon?: boolean
  }, ExtArgs["result"]["location"]>

  export type LocationSelectScalar = {
    id?: boolean
    lat?: boolean
    lon?: boolean
  }

  export type LocationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stops?: boolean | Location$stopsArgs<ExtArgs>
    _count?: boolean | LocationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LocationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $LocationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Location"
    objects: {
      stops: Prisma.$StopPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      lat: Prisma.Decimal
      lon: Prisma.Decimal
    }, ExtArgs["result"]["location"]>
    composites: {}
  }

  type LocationGetPayload<S extends boolean | null | undefined | LocationDefaultArgs> = $Result.GetResult<Prisma.$LocationPayload, S>

  type LocationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LocationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LocationCountAggregateInputType | true
    }

  export interface LocationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Location'], meta: { name: 'Location' } }
    /**
     * Find zero or one Location that matches the filter.
     * @param {LocationFindUniqueArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LocationFindUniqueArgs>(args: SelectSubset<T, LocationFindUniqueArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Location that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LocationFindUniqueOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LocationFindUniqueOrThrowArgs>(args: SelectSubset<T, LocationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Location that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindFirstArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LocationFindFirstArgs>(args?: SelectSubset<T, LocationFindFirstArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Location that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindFirstOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LocationFindFirstOrThrowArgs>(args?: SelectSubset<T, LocationFindFirstOrThrowArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Locations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Locations
     * const locations = await prisma.location.findMany()
     * 
     * // Get first 10 Locations
     * const locations = await prisma.location.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const locationWithIdOnly = await prisma.location.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LocationFindManyArgs>(args?: SelectSubset<T, LocationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Location.
     * @param {LocationCreateArgs} args - Arguments to create a Location.
     * @example
     * // Create one Location
     * const Location = await prisma.location.create({
     *   data: {
     *     // ... data to create a Location
     *   }
     * })
     * 
     */
    create<T extends LocationCreateArgs>(args: SelectSubset<T, LocationCreateArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Locations.
     * @param {LocationCreateManyArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const location = await prisma.location.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LocationCreateManyArgs>(args?: SelectSubset<T, LocationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Locations and returns the data saved in the database.
     * @param {LocationCreateManyAndReturnArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const location = await prisma.location.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Locations and only return the `id`
     * const locationWithIdOnly = await prisma.location.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LocationCreateManyAndReturnArgs>(args?: SelectSubset<T, LocationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Location.
     * @param {LocationDeleteArgs} args - Arguments to delete one Location.
     * @example
     * // Delete one Location
     * const Location = await prisma.location.delete({
     *   where: {
     *     // ... filter to delete one Location
     *   }
     * })
     * 
     */
    delete<T extends LocationDeleteArgs>(args: SelectSubset<T, LocationDeleteArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Location.
     * @param {LocationUpdateArgs} args - Arguments to update one Location.
     * @example
     * // Update one Location
     * const location = await prisma.location.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LocationUpdateArgs>(args: SelectSubset<T, LocationUpdateArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Locations.
     * @param {LocationDeleteManyArgs} args - Arguments to filter Locations to delete.
     * @example
     * // Delete a few Locations
     * const { count } = await prisma.location.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LocationDeleteManyArgs>(args?: SelectSubset<T, LocationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Locations
     * const location = await prisma.location.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LocationUpdateManyArgs>(args: SelectSubset<T, LocationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Location.
     * @param {LocationUpsertArgs} args - Arguments to update or create a Location.
     * @example
     * // Update or create a Location
     * const location = await prisma.location.upsert({
     *   create: {
     *     // ... data to create a Location
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Location we want to update
     *   }
     * })
     */
    upsert<T extends LocationUpsertArgs>(args: SelectSubset<T, LocationUpsertArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationCountArgs} args - Arguments to filter Locations to count.
     * @example
     * // Count the number of Locations
     * const count = await prisma.location.count({
     *   where: {
     *     // ... the filter for the Locations we want to count
     *   }
     * })
    **/
    count<T extends LocationCountArgs>(
      args?: Subset<T, LocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocationAggregateArgs>(args: Subset<T, LocationAggregateArgs>): Prisma.PrismaPromise<GetLocationAggregateType<T>>

    /**
     * Group by Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocationGroupByArgs['orderBy'] }
        : { orderBy?: LocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Location model
   */
  readonly fields: LocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Location.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LocationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    stops<T extends Location$stopsArgs<ExtArgs> = {}>(args?: Subset<T, Location$stopsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StopPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Location model
   */ 
  interface LocationFieldRefs {
    readonly id: FieldRef<"Location", 'BigInt'>
    readonly lat: FieldRef<"Location", 'Decimal'>
    readonly lon: FieldRef<"Location", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * Location findUnique
   */
  export type LocationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location findUniqueOrThrow
   */
  export type LocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location findFirst
   */
  export type LocationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location findFirstOrThrow
   */
  export type LocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location findMany
   */
  export type LocationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Locations to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location create
   */
  export type LocationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The data needed to create a Location.
     */
    data: XOR<LocationCreateInput, LocationUncheckedCreateInput>
  }

  /**
   * Location createMany
   */
  export type LocationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Locations.
     */
    data: LocationCreateManyInput | LocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Location createManyAndReturn
   */
  export type LocationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Locations.
     */
    data: LocationCreateManyInput | LocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Location update
   */
  export type LocationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The data needed to update a Location.
     */
    data: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
    /**
     * Choose, which Location to update.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location updateMany
   */
  export type LocationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Locations.
     */
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyInput>
    /**
     * Filter which Locations to update
     */
    where?: LocationWhereInput
  }

  /**
   * Location upsert
   */
  export type LocationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The filter to search for the Location to update in case it exists.
     */
    where: LocationWhereUniqueInput
    /**
     * In case the Location found by the `where` argument doesn't exist, create a new Location with this data.
     */
    create: XOR<LocationCreateInput, LocationUncheckedCreateInput>
    /**
     * In case the Location was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
  }

  /**
   * Location delete
   */
  export type LocationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter which Location to delete.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location deleteMany
   */
  export type LocationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Locations to delete
     */
    where?: LocationWhereInput
  }

  /**
   * Location.stops
   */
  export type Location$stopsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stop
     */
    select?: StopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StopInclude<ExtArgs> | null
    where?: StopWhereInput
    orderBy?: StopOrderByWithRelationInput | StopOrderByWithRelationInput[]
    cursor?: StopWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StopScalarFieldEnum | StopScalarFieldEnum[]
  }

  /**
   * Location without action
   */
  export type LocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
  }


  /**
   * Model Stop
   */

  export type AggregateStop = {
    _count: StopCountAggregateOutputType | null
    _avg: StopAvgAggregateOutputType | null
    _sum: StopSumAggregateOutputType | null
    _min: StopMinAggregateOutputType | null
    _max: StopMaxAggregateOutputType | null
  }

  export type StopAvgAggregateOutputType = {
    id: number | null
    locationId: number | null
  }

  export type StopSumAggregateOutputType = {
    id: bigint | null
    locationId: bigint | null
  }

  export type StopMinAggregateOutputType = {
    id: bigint | null
    locationId: bigint | null
    name: string | null
    code: string | null
  }

  export type StopMaxAggregateOutputType = {
    id: bigint | null
    locationId: bigint | null
    name: string | null
    code: string | null
  }

  export type StopCountAggregateOutputType = {
    id: number
    locationId: number
    name: number
    code: number
    _all: number
  }


  export type StopAvgAggregateInputType = {
    id?: true
    locationId?: true
  }

  export type StopSumAggregateInputType = {
    id?: true
    locationId?: true
  }

  export type StopMinAggregateInputType = {
    id?: true
    locationId?: true
    name?: true
    code?: true
  }

  export type StopMaxAggregateInputType = {
    id?: true
    locationId?: true
    name?: true
    code?: true
  }

  export type StopCountAggregateInputType = {
    id?: true
    locationId?: true
    name?: true
    code?: true
    _all?: true
  }

  export type StopAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stop to aggregate.
     */
    where?: StopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stops to fetch.
     */
    orderBy?: StopOrderByWithRelationInput | StopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Stops
    **/
    _count?: true | StopCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StopAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StopSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StopMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StopMaxAggregateInputType
  }

  export type GetStopAggregateType<T extends StopAggregateArgs> = {
        [P in keyof T & keyof AggregateStop]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStop[P]>
      : GetScalarType<T[P], AggregateStop[P]>
  }




  export type StopGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StopWhereInput
    orderBy?: StopOrderByWithAggregationInput | StopOrderByWithAggregationInput[]
    by: StopScalarFieldEnum[] | StopScalarFieldEnum
    having?: StopScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StopCountAggregateInputType | true
    _avg?: StopAvgAggregateInputType
    _sum?: StopSumAggregateInputType
    _min?: StopMinAggregateInputType
    _max?: StopMaxAggregateInputType
  }

  export type StopGroupByOutputType = {
    id: bigint
    locationId: bigint
    name: string
    code: string
    _count: StopCountAggregateOutputType | null
    _avg: StopAvgAggregateOutputType | null
    _sum: StopSumAggregateOutputType | null
    _min: StopMinAggregateOutputType | null
    _max: StopMaxAggregateOutputType | null
  }

  type GetStopGroupByPayload<T extends StopGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StopGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StopGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StopGroupByOutputType[P]>
            : GetScalarType<T[P], StopGroupByOutputType[P]>
        }
      >
    >


  export type StopSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    locationId?: boolean
    name?: boolean
    code?: boolean
    location?: boolean | LocationDefaultArgs<ExtArgs>
    routeStops?: boolean | Stop$routeStopsArgs<ExtArgs>
    tripStops?: boolean | Stop$tripStopsArgs<ExtArgs>
    _count?: boolean | StopCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stop"]>

  export type StopSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    locationId?: boolean
    name?: boolean
    code?: boolean
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stop"]>

  export type StopSelectScalar = {
    id?: boolean
    locationId?: boolean
    name?: boolean
    code?: boolean
  }

  export type StopInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LocationDefaultArgs<ExtArgs>
    routeStops?: boolean | Stop$routeStopsArgs<ExtArgs>
    tripStops?: boolean | Stop$tripStopsArgs<ExtArgs>
    _count?: boolean | StopCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StopIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }

  export type $StopPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Stop"
    objects: {
      location: Prisma.$LocationPayload<ExtArgs>
      routeStops: Prisma.$RouteStopPayload<ExtArgs>[]
      tripStops: Prisma.$TripStopPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      locationId: bigint
      name: string
      code: string
    }, ExtArgs["result"]["stop"]>
    composites: {}
  }

  type StopGetPayload<S extends boolean | null | undefined | StopDefaultArgs> = $Result.GetResult<Prisma.$StopPayload, S>

  type StopCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StopFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StopCountAggregateInputType | true
    }

  export interface StopDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Stop'], meta: { name: 'Stop' } }
    /**
     * Find zero or one Stop that matches the filter.
     * @param {StopFindUniqueArgs} args - Arguments to find a Stop
     * @example
     * // Get one Stop
     * const stop = await prisma.stop.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StopFindUniqueArgs>(args: SelectSubset<T, StopFindUniqueArgs<ExtArgs>>): Prisma__StopClient<$Result.GetResult<Prisma.$StopPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Stop that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StopFindUniqueOrThrowArgs} args - Arguments to find a Stop
     * @example
     * // Get one Stop
     * const stop = await prisma.stop.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StopFindUniqueOrThrowArgs>(args: SelectSubset<T, StopFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StopClient<$Result.GetResult<Prisma.$StopPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Stop that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StopFindFirstArgs} args - Arguments to find a Stop
     * @example
     * // Get one Stop
     * const stop = await prisma.stop.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StopFindFirstArgs>(args?: SelectSubset<T, StopFindFirstArgs<ExtArgs>>): Prisma__StopClient<$Result.GetResult<Prisma.$StopPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Stop that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StopFindFirstOrThrowArgs} args - Arguments to find a Stop
     * @example
     * // Get one Stop
     * const stop = await prisma.stop.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StopFindFirstOrThrowArgs>(args?: SelectSubset<T, StopFindFirstOrThrowArgs<ExtArgs>>): Prisma__StopClient<$Result.GetResult<Prisma.$StopPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Stops that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StopFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Stops
     * const stops = await prisma.stop.findMany()
     * 
     * // Get first 10 Stops
     * const stops = await prisma.stop.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stopWithIdOnly = await prisma.stop.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StopFindManyArgs>(args?: SelectSubset<T, StopFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StopPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Stop.
     * @param {StopCreateArgs} args - Arguments to create a Stop.
     * @example
     * // Create one Stop
     * const Stop = await prisma.stop.create({
     *   data: {
     *     // ... data to create a Stop
     *   }
     * })
     * 
     */
    create<T extends StopCreateArgs>(args: SelectSubset<T, StopCreateArgs<ExtArgs>>): Prisma__StopClient<$Result.GetResult<Prisma.$StopPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Stops.
     * @param {StopCreateManyArgs} args - Arguments to create many Stops.
     * @example
     * // Create many Stops
     * const stop = await prisma.stop.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StopCreateManyArgs>(args?: SelectSubset<T, StopCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Stops and returns the data saved in the database.
     * @param {StopCreateManyAndReturnArgs} args - Arguments to create many Stops.
     * @example
     * // Create many Stops
     * const stop = await prisma.stop.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Stops and only return the `id`
     * const stopWithIdOnly = await prisma.stop.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StopCreateManyAndReturnArgs>(args?: SelectSubset<T, StopCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StopPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Stop.
     * @param {StopDeleteArgs} args - Arguments to delete one Stop.
     * @example
     * // Delete one Stop
     * const Stop = await prisma.stop.delete({
     *   where: {
     *     // ... filter to delete one Stop
     *   }
     * })
     * 
     */
    delete<T extends StopDeleteArgs>(args: SelectSubset<T, StopDeleteArgs<ExtArgs>>): Prisma__StopClient<$Result.GetResult<Prisma.$StopPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Stop.
     * @param {StopUpdateArgs} args - Arguments to update one Stop.
     * @example
     * // Update one Stop
     * const stop = await prisma.stop.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StopUpdateArgs>(args: SelectSubset<T, StopUpdateArgs<ExtArgs>>): Prisma__StopClient<$Result.GetResult<Prisma.$StopPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Stops.
     * @param {StopDeleteManyArgs} args - Arguments to filter Stops to delete.
     * @example
     * // Delete a few Stops
     * const { count } = await prisma.stop.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StopDeleteManyArgs>(args?: SelectSubset<T, StopDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StopUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Stops
     * const stop = await prisma.stop.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StopUpdateManyArgs>(args: SelectSubset<T, StopUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Stop.
     * @param {StopUpsertArgs} args - Arguments to update or create a Stop.
     * @example
     * // Update or create a Stop
     * const stop = await prisma.stop.upsert({
     *   create: {
     *     // ... data to create a Stop
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Stop we want to update
     *   }
     * })
     */
    upsert<T extends StopUpsertArgs>(args: SelectSubset<T, StopUpsertArgs<ExtArgs>>): Prisma__StopClient<$Result.GetResult<Prisma.$StopPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Stops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StopCountArgs} args - Arguments to filter Stops to count.
     * @example
     * // Count the number of Stops
     * const count = await prisma.stop.count({
     *   where: {
     *     // ... the filter for the Stops we want to count
     *   }
     * })
    **/
    count<T extends StopCountArgs>(
      args?: Subset<T, StopCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StopCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Stop.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StopAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StopAggregateArgs>(args: Subset<T, StopAggregateArgs>): Prisma.PrismaPromise<GetStopAggregateType<T>>

    /**
     * Group by Stop.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StopGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StopGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StopGroupByArgs['orderBy'] }
        : { orderBy?: StopGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StopGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStopGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Stop model
   */
  readonly fields: StopFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Stop.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StopClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    location<T extends LocationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocationDefaultArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    routeStops<T extends Stop$routeStopsArgs<ExtArgs> = {}>(args?: Subset<T, Stop$routeStopsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RouteStopPayload<ExtArgs>, T, "findMany"> | Null>
    tripStops<T extends Stop$tripStopsArgs<ExtArgs> = {}>(args?: Subset<T, Stop$tripStopsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripStopPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Stop model
   */ 
  interface StopFieldRefs {
    readonly id: FieldRef<"Stop", 'BigInt'>
    readonly locationId: FieldRef<"Stop", 'BigInt'>
    readonly name: FieldRef<"Stop", 'String'>
    readonly code: FieldRef<"Stop", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Stop findUnique
   */
  export type StopFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stop
     */
    select?: StopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StopInclude<ExtArgs> | null
    /**
     * Filter, which Stop to fetch.
     */
    where: StopWhereUniqueInput
  }

  /**
   * Stop findUniqueOrThrow
   */
  export type StopFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stop
     */
    select?: StopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StopInclude<ExtArgs> | null
    /**
     * Filter, which Stop to fetch.
     */
    where: StopWhereUniqueInput
  }

  /**
   * Stop findFirst
   */
  export type StopFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stop
     */
    select?: StopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StopInclude<ExtArgs> | null
    /**
     * Filter, which Stop to fetch.
     */
    where?: StopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stops to fetch.
     */
    orderBy?: StopOrderByWithRelationInput | StopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stops.
     */
    cursor?: StopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stops.
     */
    distinct?: StopScalarFieldEnum | StopScalarFieldEnum[]
  }

  /**
   * Stop findFirstOrThrow
   */
  export type StopFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stop
     */
    select?: StopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StopInclude<ExtArgs> | null
    /**
     * Filter, which Stop to fetch.
     */
    where?: StopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stops to fetch.
     */
    orderBy?: StopOrderByWithRelationInput | StopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stops.
     */
    cursor?: StopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stops.
     */
    distinct?: StopScalarFieldEnum | StopScalarFieldEnum[]
  }

  /**
   * Stop findMany
   */
  export type StopFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stop
     */
    select?: StopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StopInclude<ExtArgs> | null
    /**
     * Filter, which Stops to fetch.
     */
    where?: StopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stops to fetch.
     */
    orderBy?: StopOrderByWithRelationInput | StopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Stops.
     */
    cursor?: StopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stops.
     */
    skip?: number
    distinct?: StopScalarFieldEnum | StopScalarFieldEnum[]
  }

  /**
   * Stop create
   */
  export type StopCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stop
     */
    select?: StopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StopInclude<ExtArgs> | null
    /**
     * The data needed to create a Stop.
     */
    data: XOR<StopCreateInput, StopUncheckedCreateInput>
  }

  /**
   * Stop createMany
   */
  export type StopCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Stops.
     */
    data: StopCreateManyInput | StopCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Stop createManyAndReturn
   */
  export type StopCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stop
     */
    select?: StopSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Stops.
     */
    data: StopCreateManyInput | StopCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StopIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Stop update
   */
  export type StopUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stop
     */
    select?: StopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StopInclude<ExtArgs> | null
    /**
     * The data needed to update a Stop.
     */
    data: XOR<StopUpdateInput, StopUncheckedUpdateInput>
    /**
     * Choose, which Stop to update.
     */
    where: StopWhereUniqueInput
  }

  /**
   * Stop updateMany
   */
  export type StopUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Stops.
     */
    data: XOR<StopUpdateManyMutationInput, StopUncheckedUpdateManyInput>
    /**
     * Filter which Stops to update
     */
    where?: StopWhereInput
  }

  /**
   * Stop upsert
   */
  export type StopUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stop
     */
    select?: StopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StopInclude<ExtArgs> | null
    /**
     * The filter to search for the Stop to update in case it exists.
     */
    where: StopWhereUniqueInput
    /**
     * In case the Stop found by the `where` argument doesn't exist, create a new Stop with this data.
     */
    create: XOR<StopCreateInput, StopUncheckedCreateInput>
    /**
     * In case the Stop was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StopUpdateInput, StopUncheckedUpdateInput>
  }

  /**
   * Stop delete
   */
  export type StopDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stop
     */
    select?: StopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StopInclude<ExtArgs> | null
    /**
     * Filter which Stop to delete.
     */
    where: StopWhereUniqueInput
  }

  /**
   * Stop deleteMany
   */
  export type StopDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stops to delete
     */
    where?: StopWhereInput
  }

  /**
   * Stop.routeStops
   */
  export type Stop$routeStopsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteStop
     */
    select?: RouteStopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteStopInclude<ExtArgs> | null
    where?: RouteStopWhereInput
    orderBy?: RouteStopOrderByWithRelationInput | RouteStopOrderByWithRelationInput[]
    cursor?: RouteStopWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RouteStopScalarFieldEnum | RouteStopScalarFieldEnum[]
  }

  /**
   * Stop.tripStops
   */
  export type Stop$tripStopsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripStop
     */
    select?: TripStopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripStopInclude<ExtArgs> | null
    where?: TripStopWhereInput
    orderBy?: TripStopOrderByWithRelationInput | TripStopOrderByWithRelationInput[]
    cursor?: TripStopWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TripStopScalarFieldEnum | TripStopScalarFieldEnum[]
  }

  /**
   * Stop without action
   */
  export type StopDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stop
     */
    select?: StopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StopInclude<ExtArgs> | null
  }


  /**
   * Model Route
   */

  export type AggregateRoute = {
    _count: RouteCountAggregateOutputType | null
    _avg: RouteAvgAggregateOutputType | null
    _sum: RouteSumAggregateOutputType | null
    _min: RouteMinAggregateOutputType | null
    _max: RouteMaxAggregateOutputType | null
  }

  export type RouteAvgAggregateOutputType = {
    id: number | null
    totalEstimatedDuration: number | null
  }

  export type RouteSumAggregateOutputType = {
    id: bigint | null
    totalEstimatedDuration: number | null
  }

  export type RouteMinAggregateOutputType = {
    id: bigint | null
    name: string | null
    code: string | null
    isActive: boolean | null
    totalEstimatedDuration: number | null
  }

  export type RouteMaxAggregateOutputType = {
    id: bigint | null
    name: string | null
    code: string | null
    isActive: boolean | null
    totalEstimatedDuration: number | null
  }

  export type RouteCountAggregateOutputType = {
    id: number
    name: number
    code: number
    isActive: number
    totalEstimatedDuration: number
    _all: number
  }


  export type RouteAvgAggregateInputType = {
    id?: true
    totalEstimatedDuration?: true
  }

  export type RouteSumAggregateInputType = {
    id?: true
    totalEstimatedDuration?: true
  }

  export type RouteMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    isActive?: true
    totalEstimatedDuration?: true
  }

  export type RouteMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    isActive?: true
    totalEstimatedDuration?: true
  }

  export type RouteCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    isActive?: true
    totalEstimatedDuration?: true
    _all?: true
  }

  export type RouteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Route to aggregate.
     */
    where?: RouteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Routes to fetch.
     */
    orderBy?: RouteOrderByWithRelationInput | RouteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RouteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Routes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Routes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Routes
    **/
    _count?: true | RouteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RouteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RouteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RouteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RouteMaxAggregateInputType
  }

  export type GetRouteAggregateType<T extends RouteAggregateArgs> = {
        [P in keyof T & keyof AggregateRoute]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoute[P]>
      : GetScalarType<T[P], AggregateRoute[P]>
  }




  export type RouteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RouteWhereInput
    orderBy?: RouteOrderByWithAggregationInput | RouteOrderByWithAggregationInput[]
    by: RouteScalarFieldEnum[] | RouteScalarFieldEnum
    having?: RouteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RouteCountAggregateInputType | true
    _avg?: RouteAvgAggregateInputType
    _sum?: RouteSumAggregateInputType
    _min?: RouteMinAggregateInputType
    _max?: RouteMaxAggregateInputType
  }

  export type RouteGroupByOutputType = {
    id: bigint
    name: string
    code: string
    isActive: boolean
    totalEstimatedDuration: number
    _count: RouteCountAggregateOutputType | null
    _avg: RouteAvgAggregateOutputType | null
    _sum: RouteSumAggregateOutputType | null
    _min: RouteMinAggregateOutputType | null
    _max: RouteMaxAggregateOutputType | null
  }

  type GetRouteGroupByPayload<T extends RouteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RouteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RouteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RouteGroupByOutputType[P]>
            : GetScalarType<T[P], RouteGroupByOutputType[P]>
        }
      >
    >


  export type RouteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    isActive?: boolean
    totalEstimatedDuration?: boolean
    routeStops?: boolean | Route$routeStopsArgs<ExtArgs>
    trips?: boolean | Route$tripsArgs<ExtArgs>
    TripDuty?: boolean | Route$TripDutyArgs<ExtArgs>
    _count?: boolean | RouteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["route"]>

  export type RouteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    isActive?: boolean
    totalEstimatedDuration?: boolean
  }, ExtArgs["result"]["route"]>

  export type RouteSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    isActive?: boolean
    totalEstimatedDuration?: boolean
  }

  export type RouteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    routeStops?: boolean | Route$routeStopsArgs<ExtArgs>
    trips?: boolean | Route$tripsArgs<ExtArgs>
    TripDuty?: boolean | Route$TripDutyArgs<ExtArgs>
    _count?: boolean | RouteCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RouteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RoutePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Route"
    objects: {
      routeStops: Prisma.$RouteStopPayload<ExtArgs>[]
      trips: Prisma.$TripPayload<ExtArgs>[]
      TripDuty: Prisma.$TripDutyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      name: string
      code: string
      isActive: boolean
      totalEstimatedDuration: number
    }, ExtArgs["result"]["route"]>
    composites: {}
  }

  type RouteGetPayload<S extends boolean | null | undefined | RouteDefaultArgs> = $Result.GetResult<Prisma.$RoutePayload, S>

  type RouteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RouteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RouteCountAggregateInputType | true
    }

  export interface RouteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Route'], meta: { name: 'Route' } }
    /**
     * Find zero or one Route that matches the filter.
     * @param {RouteFindUniqueArgs} args - Arguments to find a Route
     * @example
     * // Get one Route
     * const route = await prisma.route.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RouteFindUniqueArgs>(args: SelectSubset<T, RouteFindUniqueArgs<ExtArgs>>): Prisma__RouteClient<$Result.GetResult<Prisma.$RoutePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Route that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RouteFindUniqueOrThrowArgs} args - Arguments to find a Route
     * @example
     * // Get one Route
     * const route = await prisma.route.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RouteFindUniqueOrThrowArgs>(args: SelectSubset<T, RouteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RouteClient<$Result.GetResult<Prisma.$RoutePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Route that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteFindFirstArgs} args - Arguments to find a Route
     * @example
     * // Get one Route
     * const route = await prisma.route.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RouteFindFirstArgs>(args?: SelectSubset<T, RouteFindFirstArgs<ExtArgs>>): Prisma__RouteClient<$Result.GetResult<Prisma.$RoutePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Route that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteFindFirstOrThrowArgs} args - Arguments to find a Route
     * @example
     * // Get one Route
     * const route = await prisma.route.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RouteFindFirstOrThrowArgs>(args?: SelectSubset<T, RouteFindFirstOrThrowArgs<ExtArgs>>): Prisma__RouteClient<$Result.GetResult<Prisma.$RoutePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Routes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Routes
     * const routes = await prisma.route.findMany()
     * 
     * // Get first 10 Routes
     * const routes = await prisma.route.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const routeWithIdOnly = await prisma.route.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RouteFindManyArgs>(args?: SelectSubset<T, RouteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoutePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Route.
     * @param {RouteCreateArgs} args - Arguments to create a Route.
     * @example
     * // Create one Route
     * const Route = await prisma.route.create({
     *   data: {
     *     // ... data to create a Route
     *   }
     * })
     * 
     */
    create<T extends RouteCreateArgs>(args: SelectSubset<T, RouteCreateArgs<ExtArgs>>): Prisma__RouteClient<$Result.GetResult<Prisma.$RoutePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Routes.
     * @param {RouteCreateManyArgs} args - Arguments to create many Routes.
     * @example
     * // Create many Routes
     * const route = await prisma.route.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RouteCreateManyArgs>(args?: SelectSubset<T, RouteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Routes and returns the data saved in the database.
     * @param {RouteCreateManyAndReturnArgs} args - Arguments to create many Routes.
     * @example
     * // Create many Routes
     * const route = await prisma.route.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Routes and only return the `id`
     * const routeWithIdOnly = await prisma.route.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RouteCreateManyAndReturnArgs>(args?: SelectSubset<T, RouteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoutePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Route.
     * @param {RouteDeleteArgs} args - Arguments to delete one Route.
     * @example
     * // Delete one Route
     * const Route = await prisma.route.delete({
     *   where: {
     *     // ... filter to delete one Route
     *   }
     * })
     * 
     */
    delete<T extends RouteDeleteArgs>(args: SelectSubset<T, RouteDeleteArgs<ExtArgs>>): Prisma__RouteClient<$Result.GetResult<Prisma.$RoutePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Route.
     * @param {RouteUpdateArgs} args - Arguments to update one Route.
     * @example
     * // Update one Route
     * const route = await prisma.route.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RouteUpdateArgs>(args: SelectSubset<T, RouteUpdateArgs<ExtArgs>>): Prisma__RouteClient<$Result.GetResult<Prisma.$RoutePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Routes.
     * @param {RouteDeleteManyArgs} args - Arguments to filter Routes to delete.
     * @example
     * // Delete a few Routes
     * const { count } = await prisma.route.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RouteDeleteManyArgs>(args?: SelectSubset<T, RouteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Routes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Routes
     * const route = await prisma.route.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RouteUpdateManyArgs>(args: SelectSubset<T, RouteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Route.
     * @param {RouteUpsertArgs} args - Arguments to update or create a Route.
     * @example
     * // Update or create a Route
     * const route = await prisma.route.upsert({
     *   create: {
     *     // ... data to create a Route
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Route we want to update
     *   }
     * })
     */
    upsert<T extends RouteUpsertArgs>(args: SelectSubset<T, RouteUpsertArgs<ExtArgs>>): Prisma__RouteClient<$Result.GetResult<Prisma.$RoutePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Routes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteCountArgs} args - Arguments to filter Routes to count.
     * @example
     * // Count the number of Routes
     * const count = await prisma.route.count({
     *   where: {
     *     // ... the filter for the Routes we want to count
     *   }
     * })
    **/
    count<T extends RouteCountArgs>(
      args?: Subset<T, RouteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RouteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Route.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RouteAggregateArgs>(args: Subset<T, RouteAggregateArgs>): Prisma.PrismaPromise<GetRouteAggregateType<T>>

    /**
     * Group by Route.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RouteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RouteGroupByArgs['orderBy'] }
        : { orderBy?: RouteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RouteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRouteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Route model
   */
  readonly fields: RouteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Route.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RouteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    routeStops<T extends Route$routeStopsArgs<ExtArgs> = {}>(args?: Subset<T, Route$routeStopsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RouteStopPayload<ExtArgs>, T, "findMany"> | Null>
    trips<T extends Route$tripsArgs<ExtArgs> = {}>(args?: Subset<T, Route$tripsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "findMany"> | Null>
    TripDuty<T extends Route$TripDutyArgs<ExtArgs> = {}>(args?: Subset<T, Route$TripDutyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripDutyPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Route model
   */ 
  interface RouteFieldRefs {
    readonly id: FieldRef<"Route", 'BigInt'>
    readonly name: FieldRef<"Route", 'String'>
    readonly code: FieldRef<"Route", 'String'>
    readonly isActive: FieldRef<"Route", 'Boolean'>
    readonly totalEstimatedDuration: FieldRef<"Route", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Route findUnique
   */
  export type RouteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteInclude<ExtArgs> | null
    /**
     * Filter, which Route to fetch.
     */
    where: RouteWhereUniqueInput
  }

  /**
   * Route findUniqueOrThrow
   */
  export type RouteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteInclude<ExtArgs> | null
    /**
     * Filter, which Route to fetch.
     */
    where: RouteWhereUniqueInput
  }

  /**
   * Route findFirst
   */
  export type RouteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteInclude<ExtArgs> | null
    /**
     * Filter, which Route to fetch.
     */
    where?: RouteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Routes to fetch.
     */
    orderBy?: RouteOrderByWithRelationInput | RouteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Routes.
     */
    cursor?: RouteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Routes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Routes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Routes.
     */
    distinct?: RouteScalarFieldEnum | RouteScalarFieldEnum[]
  }

  /**
   * Route findFirstOrThrow
   */
  export type RouteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteInclude<ExtArgs> | null
    /**
     * Filter, which Route to fetch.
     */
    where?: RouteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Routes to fetch.
     */
    orderBy?: RouteOrderByWithRelationInput | RouteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Routes.
     */
    cursor?: RouteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Routes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Routes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Routes.
     */
    distinct?: RouteScalarFieldEnum | RouteScalarFieldEnum[]
  }

  /**
   * Route findMany
   */
  export type RouteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteInclude<ExtArgs> | null
    /**
     * Filter, which Routes to fetch.
     */
    where?: RouteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Routes to fetch.
     */
    orderBy?: RouteOrderByWithRelationInput | RouteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Routes.
     */
    cursor?: RouteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Routes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Routes.
     */
    skip?: number
    distinct?: RouteScalarFieldEnum | RouteScalarFieldEnum[]
  }

  /**
   * Route create
   */
  export type RouteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteInclude<ExtArgs> | null
    /**
     * The data needed to create a Route.
     */
    data: XOR<RouteCreateInput, RouteUncheckedCreateInput>
  }

  /**
   * Route createMany
   */
  export type RouteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Routes.
     */
    data: RouteCreateManyInput | RouteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Route createManyAndReturn
   */
  export type RouteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Routes.
     */
    data: RouteCreateManyInput | RouteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Route update
   */
  export type RouteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteInclude<ExtArgs> | null
    /**
     * The data needed to update a Route.
     */
    data: XOR<RouteUpdateInput, RouteUncheckedUpdateInput>
    /**
     * Choose, which Route to update.
     */
    where: RouteWhereUniqueInput
  }

  /**
   * Route updateMany
   */
  export type RouteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Routes.
     */
    data: XOR<RouteUpdateManyMutationInput, RouteUncheckedUpdateManyInput>
    /**
     * Filter which Routes to update
     */
    where?: RouteWhereInput
  }

  /**
   * Route upsert
   */
  export type RouteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteInclude<ExtArgs> | null
    /**
     * The filter to search for the Route to update in case it exists.
     */
    where: RouteWhereUniqueInput
    /**
     * In case the Route found by the `where` argument doesn't exist, create a new Route with this data.
     */
    create: XOR<RouteCreateInput, RouteUncheckedCreateInput>
    /**
     * In case the Route was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RouteUpdateInput, RouteUncheckedUpdateInput>
  }

  /**
   * Route delete
   */
  export type RouteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteInclude<ExtArgs> | null
    /**
     * Filter which Route to delete.
     */
    where: RouteWhereUniqueInput
  }

  /**
   * Route deleteMany
   */
  export type RouteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Routes to delete
     */
    where?: RouteWhereInput
  }

  /**
   * Route.routeStops
   */
  export type Route$routeStopsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteStop
     */
    select?: RouteStopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteStopInclude<ExtArgs> | null
    where?: RouteStopWhereInput
    orderBy?: RouteStopOrderByWithRelationInput | RouteStopOrderByWithRelationInput[]
    cursor?: RouteStopWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RouteStopScalarFieldEnum | RouteStopScalarFieldEnum[]
  }

  /**
   * Route.trips
   */
  export type Route$tripsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    where?: TripWhereInput
    orderBy?: TripOrderByWithRelationInput | TripOrderByWithRelationInput[]
    cursor?: TripWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TripScalarFieldEnum | TripScalarFieldEnum[]
  }

  /**
   * Route.TripDuty
   */
  export type Route$TripDutyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripDuty
     */
    select?: TripDutySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripDutyInclude<ExtArgs> | null
    where?: TripDutyWhereInput
    orderBy?: TripDutyOrderByWithRelationInput | TripDutyOrderByWithRelationInput[]
    cursor?: TripDutyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TripDutyScalarFieldEnum | TripDutyScalarFieldEnum[]
  }

  /**
   * Route without action
   */
  export type RouteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteInclude<ExtArgs> | null
  }


  /**
   * Model RouteStop
   */

  export type AggregateRouteStop = {
    _count: RouteStopCountAggregateOutputType | null
    _avg: RouteStopAvgAggregateOutputType | null
    _sum: RouteStopSumAggregateOutputType | null
    _min: RouteStopMinAggregateOutputType | null
    _max: RouteStopMaxAggregateOutputType | null
  }

  export type RouteStopAvgAggregateOutputType = {
    id: number | null
    routeId: number | null
    stopId: number | null
    stopOrder: number | null
    eta: number | null
    waitTime: number | null
  }

  export type RouteStopSumAggregateOutputType = {
    id: bigint | null
    routeId: bigint | null
    stopId: bigint | null
    stopOrder: number | null
    eta: number | null
    waitTime: number | null
  }

  export type RouteStopMinAggregateOutputType = {
    id: bigint | null
    routeId: bigint | null
    stopId: bigint | null
    stopOrder: number | null
    isActive: boolean | null
    path: string | null
    eta: number | null
    waitTime: number | null
  }

  export type RouteStopMaxAggregateOutputType = {
    id: bigint | null
    routeId: bigint | null
    stopId: bigint | null
    stopOrder: number | null
    isActive: boolean | null
    path: string | null
    eta: number | null
    waitTime: number | null
  }

  export type RouteStopCountAggregateOutputType = {
    id: number
    routeId: number
    stopId: number
    stopOrder: number
    isActive: number
    path: number
    eta: number
    waitTime: number
    _all: number
  }


  export type RouteStopAvgAggregateInputType = {
    id?: true
    routeId?: true
    stopId?: true
    stopOrder?: true
    eta?: true
    waitTime?: true
  }

  export type RouteStopSumAggregateInputType = {
    id?: true
    routeId?: true
    stopId?: true
    stopOrder?: true
    eta?: true
    waitTime?: true
  }

  export type RouteStopMinAggregateInputType = {
    id?: true
    routeId?: true
    stopId?: true
    stopOrder?: true
    isActive?: true
    path?: true
    eta?: true
    waitTime?: true
  }

  export type RouteStopMaxAggregateInputType = {
    id?: true
    routeId?: true
    stopId?: true
    stopOrder?: true
    isActive?: true
    path?: true
    eta?: true
    waitTime?: true
  }

  export type RouteStopCountAggregateInputType = {
    id?: true
    routeId?: true
    stopId?: true
    stopOrder?: true
    isActive?: true
    path?: true
    eta?: true
    waitTime?: true
    _all?: true
  }

  export type RouteStopAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RouteStop to aggregate.
     */
    where?: RouteStopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RouteStops to fetch.
     */
    orderBy?: RouteStopOrderByWithRelationInput | RouteStopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RouteStopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RouteStops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RouteStops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RouteStops
    **/
    _count?: true | RouteStopCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RouteStopAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RouteStopSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RouteStopMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RouteStopMaxAggregateInputType
  }

  export type GetRouteStopAggregateType<T extends RouteStopAggregateArgs> = {
        [P in keyof T & keyof AggregateRouteStop]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRouteStop[P]>
      : GetScalarType<T[P], AggregateRouteStop[P]>
  }




  export type RouteStopGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RouteStopWhereInput
    orderBy?: RouteStopOrderByWithAggregationInput | RouteStopOrderByWithAggregationInput[]
    by: RouteStopScalarFieldEnum[] | RouteStopScalarFieldEnum
    having?: RouteStopScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RouteStopCountAggregateInputType | true
    _avg?: RouteStopAvgAggregateInputType
    _sum?: RouteStopSumAggregateInputType
    _min?: RouteStopMinAggregateInputType
    _max?: RouteStopMaxAggregateInputType
  }

  export type RouteStopGroupByOutputType = {
    id: bigint
    routeId: bigint
    stopId: bigint
    stopOrder: number
    isActive: boolean
    path: string | null
    eta: number | null
    waitTime: number | null
    _count: RouteStopCountAggregateOutputType | null
    _avg: RouteStopAvgAggregateOutputType | null
    _sum: RouteStopSumAggregateOutputType | null
    _min: RouteStopMinAggregateOutputType | null
    _max: RouteStopMaxAggregateOutputType | null
  }

  type GetRouteStopGroupByPayload<T extends RouteStopGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RouteStopGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RouteStopGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RouteStopGroupByOutputType[P]>
            : GetScalarType<T[P], RouteStopGroupByOutputType[P]>
        }
      >
    >


  export type RouteStopSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    routeId?: boolean
    stopId?: boolean
    stopOrder?: boolean
    isActive?: boolean
    path?: boolean
    eta?: boolean
    waitTime?: boolean
    route?: boolean | RouteDefaultArgs<ExtArgs>
    stop?: boolean | StopDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["routeStop"]>

  export type RouteStopSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    routeId?: boolean
    stopId?: boolean
    stopOrder?: boolean
    isActive?: boolean
    path?: boolean
    eta?: boolean
    waitTime?: boolean
    route?: boolean | RouteDefaultArgs<ExtArgs>
    stop?: boolean | StopDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["routeStop"]>

  export type RouteStopSelectScalar = {
    id?: boolean
    routeId?: boolean
    stopId?: boolean
    stopOrder?: boolean
    isActive?: boolean
    path?: boolean
    eta?: boolean
    waitTime?: boolean
  }

  export type RouteStopInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    route?: boolean | RouteDefaultArgs<ExtArgs>
    stop?: boolean | StopDefaultArgs<ExtArgs>
  }
  export type RouteStopIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    route?: boolean | RouteDefaultArgs<ExtArgs>
    stop?: boolean | StopDefaultArgs<ExtArgs>
  }

  export type $RouteStopPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RouteStop"
    objects: {
      route: Prisma.$RoutePayload<ExtArgs>
      stop: Prisma.$StopPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      routeId: bigint
      stopId: bigint
      stopOrder: number
      isActive: boolean
      path: string | null
      eta: number | null
      waitTime: number | null
    }, ExtArgs["result"]["routeStop"]>
    composites: {}
  }

  type RouteStopGetPayload<S extends boolean | null | undefined | RouteStopDefaultArgs> = $Result.GetResult<Prisma.$RouteStopPayload, S>

  type RouteStopCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RouteStopFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RouteStopCountAggregateInputType | true
    }

  export interface RouteStopDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RouteStop'], meta: { name: 'RouteStop' } }
    /**
     * Find zero or one RouteStop that matches the filter.
     * @param {RouteStopFindUniqueArgs} args - Arguments to find a RouteStop
     * @example
     * // Get one RouteStop
     * const routeStop = await prisma.routeStop.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RouteStopFindUniqueArgs>(args: SelectSubset<T, RouteStopFindUniqueArgs<ExtArgs>>): Prisma__RouteStopClient<$Result.GetResult<Prisma.$RouteStopPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RouteStop that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RouteStopFindUniqueOrThrowArgs} args - Arguments to find a RouteStop
     * @example
     * // Get one RouteStop
     * const routeStop = await prisma.routeStop.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RouteStopFindUniqueOrThrowArgs>(args: SelectSubset<T, RouteStopFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RouteStopClient<$Result.GetResult<Prisma.$RouteStopPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RouteStop that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteStopFindFirstArgs} args - Arguments to find a RouteStop
     * @example
     * // Get one RouteStop
     * const routeStop = await prisma.routeStop.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RouteStopFindFirstArgs>(args?: SelectSubset<T, RouteStopFindFirstArgs<ExtArgs>>): Prisma__RouteStopClient<$Result.GetResult<Prisma.$RouteStopPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RouteStop that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteStopFindFirstOrThrowArgs} args - Arguments to find a RouteStop
     * @example
     * // Get one RouteStop
     * const routeStop = await prisma.routeStop.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RouteStopFindFirstOrThrowArgs>(args?: SelectSubset<T, RouteStopFindFirstOrThrowArgs<ExtArgs>>): Prisma__RouteStopClient<$Result.GetResult<Prisma.$RouteStopPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RouteStops that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteStopFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RouteStops
     * const routeStops = await prisma.routeStop.findMany()
     * 
     * // Get first 10 RouteStops
     * const routeStops = await prisma.routeStop.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const routeStopWithIdOnly = await prisma.routeStop.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RouteStopFindManyArgs>(args?: SelectSubset<T, RouteStopFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RouteStopPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RouteStop.
     * @param {RouteStopCreateArgs} args - Arguments to create a RouteStop.
     * @example
     * // Create one RouteStop
     * const RouteStop = await prisma.routeStop.create({
     *   data: {
     *     // ... data to create a RouteStop
     *   }
     * })
     * 
     */
    create<T extends RouteStopCreateArgs>(args: SelectSubset<T, RouteStopCreateArgs<ExtArgs>>): Prisma__RouteStopClient<$Result.GetResult<Prisma.$RouteStopPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RouteStops.
     * @param {RouteStopCreateManyArgs} args - Arguments to create many RouteStops.
     * @example
     * // Create many RouteStops
     * const routeStop = await prisma.routeStop.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RouteStopCreateManyArgs>(args?: SelectSubset<T, RouteStopCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RouteStops and returns the data saved in the database.
     * @param {RouteStopCreateManyAndReturnArgs} args - Arguments to create many RouteStops.
     * @example
     * // Create many RouteStops
     * const routeStop = await prisma.routeStop.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RouteStops and only return the `id`
     * const routeStopWithIdOnly = await prisma.routeStop.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RouteStopCreateManyAndReturnArgs>(args?: SelectSubset<T, RouteStopCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RouteStopPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RouteStop.
     * @param {RouteStopDeleteArgs} args - Arguments to delete one RouteStop.
     * @example
     * // Delete one RouteStop
     * const RouteStop = await prisma.routeStop.delete({
     *   where: {
     *     // ... filter to delete one RouteStop
     *   }
     * })
     * 
     */
    delete<T extends RouteStopDeleteArgs>(args: SelectSubset<T, RouteStopDeleteArgs<ExtArgs>>): Prisma__RouteStopClient<$Result.GetResult<Prisma.$RouteStopPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RouteStop.
     * @param {RouteStopUpdateArgs} args - Arguments to update one RouteStop.
     * @example
     * // Update one RouteStop
     * const routeStop = await prisma.routeStop.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RouteStopUpdateArgs>(args: SelectSubset<T, RouteStopUpdateArgs<ExtArgs>>): Prisma__RouteStopClient<$Result.GetResult<Prisma.$RouteStopPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RouteStops.
     * @param {RouteStopDeleteManyArgs} args - Arguments to filter RouteStops to delete.
     * @example
     * // Delete a few RouteStops
     * const { count } = await prisma.routeStop.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RouteStopDeleteManyArgs>(args?: SelectSubset<T, RouteStopDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RouteStops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteStopUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RouteStops
     * const routeStop = await prisma.routeStop.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RouteStopUpdateManyArgs>(args: SelectSubset<T, RouteStopUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RouteStop.
     * @param {RouteStopUpsertArgs} args - Arguments to update or create a RouteStop.
     * @example
     * // Update or create a RouteStop
     * const routeStop = await prisma.routeStop.upsert({
     *   create: {
     *     // ... data to create a RouteStop
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RouteStop we want to update
     *   }
     * })
     */
    upsert<T extends RouteStopUpsertArgs>(args: SelectSubset<T, RouteStopUpsertArgs<ExtArgs>>): Prisma__RouteStopClient<$Result.GetResult<Prisma.$RouteStopPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RouteStops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteStopCountArgs} args - Arguments to filter RouteStops to count.
     * @example
     * // Count the number of RouteStops
     * const count = await prisma.routeStop.count({
     *   where: {
     *     // ... the filter for the RouteStops we want to count
     *   }
     * })
    **/
    count<T extends RouteStopCountArgs>(
      args?: Subset<T, RouteStopCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RouteStopCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RouteStop.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteStopAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RouteStopAggregateArgs>(args: Subset<T, RouteStopAggregateArgs>): Prisma.PrismaPromise<GetRouteStopAggregateType<T>>

    /**
     * Group by RouteStop.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteStopGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RouteStopGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RouteStopGroupByArgs['orderBy'] }
        : { orderBy?: RouteStopGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RouteStopGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRouteStopGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RouteStop model
   */
  readonly fields: RouteStopFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RouteStop.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RouteStopClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    route<T extends RouteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RouteDefaultArgs<ExtArgs>>): Prisma__RouteClient<$Result.GetResult<Prisma.$RoutePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    stop<T extends StopDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StopDefaultArgs<ExtArgs>>): Prisma__StopClient<$Result.GetResult<Prisma.$StopPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RouteStop model
   */ 
  interface RouteStopFieldRefs {
    readonly id: FieldRef<"RouteStop", 'BigInt'>
    readonly routeId: FieldRef<"RouteStop", 'BigInt'>
    readonly stopId: FieldRef<"RouteStop", 'BigInt'>
    readonly stopOrder: FieldRef<"RouteStop", 'Int'>
    readonly isActive: FieldRef<"RouteStop", 'Boolean'>
    readonly path: FieldRef<"RouteStop", 'String'>
    readonly eta: FieldRef<"RouteStop", 'Int'>
    readonly waitTime: FieldRef<"RouteStop", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * RouteStop findUnique
   */
  export type RouteStopFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteStop
     */
    select?: RouteStopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteStopInclude<ExtArgs> | null
    /**
     * Filter, which RouteStop to fetch.
     */
    where: RouteStopWhereUniqueInput
  }

  /**
   * RouteStop findUniqueOrThrow
   */
  export type RouteStopFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteStop
     */
    select?: RouteStopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteStopInclude<ExtArgs> | null
    /**
     * Filter, which RouteStop to fetch.
     */
    where: RouteStopWhereUniqueInput
  }

  /**
   * RouteStop findFirst
   */
  export type RouteStopFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteStop
     */
    select?: RouteStopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteStopInclude<ExtArgs> | null
    /**
     * Filter, which RouteStop to fetch.
     */
    where?: RouteStopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RouteStops to fetch.
     */
    orderBy?: RouteStopOrderByWithRelationInput | RouteStopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RouteStops.
     */
    cursor?: RouteStopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RouteStops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RouteStops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RouteStops.
     */
    distinct?: RouteStopScalarFieldEnum | RouteStopScalarFieldEnum[]
  }

  /**
   * RouteStop findFirstOrThrow
   */
  export type RouteStopFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteStop
     */
    select?: RouteStopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteStopInclude<ExtArgs> | null
    /**
     * Filter, which RouteStop to fetch.
     */
    where?: RouteStopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RouteStops to fetch.
     */
    orderBy?: RouteStopOrderByWithRelationInput | RouteStopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RouteStops.
     */
    cursor?: RouteStopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RouteStops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RouteStops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RouteStops.
     */
    distinct?: RouteStopScalarFieldEnum | RouteStopScalarFieldEnum[]
  }

  /**
   * RouteStop findMany
   */
  export type RouteStopFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteStop
     */
    select?: RouteStopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteStopInclude<ExtArgs> | null
    /**
     * Filter, which RouteStops to fetch.
     */
    where?: RouteStopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RouteStops to fetch.
     */
    orderBy?: RouteStopOrderByWithRelationInput | RouteStopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RouteStops.
     */
    cursor?: RouteStopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RouteStops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RouteStops.
     */
    skip?: number
    distinct?: RouteStopScalarFieldEnum | RouteStopScalarFieldEnum[]
  }

  /**
   * RouteStop create
   */
  export type RouteStopCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteStop
     */
    select?: RouteStopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteStopInclude<ExtArgs> | null
    /**
     * The data needed to create a RouteStop.
     */
    data: XOR<RouteStopCreateInput, RouteStopUncheckedCreateInput>
  }

  /**
   * RouteStop createMany
   */
  export type RouteStopCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RouteStops.
     */
    data: RouteStopCreateManyInput | RouteStopCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RouteStop createManyAndReturn
   */
  export type RouteStopCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteStop
     */
    select?: RouteStopSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RouteStops.
     */
    data: RouteStopCreateManyInput | RouteStopCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteStopIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RouteStop update
   */
  export type RouteStopUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteStop
     */
    select?: RouteStopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteStopInclude<ExtArgs> | null
    /**
     * The data needed to update a RouteStop.
     */
    data: XOR<RouteStopUpdateInput, RouteStopUncheckedUpdateInput>
    /**
     * Choose, which RouteStop to update.
     */
    where: RouteStopWhereUniqueInput
  }

  /**
   * RouteStop updateMany
   */
  export type RouteStopUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RouteStops.
     */
    data: XOR<RouteStopUpdateManyMutationInput, RouteStopUncheckedUpdateManyInput>
    /**
     * Filter which RouteStops to update
     */
    where?: RouteStopWhereInput
  }

  /**
   * RouteStop upsert
   */
  export type RouteStopUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteStop
     */
    select?: RouteStopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteStopInclude<ExtArgs> | null
    /**
     * The filter to search for the RouteStop to update in case it exists.
     */
    where: RouteStopWhereUniqueInput
    /**
     * In case the RouteStop found by the `where` argument doesn't exist, create a new RouteStop with this data.
     */
    create: XOR<RouteStopCreateInput, RouteStopUncheckedCreateInput>
    /**
     * In case the RouteStop was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RouteStopUpdateInput, RouteStopUncheckedUpdateInput>
  }

  /**
   * RouteStop delete
   */
  export type RouteStopDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteStop
     */
    select?: RouteStopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteStopInclude<ExtArgs> | null
    /**
     * Filter which RouteStop to delete.
     */
    where: RouteStopWhereUniqueInput
  }

  /**
   * RouteStop deleteMany
   */
  export type RouteStopDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RouteStops to delete
     */
    where?: RouteStopWhereInput
  }

  /**
   * RouteStop without action
   */
  export type RouteStopDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteStop
     */
    select?: RouteStopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteStopInclude<ExtArgs> | null
  }


  /**
   * Model Trip
   */

  export type AggregateTrip = {
    _count: TripCountAggregateOutputType | null
    _avg: TripAvgAggregateOutputType | null
    _sum: TripSumAggregateOutputType | null
    _min: TripMinAggregateOutputType | null
    _max: TripMaxAggregateOutputType | null
  }

  export type TripAvgAggregateOutputType = {
    id: number | null
    routeId: number | null
    startLocation: number | null
    endLocation: number | null
    driverId: number | null
    vehicleId: number | null
    averageSpeed: Decimal | null
    maxSpeed: Decimal | null
    totalDistance: Decimal | null
    totalDuration: number | null
    idleTime: number | null
  }

  export type TripSumAggregateOutputType = {
    id: bigint | null
    routeId: bigint | null
    startLocation: bigint | null
    endLocation: bigint | null
    driverId: bigint | null
    vehicleId: bigint | null
    averageSpeed: Decimal | null
    maxSpeed: Decimal | null
    totalDistance: Decimal | null
    totalDuration: number | null
    idleTime: number | null
  }

  export type TripMinAggregateOutputType = {
    id: bigint | null
    routeId: bigint | null
    startTime: Date | null
    endTime: Date | null
    startLocation: bigint | null
    endLocation: bigint | null
    driverId: bigint | null
    vehicleId: bigint | null
    averageSpeed: Decimal | null
    maxSpeed: Decimal | null
    totalDistance: Decimal | null
    totalDuration: number | null
    idleTime: number | null
    path: string | null
  }

  export type TripMaxAggregateOutputType = {
    id: bigint | null
    routeId: bigint | null
    startTime: Date | null
    endTime: Date | null
    startLocation: bigint | null
    endLocation: bigint | null
    driverId: bigint | null
    vehicleId: bigint | null
    averageSpeed: Decimal | null
    maxSpeed: Decimal | null
    totalDistance: Decimal | null
    totalDuration: number | null
    idleTime: number | null
    path: string | null
  }

  export type TripCountAggregateOutputType = {
    id: number
    routeId: number
    startTime: number
    endTime: number
    startLocation: number
    endLocation: number
    driverId: number
    vehicleId: number
    averageSpeed: number
    maxSpeed: number
    totalDistance: number
    totalDuration: number
    idleTime: number
    path: number
    _all: number
  }


  export type TripAvgAggregateInputType = {
    id?: true
    routeId?: true
    startLocation?: true
    endLocation?: true
    driverId?: true
    vehicleId?: true
    averageSpeed?: true
    maxSpeed?: true
    totalDistance?: true
    totalDuration?: true
    idleTime?: true
  }

  export type TripSumAggregateInputType = {
    id?: true
    routeId?: true
    startLocation?: true
    endLocation?: true
    driverId?: true
    vehicleId?: true
    averageSpeed?: true
    maxSpeed?: true
    totalDistance?: true
    totalDuration?: true
    idleTime?: true
  }

  export type TripMinAggregateInputType = {
    id?: true
    routeId?: true
    startTime?: true
    endTime?: true
    startLocation?: true
    endLocation?: true
    driverId?: true
    vehicleId?: true
    averageSpeed?: true
    maxSpeed?: true
    totalDistance?: true
    totalDuration?: true
    idleTime?: true
    path?: true
  }

  export type TripMaxAggregateInputType = {
    id?: true
    routeId?: true
    startTime?: true
    endTime?: true
    startLocation?: true
    endLocation?: true
    driverId?: true
    vehicleId?: true
    averageSpeed?: true
    maxSpeed?: true
    totalDistance?: true
    totalDuration?: true
    idleTime?: true
    path?: true
  }

  export type TripCountAggregateInputType = {
    id?: true
    routeId?: true
    startTime?: true
    endTime?: true
    startLocation?: true
    endLocation?: true
    driverId?: true
    vehicleId?: true
    averageSpeed?: true
    maxSpeed?: true
    totalDistance?: true
    totalDuration?: true
    idleTime?: true
    path?: true
    _all?: true
  }

  export type TripAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Trip to aggregate.
     */
    where?: TripWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trips to fetch.
     */
    orderBy?: TripOrderByWithRelationInput | TripOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TripWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Trips
    **/
    _count?: true | TripCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TripAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TripSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TripMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TripMaxAggregateInputType
  }

  export type GetTripAggregateType<T extends TripAggregateArgs> = {
        [P in keyof T & keyof AggregateTrip]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrip[P]>
      : GetScalarType<T[P], AggregateTrip[P]>
  }




  export type TripGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TripWhereInput
    orderBy?: TripOrderByWithAggregationInput | TripOrderByWithAggregationInput[]
    by: TripScalarFieldEnum[] | TripScalarFieldEnum
    having?: TripScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TripCountAggregateInputType | true
    _avg?: TripAvgAggregateInputType
    _sum?: TripSumAggregateInputType
    _min?: TripMinAggregateInputType
    _max?: TripMaxAggregateInputType
  }

  export type TripGroupByOutputType = {
    id: bigint
    routeId: bigint
    startTime: Date
    endTime: Date | null
    startLocation: bigint
    endLocation: bigint | null
    driverId: bigint
    vehicleId: bigint
    averageSpeed: Decimal | null
    maxSpeed: Decimal | null
    totalDistance: Decimal | null
    totalDuration: number | null
    idleTime: number | null
    path: string | null
    _count: TripCountAggregateOutputType | null
    _avg: TripAvgAggregateOutputType | null
    _sum: TripSumAggregateOutputType | null
    _min: TripMinAggregateOutputType | null
    _max: TripMaxAggregateOutputType | null
  }

  type GetTripGroupByPayload<T extends TripGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TripGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TripGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TripGroupByOutputType[P]>
            : GetScalarType<T[P], TripGroupByOutputType[P]>
        }
      >
    >


  export type TripSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    routeId?: boolean
    startTime?: boolean
    endTime?: boolean
    startLocation?: boolean
    endLocation?: boolean
    driverId?: boolean
    vehicleId?: boolean
    averageSpeed?: boolean
    maxSpeed?: boolean
    totalDistance?: boolean
    totalDuration?: boolean
    idleTime?: boolean
    path?: boolean
    route?: boolean | RouteDefaultArgs<ExtArgs>
    driver?: boolean | DriverDefaultArgs<ExtArgs>
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
    tripStops?: boolean | Trip$tripStopsArgs<ExtArgs>
    _count?: boolean | TripCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trip"]>

  export type TripSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    routeId?: boolean
    startTime?: boolean
    endTime?: boolean
    startLocation?: boolean
    endLocation?: boolean
    driverId?: boolean
    vehicleId?: boolean
    averageSpeed?: boolean
    maxSpeed?: boolean
    totalDistance?: boolean
    totalDuration?: boolean
    idleTime?: boolean
    path?: boolean
    route?: boolean | RouteDefaultArgs<ExtArgs>
    driver?: boolean | DriverDefaultArgs<ExtArgs>
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trip"]>

  export type TripSelectScalar = {
    id?: boolean
    routeId?: boolean
    startTime?: boolean
    endTime?: boolean
    startLocation?: boolean
    endLocation?: boolean
    driverId?: boolean
    vehicleId?: boolean
    averageSpeed?: boolean
    maxSpeed?: boolean
    totalDistance?: boolean
    totalDuration?: boolean
    idleTime?: boolean
    path?: boolean
  }

  export type TripInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    route?: boolean | RouteDefaultArgs<ExtArgs>
    driver?: boolean | DriverDefaultArgs<ExtArgs>
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
    tripStops?: boolean | Trip$tripStopsArgs<ExtArgs>
    _count?: boolean | TripCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TripIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    route?: boolean | RouteDefaultArgs<ExtArgs>
    driver?: boolean | DriverDefaultArgs<ExtArgs>
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
  }

  export type $TripPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Trip"
    objects: {
      route: Prisma.$RoutePayload<ExtArgs>
      driver: Prisma.$DriverPayload<ExtArgs>
      vehicle: Prisma.$VehiclePayload<ExtArgs>
      tripStops: Prisma.$TripStopPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      routeId: bigint
      startTime: Date
      endTime: Date | null
      startLocation: bigint
      endLocation: bigint | null
      driverId: bigint
      vehicleId: bigint
      averageSpeed: Prisma.Decimal | null
      maxSpeed: Prisma.Decimal | null
      totalDistance: Prisma.Decimal | null
      totalDuration: number | null
      idleTime: number | null
      path: string | null
    }, ExtArgs["result"]["trip"]>
    composites: {}
  }

  type TripGetPayload<S extends boolean | null | undefined | TripDefaultArgs> = $Result.GetResult<Prisma.$TripPayload, S>

  type TripCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TripFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TripCountAggregateInputType | true
    }

  export interface TripDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Trip'], meta: { name: 'Trip' } }
    /**
     * Find zero or one Trip that matches the filter.
     * @param {TripFindUniqueArgs} args - Arguments to find a Trip
     * @example
     * // Get one Trip
     * const trip = await prisma.trip.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TripFindUniqueArgs>(args: SelectSubset<T, TripFindUniqueArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Trip that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TripFindUniqueOrThrowArgs} args - Arguments to find a Trip
     * @example
     * // Get one Trip
     * const trip = await prisma.trip.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TripFindUniqueOrThrowArgs>(args: SelectSubset<T, TripFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Trip that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripFindFirstArgs} args - Arguments to find a Trip
     * @example
     * // Get one Trip
     * const trip = await prisma.trip.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TripFindFirstArgs>(args?: SelectSubset<T, TripFindFirstArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Trip that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripFindFirstOrThrowArgs} args - Arguments to find a Trip
     * @example
     * // Get one Trip
     * const trip = await prisma.trip.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TripFindFirstOrThrowArgs>(args?: SelectSubset<T, TripFindFirstOrThrowArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Trips that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Trips
     * const trips = await prisma.trip.findMany()
     * 
     * // Get first 10 Trips
     * const trips = await prisma.trip.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tripWithIdOnly = await prisma.trip.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TripFindManyArgs>(args?: SelectSubset<T, TripFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Trip.
     * @param {TripCreateArgs} args - Arguments to create a Trip.
     * @example
     * // Create one Trip
     * const Trip = await prisma.trip.create({
     *   data: {
     *     // ... data to create a Trip
     *   }
     * })
     * 
     */
    create<T extends TripCreateArgs>(args: SelectSubset<T, TripCreateArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Trips.
     * @param {TripCreateManyArgs} args - Arguments to create many Trips.
     * @example
     * // Create many Trips
     * const trip = await prisma.trip.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TripCreateManyArgs>(args?: SelectSubset<T, TripCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Trips and returns the data saved in the database.
     * @param {TripCreateManyAndReturnArgs} args - Arguments to create many Trips.
     * @example
     * // Create many Trips
     * const trip = await prisma.trip.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Trips and only return the `id`
     * const tripWithIdOnly = await prisma.trip.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TripCreateManyAndReturnArgs>(args?: SelectSubset<T, TripCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Trip.
     * @param {TripDeleteArgs} args - Arguments to delete one Trip.
     * @example
     * // Delete one Trip
     * const Trip = await prisma.trip.delete({
     *   where: {
     *     // ... filter to delete one Trip
     *   }
     * })
     * 
     */
    delete<T extends TripDeleteArgs>(args: SelectSubset<T, TripDeleteArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Trip.
     * @param {TripUpdateArgs} args - Arguments to update one Trip.
     * @example
     * // Update one Trip
     * const trip = await prisma.trip.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TripUpdateArgs>(args: SelectSubset<T, TripUpdateArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Trips.
     * @param {TripDeleteManyArgs} args - Arguments to filter Trips to delete.
     * @example
     * // Delete a few Trips
     * const { count } = await prisma.trip.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TripDeleteManyArgs>(args?: SelectSubset<T, TripDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Trips.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Trips
     * const trip = await prisma.trip.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TripUpdateManyArgs>(args: SelectSubset<T, TripUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Trip.
     * @param {TripUpsertArgs} args - Arguments to update or create a Trip.
     * @example
     * // Update or create a Trip
     * const trip = await prisma.trip.upsert({
     *   create: {
     *     // ... data to create a Trip
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Trip we want to update
     *   }
     * })
     */
    upsert<T extends TripUpsertArgs>(args: SelectSubset<T, TripUpsertArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Trips.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripCountArgs} args - Arguments to filter Trips to count.
     * @example
     * // Count the number of Trips
     * const count = await prisma.trip.count({
     *   where: {
     *     // ... the filter for the Trips we want to count
     *   }
     * })
    **/
    count<T extends TripCountArgs>(
      args?: Subset<T, TripCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TripCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Trip.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TripAggregateArgs>(args: Subset<T, TripAggregateArgs>): Prisma.PrismaPromise<GetTripAggregateType<T>>

    /**
     * Group by Trip.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TripGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TripGroupByArgs['orderBy'] }
        : { orderBy?: TripGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TripGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTripGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Trip model
   */
  readonly fields: TripFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Trip.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TripClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    route<T extends RouteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RouteDefaultArgs<ExtArgs>>): Prisma__RouteClient<$Result.GetResult<Prisma.$RoutePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    driver<T extends DriverDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DriverDefaultArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    vehicle<T extends VehicleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VehicleDefaultArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    tripStops<T extends Trip$tripStopsArgs<ExtArgs> = {}>(args?: Subset<T, Trip$tripStopsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripStopPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Trip model
   */ 
  interface TripFieldRefs {
    readonly id: FieldRef<"Trip", 'BigInt'>
    readonly routeId: FieldRef<"Trip", 'BigInt'>
    readonly startTime: FieldRef<"Trip", 'DateTime'>
    readonly endTime: FieldRef<"Trip", 'DateTime'>
    readonly startLocation: FieldRef<"Trip", 'BigInt'>
    readonly endLocation: FieldRef<"Trip", 'BigInt'>
    readonly driverId: FieldRef<"Trip", 'BigInt'>
    readonly vehicleId: FieldRef<"Trip", 'BigInt'>
    readonly averageSpeed: FieldRef<"Trip", 'Decimal'>
    readonly maxSpeed: FieldRef<"Trip", 'Decimal'>
    readonly totalDistance: FieldRef<"Trip", 'Decimal'>
    readonly totalDuration: FieldRef<"Trip", 'Int'>
    readonly idleTime: FieldRef<"Trip", 'Int'>
    readonly path: FieldRef<"Trip", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Trip findUnique
   */
  export type TripFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    /**
     * Filter, which Trip to fetch.
     */
    where: TripWhereUniqueInput
  }

  /**
   * Trip findUniqueOrThrow
   */
  export type TripFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    /**
     * Filter, which Trip to fetch.
     */
    where: TripWhereUniqueInput
  }

  /**
   * Trip findFirst
   */
  export type TripFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    /**
     * Filter, which Trip to fetch.
     */
    where?: TripWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trips to fetch.
     */
    orderBy?: TripOrderByWithRelationInput | TripOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Trips.
     */
    cursor?: TripWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Trips.
     */
    distinct?: TripScalarFieldEnum | TripScalarFieldEnum[]
  }

  /**
   * Trip findFirstOrThrow
   */
  export type TripFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    /**
     * Filter, which Trip to fetch.
     */
    where?: TripWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trips to fetch.
     */
    orderBy?: TripOrderByWithRelationInput | TripOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Trips.
     */
    cursor?: TripWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Trips.
     */
    distinct?: TripScalarFieldEnum | TripScalarFieldEnum[]
  }

  /**
   * Trip findMany
   */
  export type TripFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    /**
     * Filter, which Trips to fetch.
     */
    where?: TripWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trips to fetch.
     */
    orderBy?: TripOrderByWithRelationInput | TripOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Trips.
     */
    cursor?: TripWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trips.
     */
    skip?: number
    distinct?: TripScalarFieldEnum | TripScalarFieldEnum[]
  }

  /**
   * Trip create
   */
  export type TripCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    /**
     * The data needed to create a Trip.
     */
    data: XOR<TripCreateInput, TripUncheckedCreateInput>
  }

  /**
   * Trip createMany
   */
  export type TripCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Trips.
     */
    data: TripCreateManyInput | TripCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Trip createManyAndReturn
   */
  export type TripCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Trips.
     */
    data: TripCreateManyInput | TripCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Trip update
   */
  export type TripUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    /**
     * The data needed to update a Trip.
     */
    data: XOR<TripUpdateInput, TripUncheckedUpdateInput>
    /**
     * Choose, which Trip to update.
     */
    where: TripWhereUniqueInput
  }

  /**
   * Trip updateMany
   */
  export type TripUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Trips.
     */
    data: XOR<TripUpdateManyMutationInput, TripUncheckedUpdateManyInput>
    /**
     * Filter which Trips to update
     */
    where?: TripWhereInput
  }

  /**
   * Trip upsert
   */
  export type TripUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    /**
     * The filter to search for the Trip to update in case it exists.
     */
    where: TripWhereUniqueInput
    /**
     * In case the Trip found by the `where` argument doesn't exist, create a new Trip with this data.
     */
    create: XOR<TripCreateInput, TripUncheckedCreateInput>
    /**
     * In case the Trip was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TripUpdateInput, TripUncheckedUpdateInput>
  }

  /**
   * Trip delete
   */
  export type TripDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    /**
     * Filter which Trip to delete.
     */
    where: TripWhereUniqueInput
  }

  /**
   * Trip deleteMany
   */
  export type TripDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Trips to delete
     */
    where?: TripWhereInput
  }

  /**
   * Trip.tripStops
   */
  export type Trip$tripStopsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripStop
     */
    select?: TripStopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripStopInclude<ExtArgs> | null
    where?: TripStopWhereInput
    orderBy?: TripStopOrderByWithRelationInput | TripStopOrderByWithRelationInput[]
    cursor?: TripStopWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TripStopScalarFieldEnum | TripStopScalarFieldEnum[]
  }

  /**
   * Trip without action
   */
  export type TripDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
  }


  /**
   * Model TripStop
   */

  export type AggregateTripStop = {
    _count: TripStopCountAggregateOutputType | null
    _avg: TripStopAvgAggregateOutputType | null
    _sum: TripStopSumAggregateOutputType | null
    _min: TripStopMinAggregateOutputType | null
    _max: TripStopMaxAggregateOutputType | null
  }

  export type TripStopAvgAggregateOutputType = {
    id: number | null
    tripId: number | null
    stopId: number | null
    stopOrder: number | null
    eta: number | null
  }

  export type TripStopSumAggregateOutputType = {
    id: bigint | null
    tripId: bigint | null
    stopId: bigint | null
    stopOrder: number | null
    eta: number | null
  }

  export type TripStopMinAggregateOutputType = {
    id: bigint | null
    tripId: bigint | null
    stopId: bigint | null
    stopOrder: number | null
    arrivalTime: Date | null
    departureTime: Date | null
    eta: number | null
  }

  export type TripStopMaxAggregateOutputType = {
    id: bigint | null
    tripId: bigint | null
    stopId: bigint | null
    stopOrder: number | null
    arrivalTime: Date | null
    departureTime: Date | null
    eta: number | null
  }

  export type TripStopCountAggregateOutputType = {
    id: number
    tripId: number
    stopId: number
    stopOrder: number
    arrivalTime: number
    departureTime: number
    eta: number
    _all: number
  }


  export type TripStopAvgAggregateInputType = {
    id?: true
    tripId?: true
    stopId?: true
    stopOrder?: true
    eta?: true
  }

  export type TripStopSumAggregateInputType = {
    id?: true
    tripId?: true
    stopId?: true
    stopOrder?: true
    eta?: true
  }

  export type TripStopMinAggregateInputType = {
    id?: true
    tripId?: true
    stopId?: true
    stopOrder?: true
    arrivalTime?: true
    departureTime?: true
    eta?: true
  }

  export type TripStopMaxAggregateInputType = {
    id?: true
    tripId?: true
    stopId?: true
    stopOrder?: true
    arrivalTime?: true
    departureTime?: true
    eta?: true
  }

  export type TripStopCountAggregateInputType = {
    id?: true
    tripId?: true
    stopId?: true
    stopOrder?: true
    arrivalTime?: true
    departureTime?: true
    eta?: true
    _all?: true
  }

  export type TripStopAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TripStop to aggregate.
     */
    where?: TripStopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TripStops to fetch.
     */
    orderBy?: TripStopOrderByWithRelationInput | TripStopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TripStopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TripStops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TripStops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TripStops
    **/
    _count?: true | TripStopCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TripStopAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TripStopSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TripStopMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TripStopMaxAggregateInputType
  }

  export type GetTripStopAggregateType<T extends TripStopAggregateArgs> = {
        [P in keyof T & keyof AggregateTripStop]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTripStop[P]>
      : GetScalarType<T[P], AggregateTripStop[P]>
  }




  export type TripStopGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TripStopWhereInput
    orderBy?: TripStopOrderByWithAggregationInput | TripStopOrderByWithAggregationInput[]
    by: TripStopScalarFieldEnum[] | TripStopScalarFieldEnum
    having?: TripStopScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TripStopCountAggregateInputType | true
    _avg?: TripStopAvgAggregateInputType
    _sum?: TripStopSumAggregateInputType
    _min?: TripStopMinAggregateInputType
    _max?: TripStopMaxAggregateInputType
  }

  export type TripStopGroupByOutputType = {
    id: bigint
    tripId: bigint
    stopId: bigint
    stopOrder: number
    arrivalTime: Date | null
    departureTime: Date | null
    eta: number | null
    _count: TripStopCountAggregateOutputType | null
    _avg: TripStopAvgAggregateOutputType | null
    _sum: TripStopSumAggregateOutputType | null
    _min: TripStopMinAggregateOutputType | null
    _max: TripStopMaxAggregateOutputType | null
  }

  type GetTripStopGroupByPayload<T extends TripStopGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TripStopGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TripStopGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TripStopGroupByOutputType[P]>
            : GetScalarType<T[P], TripStopGroupByOutputType[P]>
        }
      >
    >


  export type TripStopSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tripId?: boolean
    stopId?: boolean
    stopOrder?: boolean
    arrivalTime?: boolean
    departureTime?: boolean
    eta?: boolean
    trip?: boolean | TripDefaultArgs<ExtArgs>
    stop?: boolean | StopDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tripStop"]>

  export type TripStopSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tripId?: boolean
    stopId?: boolean
    stopOrder?: boolean
    arrivalTime?: boolean
    departureTime?: boolean
    eta?: boolean
    trip?: boolean | TripDefaultArgs<ExtArgs>
    stop?: boolean | StopDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tripStop"]>

  export type TripStopSelectScalar = {
    id?: boolean
    tripId?: boolean
    stopId?: boolean
    stopOrder?: boolean
    arrivalTime?: boolean
    departureTime?: boolean
    eta?: boolean
  }

  export type TripStopInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trip?: boolean | TripDefaultArgs<ExtArgs>
    stop?: boolean | StopDefaultArgs<ExtArgs>
  }
  export type TripStopIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trip?: boolean | TripDefaultArgs<ExtArgs>
    stop?: boolean | StopDefaultArgs<ExtArgs>
  }

  export type $TripStopPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TripStop"
    objects: {
      trip: Prisma.$TripPayload<ExtArgs>
      stop: Prisma.$StopPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      tripId: bigint
      stopId: bigint
      stopOrder: number
      arrivalTime: Date | null
      departureTime: Date | null
      eta: number | null
    }, ExtArgs["result"]["tripStop"]>
    composites: {}
  }

  type TripStopGetPayload<S extends boolean | null | undefined | TripStopDefaultArgs> = $Result.GetResult<Prisma.$TripStopPayload, S>

  type TripStopCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TripStopFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TripStopCountAggregateInputType | true
    }

  export interface TripStopDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TripStop'], meta: { name: 'TripStop' } }
    /**
     * Find zero or one TripStop that matches the filter.
     * @param {TripStopFindUniqueArgs} args - Arguments to find a TripStop
     * @example
     * // Get one TripStop
     * const tripStop = await prisma.tripStop.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TripStopFindUniqueArgs>(args: SelectSubset<T, TripStopFindUniqueArgs<ExtArgs>>): Prisma__TripStopClient<$Result.GetResult<Prisma.$TripStopPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TripStop that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TripStopFindUniqueOrThrowArgs} args - Arguments to find a TripStop
     * @example
     * // Get one TripStop
     * const tripStop = await prisma.tripStop.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TripStopFindUniqueOrThrowArgs>(args: SelectSubset<T, TripStopFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TripStopClient<$Result.GetResult<Prisma.$TripStopPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TripStop that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripStopFindFirstArgs} args - Arguments to find a TripStop
     * @example
     * // Get one TripStop
     * const tripStop = await prisma.tripStop.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TripStopFindFirstArgs>(args?: SelectSubset<T, TripStopFindFirstArgs<ExtArgs>>): Prisma__TripStopClient<$Result.GetResult<Prisma.$TripStopPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TripStop that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripStopFindFirstOrThrowArgs} args - Arguments to find a TripStop
     * @example
     * // Get one TripStop
     * const tripStop = await prisma.tripStop.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TripStopFindFirstOrThrowArgs>(args?: SelectSubset<T, TripStopFindFirstOrThrowArgs<ExtArgs>>): Prisma__TripStopClient<$Result.GetResult<Prisma.$TripStopPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TripStops that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripStopFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TripStops
     * const tripStops = await prisma.tripStop.findMany()
     * 
     * // Get first 10 TripStops
     * const tripStops = await prisma.tripStop.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tripStopWithIdOnly = await prisma.tripStop.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TripStopFindManyArgs>(args?: SelectSubset<T, TripStopFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripStopPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TripStop.
     * @param {TripStopCreateArgs} args - Arguments to create a TripStop.
     * @example
     * // Create one TripStop
     * const TripStop = await prisma.tripStop.create({
     *   data: {
     *     // ... data to create a TripStop
     *   }
     * })
     * 
     */
    create<T extends TripStopCreateArgs>(args: SelectSubset<T, TripStopCreateArgs<ExtArgs>>): Prisma__TripStopClient<$Result.GetResult<Prisma.$TripStopPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TripStops.
     * @param {TripStopCreateManyArgs} args - Arguments to create many TripStops.
     * @example
     * // Create many TripStops
     * const tripStop = await prisma.tripStop.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TripStopCreateManyArgs>(args?: SelectSubset<T, TripStopCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TripStops and returns the data saved in the database.
     * @param {TripStopCreateManyAndReturnArgs} args - Arguments to create many TripStops.
     * @example
     * // Create many TripStops
     * const tripStop = await prisma.tripStop.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TripStops and only return the `id`
     * const tripStopWithIdOnly = await prisma.tripStop.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TripStopCreateManyAndReturnArgs>(args?: SelectSubset<T, TripStopCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripStopPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TripStop.
     * @param {TripStopDeleteArgs} args - Arguments to delete one TripStop.
     * @example
     * // Delete one TripStop
     * const TripStop = await prisma.tripStop.delete({
     *   where: {
     *     // ... filter to delete one TripStop
     *   }
     * })
     * 
     */
    delete<T extends TripStopDeleteArgs>(args: SelectSubset<T, TripStopDeleteArgs<ExtArgs>>): Prisma__TripStopClient<$Result.GetResult<Prisma.$TripStopPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TripStop.
     * @param {TripStopUpdateArgs} args - Arguments to update one TripStop.
     * @example
     * // Update one TripStop
     * const tripStop = await prisma.tripStop.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TripStopUpdateArgs>(args: SelectSubset<T, TripStopUpdateArgs<ExtArgs>>): Prisma__TripStopClient<$Result.GetResult<Prisma.$TripStopPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TripStops.
     * @param {TripStopDeleteManyArgs} args - Arguments to filter TripStops to delete.
     * @example
     * // Delete a few TripStops
     * const { count } = await prisma.tripStop.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TripStopDeleteManyArgs>(args?: SelectSubset<T, TripStopDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TripStops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripStopUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TripStops
     * const tripStop = await prisma.tripStop.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TripStopUpdateManyArgs>(args: SelectSubset<T, TripStopUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TripStop.
     * @param {TripStopUpsertArgs} args - Arguments to update or create a TripStop.
     * @example
     * // Update or create a TripStop
     * const tripStop = await prisma.tripStop.upsert({
     *   create: {
     *     // ... data to create a TripStop
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TripStop we want to update
     *   }
     * })
     */
    upsert<T extends TripStopUpsertArgs>(args: SelectSubset<T, TripStopUpsertArgs<ExtArgs>>): Prisma__TripStopClient<$Result.GetResult<Prisma.$TripStopPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TripStops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripStopCountArgs} args - Arguments to filter TripStops to count.
     * @example
     * // Count the number of TripStops
     * const count = await prisma.tripStop.count({
     *   where: {
     *     // ... the filter for the TripStops we want to count
     *   }
     * })
    **/
    count<T extends TripStopCountArgs>(
      args?: Subset<T, TripStopCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TripStopCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TripStop.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripStopAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TripStopAggregateArgs>(args: Subset<T, TripStopAggregateArgs>): Prisma.PrismaPromise<GetTripStopAggregateType<T>>

    /**
     * Group by TripStop.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripStopGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TripStopGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TripStopGroupByArgs['orderBy'] }
        : { orderBy?: TripStopGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TripStopGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTripStopGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TripStop model
   */
  readonly fields: TripStopFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TripStop.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TripStopClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    trip<T extends TripDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TripDefaultArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    stop<T extends StopDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StopDefaultArgs<ExtArgs>>): Prisma__StopClient<$Result.GetResult<Prisma.$StopPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TripStop model
   */ 
  interface TripStopFieldRefs {
    readonly id: FieldRef<"TripStop", 'BigInt'>
    readonly tripId: FieldRef<"TripStop", 'BigInt'>
    readonly stopId: FieldRef<"TripStop", 'BigInt'>
    readonly stopOrder: FieldRef<"TripStop", 'Int'>
    readonly arrivalTime: FieldRef<"TripStop", 'DateTime'>
    readonly departureTime: FieldRef<"TripStop", 'DateTime'>
    readonly eta: FieldRef<"TripStop", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * TripStop findUnique
   */
  export type TripStopFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripStop
     */
    select?: TripStopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripStopInclude<ExtArgs> | null
    /**
     * Filter, which TripStop to fetch.
     */
    where: TripStopWhereUniqueInput
  }

  /**
   * TripStop findUniqueOrThrow
   */
  export type TripStopFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripStop
     */
    select?: TripStopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripStopInclude<ExtArgs> | null
    /**
     * Filter, which TripStop to fetch.
     */
    where: TripStopWhereUniqueInput
  }

  /**
   * TripStop findFirst
   */
  export type TripStopFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripStop
     */
    select?: TripStopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripStopInclude<ExtArgs> | null
    /**
     * Filter, which TripStop to fetch.
     */
    where?: TripStopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TripStops to fetch.
     */
    orderBy?: TripStopOrderByWithRelationInput | TripStopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TripStops.
     */
    cursor?: TripStopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TripStops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TripStops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TripStops.
     */
    distinct?: TripStopScalarFieldEnum | TripStopScalarFieldEnum[]
  }

  /**
   * TripStop findFirstOrThrow
   */
  export type TripStopFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripStop
     */
    select?: TripStopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripStopInclude<ExtArgs> | null
    /**
     * Filter, which TripStop to fetch.
     */
    where?: TripStopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TripStops to fetch.
     */
    orderBy?: TripStopOrderByWithRelationInput | TripStopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TripStops.
     */
    cursor?: TripStopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TripStops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TripStops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TripStops.
     */
    distinct?: TripStopScalarFieldEnum | TripStopScalarFieldEnum[]
  }

  /**
   * TripStop findMany
   */
  export type TripStopFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripStop
     */
    select?: TripStopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripStopInclude<ExtArgs> | null
    /**
     * Filter, which TripStops to fetch.
     */
    where?: TripStopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TripStops to fetch.
     */
    orderBy?: TripStopOrderByWithRelationInput | TripStopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TripStops.
     */
    cursor?: TripStopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TripStops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TripStops.
     */
    skip?: number
    distinct?: TripStopScalarFieldEnum | TripStopScalarFieldEnum[]
  }

  /**
   * TripStop create
   */
  export type TripStopCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripStop
     */
    select?: TripStopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripStopInclude<ExtArgs> | null
    /**
     * The data needed to create a TripStop.
     */
    data: XOR<TripStopCreateInput, TripStopUncheckedCreateInput>
  }

  /**
   * TripStop createMany
   */
  export type TripStopCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TripStops.
     */
    data: TripStopCreateManyInput | TripStopCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TripStop createManyAndReturn
   */
  export type TripStopCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripStop
     */
    select?: TripStopSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TripStops.
     */
    data: TripStopCreateManyInput | TripStopCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripStopIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TripStop update
   */
  export type TripStopUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripStop
     */
    select?: TripStopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripStopInclude<ExtArgs> | null
    /**
     * The data needed to update a TripStop.
     */
    data: XOR<TripStopUpdateInput, TripStopUncheckedUpdateInput>
    /**
     * Choose, which TripStop to update.
     */
    where: TripStopWhereUniqueInput
  }

  /**
   * TripStop updateMany
   */
  export type TripStopUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TripStops.
     */
    data: XOR<TripStopUpdateManyMutationInput, TripStopUncheckedUpdateManyInput>
    /**
     * Filter which TripStops to update
     */
    where?: TripStopWhereInput
  }

  /**
   * TripStop upsert
   */
  export type TripStopUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripStop
     */
    select?: TripStopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripStopInclude<ExtArgs> | null
    /**
     * The filter to search for the TripStop to update in case it exists.
     */
    where: TripStopWhereUniqueInput
    /**
     * In case the TripStop found by the `where` argument doesn't exist, create a new TripStop with this data.
     */
    create: XOR<TripStopCreateInput, TripStopUncheckedCreateInput>
    /**
     * In case the TripStop was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TripStopUpdateInput, TripStopUncheckedUpdateInput>
  }

  /**
   * TripStop delete
   */
  export type TripStopDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripStop
     */
    select?: TripStopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripStopInclude<ExtArgs> | null
    /**
     * Filter which TripStop to delete.
     */
    where: TripStopWhereUniqueInput
  }

  /**
   * TripStop deleteMany
   */
  export type TripStopDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TripStops to delete
     */
    where?: TripStopWhereInput
  }

  /**
   * TripStop without action
   */
  export type TripStopDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripStop
     */
    select?: TripStopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripStopInclude<ExtArgs> | null
  }


  /**
   * Model VehicleTelemetry
   */

  export type AggregateVehicleTelemetry = {
    _count: VehicleTelemetryCountAggregateOutputType | null
    _avg: VehicleTelemetryAvgAggregateOutputType | null
    _sum: VehicleTelemetrySumAggregateOutputType | null
    _min: VehicleTelemetryMinAggregateOutputType | null
    _max: VehicleTelemetryMaxAggregateOutputType | null
  }

  export type VehicleTelemetryAvgAggregateOutputType = {
    id: number | null
    lat: Decimal | null
    lon: Decimal | null
    speed: Decimal | null
    vehicleId: number | null
  }

  export type VehicleTelemetrySumAggregateOutputType = {
    id: bigint | null
    lat: Decimal | null
    lon: Decimal | null
    speed: Decimal | null
    vehicleId: bigint | null
  }

  export type VehicleTelemetryMinAggregateOutputType = {
    id: bigint | null
    lat: Decimal | null
    lon: Decimal | null
    speed: Decimal | null
    ignition: boolean | null
    trackedOn: Date | null
    vehicleId: bigint | null
  }

  export type VehicleTelemetryMaxAggregateOutputType = {
    id: bigint | null
    lat: Decimal | null
    lon: Decimal | null
    speed: Decimal | null
    ignition: boolean | null
    trackedOn: Date | null
    vehicleId: bigint | null
  }

  export type VehicleTelemetryCountAggregateOutputType = {
    id: number
    lat: number
    lon: number
    speed: number
    ignition: number
    trackedOn: number
    vehicleId: number
    _all: number
  }


  export type VehicleTelemetryAvgAggregateInputType = {
    id?: true
    lat?: true
    lon?: true
    speed?: true
    vehicleId?: true
  }

  export type VehicleTelemetrySumAggregateInputType = {
    id?: true
    lat?: true
    lon?: true
    speed?: true
    vehicleId?: true
  }

  export type VehicleTelemetryMinAggregateInputType = {
    id?: true
    lat?: true
    lon?: true
    speed?: true
    ignition?: true
    trackedOn?: true
    vehicleId?: true
  }

  export type VehicleTelemetryMaxAggregateInputType = {
    id?: true
    lat?: true
    lon?: true
    speed?: true
    ignition?: true
    trackedOn?: true
    vehicleId?: true
  }

  export type VehicleTelemetryCountAggregateInputType = {
    id?: true
    lat?: true
    lon?: true
    speed?: true
    ignition?: true
    trackedOn?: true
    vehicleId?: true
    _all?: true
  }

  export type VehicleTelemetryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VehicleTelemetry to aggregate.
     */
    where?: VehicleTelemetryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleTelemetries to fetch.
     */
    orderBy?: VehicleTelemetryOrderByWithRelationInput | VehicleTelemetryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VehicleTelemetryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleTelemetries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleTelemetries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VehicleTelemetries
    **/
    _count?: true | VehicleTelemetryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VehicleTelemetryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VehicleTelemetrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VehicleTelemetryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VehicleTelemetryMaxAggregateInputType
  }

  export type GetVehicleTelemetryAggregateType<T extends VehicleTelemetryAggregateArgs> = {
        [P in keyof T & keyof AggregateVehicleTelemetry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVehicleTelemetry[P]>
      : GetScalarType<T[P], AggregateVehicleTelemetry[P]>
  }




  export type VehicleTelemetryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VehicleTelemetryWhereInput
    orderBy?: VehicleTelemetryOrderByWithAggregationInput | VehicleTelemetryOrderByWithAggregationInput[]
    by: VehicleTelemetryScalarFieldEnum[] | VehicleTelemetryScalarFieldEnum
    having?: VehicleTelemetryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VehicleTelemetryCountAggregateInputType | true
    _avg?: VehicleTelemetryAvgAggregateInputType
    _sum?: VehicleTelemetrySumAggregateInputType
    _min?: VehicleTelemetryMinAggregateInputType
    _max?: VehicleTelemetryMaxAggregateInputType
  }

  export type VehicleTelemetryGroupByOutputType = {
    id: bigint
    lat: Decimal
    lon: Decimal
    speed: Decimal | null
    ignition: boolean
    trackedOn: Date
    vehicleId: bigint
    _count: VehicleTelemetryCountAggregateOutputType | null
    _avg: VehicleTelemetryAvgAggregateOutputType | null
    _sum: VehicleTelemetrySumAggregateOutputType | null
    _min: VehicleTelemetryMinAggregateOutputType | null
    _max: VehicleTelemetryMaxAggregateOutputType | null
  }

  type GetVehicleTelemetryGroupByPayload<T extends VehicleTelemetryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VehicleTelemetryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VehicleTelemetryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VehicleTelemetryGroupByOutputType[P]>
            : GetScalarType<T[P], VehicleTelemetryGroupByOutputType[P]>
        }
      >
    >


  export type VehicleTelemetrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lat?: boolean
    lon?: boolean
    speed?: boolean
    ignition?: boolean
    trackedOn?: boolean
    vehicleId?: boolean
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicleTelemetry"]>

  export type VehicleTelemetrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lat?: boolean
    lon?: boolean
    speed?: boolean
    ignition?: boolean
    trackedOn?: boolean
    vehicleId?: boolean
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicleTelemetry"]>

  export type VehicleTelemetrySelectScalar = {
    id?: boolean
    lat?: boolean
    lon?: boolean
    speed?: boolean
    ignition?: boolean
    trackedOn?: boolean
    vehicleId?: boolean
  }

  export type VehicleTelemetryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
  }
  export type VehicleTelemetryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
  }

  export type $VehicleTelemetryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VehicleTelemetry"
    objects: {
      vehicle: Prisma.$VehiclePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      lat: Prisma.Decimal
      lon: Prisma.Decimal
      speed: Prisma.Decimal | null
      ignition: boolean
      trackedOn: Date
      vehicleId: bigint
    }, ExtArgs["result"]["vehicleTelemetry"]>
    composites: {}
  }

  type VehicleTelemetryGetPayload<S extends boolean | null | undefined | VehicleTelemetryDefaultArgs> = $Result.GetResult<Prisma.$VehicleTelemetryPayload, S>

  type VehicleTelemetryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VehicleTelemetryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VehicleTelemetryCountAggregateInputType | true
    }

  export interface VehicleTelemetryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VehicleTelemetry'], meta: { name: 'VehicleTelemetry' } }
    /**
     * Find zero or one VehicleTelemetry that matches the filter.
     * @param {VehicleTelemetryFindUniqueArgs} args - Arguments to find a VehicleTelemetry
     * @example
     * // Get one VehicleTelemetry
     * const vehicleTelemetry = await prisma.vehicleTelemetry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VehicleTelemetryFindUniqueArgs>(args: SelectSubset<T, VehicleTelemetryFindUniqueArgs<ExtArgs>>): Prisma__VehicleTelemetryClient<$Result.GetResult<Prisma.$VehicleTelemetryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one VehicleTelemetry that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VehicleTelemetryFindUniqueOrThrowArgs} args - Arguments to find a VehicleTelemetry
     * @example
     * // Get one VehicleTelemetry
     * const vehicleTelemetry = await prisma.vehicleTelemetry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VehicleTelemetryFindUniqueOrThrowArgs>(args: SelectSubset<T, VehicleTelemetryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VehicleTelemetryClient<$Result.GetResult<Prisma.$VehicleTelemetryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first VehicleTelemetry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleTelemetryFindFirstArgs} args - Arguments to find a VehicleTelemetry
     * @example
     * // Get one VehicleTelemetry
     * const vehicleTelemetry = await prisma.vehicleTelemetry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VehicleTelemetryFindFirstArgs>(args?: SelectSubset<T, VehicleTelemetryFindFirstArgs<ExtArgs>>): Prisma__VehicleTelemetryClient<$Result.GetResult<Prisma.$VehicleTelemetryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first VehicleTelemetry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleTelemetryFindFirstOrThrowArgs} args - Arguments to find a VehicleTelemetry
     * @example
     * // Get one VehicleTelemetry
     * const vehicleTelemetry = await prisma.vehicleTelemetry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VehicleTelemetryFindFirstOrThrowArgs>(args?: SelectSubset<T, VehicleTelemetryFindFirstOrThrowArgs<ExtArgs>>): Prisma__VehicleTelemetryClient<$Result.GetResult<Prisma.$VehicleTelemetryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more VehicleTelemetries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleTelemetryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VehicleTelemetries
     * const vehicleTelemetries = await prisma.vehicleTelemetry.findMany()
     * 
     * // Get first 10 VehicleTelemetries
     * const vehicleTelemetries = await prisma.vehicleTelemetry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vehicleTelemetryWithIdOnly = await prisma.vehicleTelemetry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VehicleTelemetryFindManyArgs>(args?: SelectSubset<T, VehicleTelemetryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehicleTelemetryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a VehicleTelemetry.
     * @param {VehicleTelemetryCreateArgs} args - Arguments to create a VehicleTelemetry.
     * @example
     * // Create one VehicleTelemetry
     * const VehicleTelemetry = await prisma.vehicleTelemetry.create({
     *   data: {
     *     // ... data to create a VehicleTelemetry
     *   }
     * })
     * 
     */
    create<T extends VehicleTelemetryCreateArgs>(args: SelectSubset<T, VehicleTelemetryCreateArgs<ExtArgs>>): Prisma__VehicleTelemetryClient<$Result.GetResult<Prisma.$VehicleTelemetryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many VehicleTelemetries.
     * @param {VehicleTelemetryCreateManyArgs} args - Arguments to create many VehicleTelemetries.
     * @example
     * // Create many VehicleTelemetries
     * const vehicleTelemetry = await prisma.vehicleTelemetry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VehicleTelemetryCreateManyArgs>(args?: SelectSubset<T, VehicleTelemetryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VehicleTelemetries and returns the data saved in the database.
     * @param {VehicleTelemetryCreateManyAndReturnArgs} args - Arguments to create many VehicleTelemetries.
     * @example
     * // Create many VehicleTelemetries
     * const vehicleTelemetry = await prisma.vehicleTelemetry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VehicleTelemetries and only return the `id`
     * const vehicleTelemetryWithIdOnly = await prisma.vehicleTelemetry.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VehicleTelemetryCreateManyAndReturnArgs>(args?: SelectSubset<T, VehicleTelemetryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehicleTelemetryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a VehicleTelemetry.
     * @param {VehicleTelemetryDeleteArgs} args - Arguments to delete one VehicleTelemetry.
     * @example
     * // Delete one VehicleTelemetry
     * const VehicleTelemetry = await prisma.vehicleTelemetry.delete({
     *   where: {
     *     // ... filter to delete one VehicleTelemetry
     *   }
     * })
     * 
     */
    delete<T extends VehicleTelemetryDeleteArgs>(args: SelectSubset<T, VehicleTelemetryDeleteArgs<ExtArgs>>): Prisma__VehicleTelemetryClient<$Result.GetResult<Prisma.$VehicleTelemetryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one VehicleTelemetry.
     * @param {VehicleTelemetryUpdateArgs} args - Arguments to update one VehicleTelemetry.
     * @example
     * // Update one VehicleTelemetry
     * const vehicleTelemetry = await prisma.vehicleTelemetry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VehicleTelemetryUpdateArgs>(args: SelectSubset<T, VehicleTelemetryUpdateArgs<ExtArgs>>): Prisma__VehicleTelemetryClient<$Result.GetResult<Prisma.$VehicleTelemetryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more VehicleTelemetries.
     * @param {VehicleTelemetryDeleteManyArgs} args - Arguments to filter VehicleTelemetries to delete.
     * @example
     * // Delete a few VehicleTelemetries
     * const { count } = await prisma.vehicleTelemetry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VehicleTelemetryDeleteManyArgs>(args?: SelectSubset<T, VehicleTelemetryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VehicleTelemetries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleTelemetryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VehicleTelemetries
     * const vehicleTelemetry = await prisma.vehicleTelemetry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VehicleTelemetryUpdateManyArgs>(args: SelectSubset<T, VehicleTelemetryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VehicleTelemetry.
     * @param {VehicleTelemetryUpsertArgs} args - Arguments to update or create a VehicleTelemetry.
     * @example
     * // Update or create a VehicleTelemetry
     * const vehicleTelemetry = await prisma.vehicleTelemetry.upsert({
     *   create: {
     *     // ... data to create a VehicleTelemetry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VehicleTelemetry we want to update
     *   }
     * })
     */
    upsert<T extends VehicleTelemetryUpsertArgs>(args: SelectSubset<T, VehicleTelemetryUpsertArgs<ExtArgs>>): Prisma__VehicleTelemetryClient<$Result.GetResult<Prisma.$VehicleTelemetryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of VehicleTelemetries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleTelemetryCountArgs} args - Arguments to filter VehicleTelemetries to count.
     * @example
     * // Count the number of VehicleTelemetries
     * const count = await prisma.vehicleTelemetry.count({
     *   where: {
     *     // ... the filter for the VehicleTelemetries we want to count
     *   }
     * })
    **/
    count<T extends VehicleTelemetryCountArgs>(
      args?: Subset<T, VehicleTelemetryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VehicleTelemetryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VehicleTelemetry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleTelemetryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VehicleTelemetryAggregateArgs>(args: Subset<T, VehicleTelemetryAggregateArgs>): Prisma.PrismaPromise<GetVehicleTelemetryAggregateType<T>>

    /**
     * Group by VehicleTelemetry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleTelemetryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VehicleTelemetryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VehicleTelemetryGroupByArgs['orderBy'] }
        : { orderBy?: VehicleTelemetryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VehicleTelemetryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVehicleTelemetryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VehicleTelemetry model
   */
  readonly fields: VehicleTelemetryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VehicleTelemetry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VehicleTelemetryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vehicle<T extends VehicleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VehicleDefaultArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VehicleTelemetry model
   */ 
  interface VehicleTelemetryFieldRefs {
    readonly id: FieldRef<"VehicleTelemetry", 'BigInt'>
    readonly lat: FieldRef<"VehicleTelemetry", 'Decimal'>
    readonly lon: FieldRef<"VehicleTelemetry", 'Decimal'>
    readonly speed: FieldRef<"VehicleTelemetry", 'Decimal'>
    readonly ignition: FieldRef<"VehicleTelemetry", 'Boolean'>
    readonly trackedOn: FieldRef<"VehicleTelemetry", 'DateTime'>
    readonly vehicleId: FieldRef<"VehicleTelemetry", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * VehicleTelemetry findUnique
   */
  export type VehicleTelemetryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleTelemetry
     */
    select?: VehicleTelemetrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleTelemetryInclude<ExtArgs> | null
    /**
     * Filter, which VehicleTelemetry to fetch.
     */
    where: VehicleTelemetryWhereUniqueInput
  }

  /**
   * VehicleTelemetry findUniqueOrThrow
   */
  export type VehicleTelemetryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleTelemetry
     */
    select?: VehicleTelemetrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleTelemetryInclude<ExtArgs> | null
    /**
     * Filter, which VehicleTelemetry to fetch.
     */
    where: VehicleTelemetryWhereUniqueInput
  }

  /**
   * VehicleTelemetry findFirst
   */
  export type VehicleTelemetryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleTelemetry
     */
    select?: VehicleTelemetrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleTelemetryInclude<ExtArgs> | null
    /**
     * Filter, which VehicleTelemetry to fetch.
     */
    where?: VehicleTelemetryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleTelemetries to fetch.
     */
    orderBy?: VehicleTelemetryOrderByWithRelationInput | VehicleTelemetryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VehicleTelemetries.
     */
    cursor?: VehicleTelemetryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleTelemetries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleTelemetries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VehicleTelemetries.
     */
    distinct?: VehicleTelemetryScalarFieldEnum | VehicleTelemetryScalarFieldEnum[]
  }

  /**
   * VehicleTelemetry findFirstOrThrow
   */
  export type VehicleTelemetryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleTelemetry
     */
    select?: VehicleTelemetrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleTelemetryInclude<ExtArgs> | null
    /**
     * Filter, which VehicleTelemetry to fetch.
     */
    where?: VehicleTelemetryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleTelemetries to fetch.
     */
    orderBy?: VehicleTelemetryOrderByWithRelationInput | VehicleTelemetryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VehicleTelemetries.
     */
    cursor?: VehicleTelemetryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleTelemetries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleTelemetries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VehicleTelemetries.
     */
    distinct?: VehicleTelemetryScalarFieldEnum | VehicleTelemetryScalarFieldEnum[]
  }

  /**
   * VehicleTelemetry findMany
   */
  export type VehicleTelemetryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleTelemetry
     */
    select?: VehicleTelemetrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleTelemetryInclude<ExtArgs> | null
    /**
     * Filter, which VehicleTelemetries to fetch.
     */
    where?: VehicleTelemetryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleTelemetries to fetch.
     */
    orderBy?: VehicleTelemetryOrderByWithRelationInput | VehicleTelemetryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VehicleTelemetries.
     */
    cursor?: VehicleTelemetryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleTelemetries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleTelemetries.
     */
    skip?: number
    distinct?: VehicleTelemetryScalarFieldEnum | VehicleTelemetryScalarFieldEnum[]
  }

  /**
   * VehicleTelemetry create
   */
  export type VehicleTelemetryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleTelemetry
     */
    select?: VehicleTelemetrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleTelemetryInclude<ExtArgs> | null
    /**
     * The data needed to create a VehicleTelemetry.
     */
    data: XOR<VehicleTelemetryCreateInput, VehicleTelemetryUncheckedCreateInput>
  }

  /**
   * VehicleTelemetry createMany
   */
  export type VehicleTelemetryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VehicleTelemetries.
     */
    data: VehicleTelemetryCreateManyInput | VehicleTelemetryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VehicleTelemetry createManyAndReturn
   */
  export type VehicleTelemetryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleTelemetry
     */
    select?: VehicleTelemetrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many VehicleTelemetries.
     */
    data: VehicleTelemetryCreateManyInput | VehicleTelemetryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleTelemetryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VehicleTelemetry update
   */
  export type VehicleTelemetryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleTelemetry
     */
    select?: VehicleTelemetrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleTelemetryInclude<ExtArgs> | null
    /**
     * The data needed to update a VehicleTelemetry.
     */
    data: XOR<VehicleTelemetryUpdateInput, VehicleTelemetryUncheckedUpdateInput>
    /**
     * Choose, which VehicleTelemetry to update.
     */
    where: VehicleTelemetryWhereUniqueInput
  }

  /**
   * VehicleTelemetry updateMany
   */
  export type VehicleTelemetryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VehicleTelemetries.
     */
    data: XOR<VehicleTelemetryUpdateManyMutationInput, VehicleTelemetryUncheckedUpdateManyInput>
    /**
     * Filter which VehicleTelemetries to update
     */
    where?: VehicleTelemetryWhereInput
  }

  /**
   * VehicleTelemetry upsert
   */
  export type VehicleTelemetryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleTelemetry
     */
    select?: VehicleTelemetrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleTelemetryInclude<ExtArgs> | null
    /**
     * The filter to search for the VehicleTelemetry to update in case it exists.
     */
    where: VehicleTelemetryWhereUniqueInput
    /**
     * In case the VehicleTelemetry found by the `where` argument doesn't exist, create a new VehicleTelemetry with this data.
     */
    create: XOR<VehicleTelemetryCreateInput, VehicleTelemetryUncheckedCreateInput>
    /**
     * In case the VehicleTelemetry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VehicleTelemetryUpdateInput, VehicleTelemetryUncheckedUpdateInput>
  }

  /**
   * VehicleTelemetry delete
   */
  export type VehicleTelemetryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleTelemetry
     */
    select?: VehicleTelemetrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleTelemetryInclude<ExtArgs> | null
    /**
     * Filter which VehicleTelemetry to delete.
     */
    where: VehicleTelemetryWhereUniqueInput
  }

  /**
   * VehicleTelemetry deleteMany
   */
  export type VehicleTelemetryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VehicleTelemetries to delete
     */
    where?: VehicleTelemetryWhereInput
  }

  /**
   * VehicleTelemetry without action
   */
  export type VehicleTelemetryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleTelemetry
     */
    select?: VehicleTelemetrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleTelemetryInclude<ExtArgs> | null
  }


  /**
   * Model VehicleTelemetryHistory
   */

  export type AggregateVehicleTelemetryHistory = {
    _count: VehicleTelemetryHistoryCountAggregateOutputType | null
    _avg: VehicleTelemetryHistoryAvgAggregateOutputType | null
    _sum: VehicleTelemetryHistorySumAggregateOutputType | null
    _min: VehicleTelemetryHistoryMinAggregateOutputType | null
    _max: VehicleTelemetryHistoryMaxAggregateOutputType | null
  }

  export type VehicleTelemetryHistoryAvgAggregateOutputType = {
    id: number | null
    lat: Decimal | null
    lon: Decimal | null
    speed: Decimal | null
    vehicleId: number | null
  }

  export type VehicleTelemetryHistorySumAggregateOutputType = {
    id: bigint | null
    lat: Decimal | null
    lon: Decimal | null
    speed: Decimal | null
    vehicleId: bigint | null
  }

  export type VehicleTelemetryHistoryMinAggregateOutputType = {
    id: bigint | null
    lat: Decimal | null
    lon: Decimal | null
    speed: Decimal | null
    ignition: boolean | null
    trackedOn: Date | null
    vehicleId: bigint | null
  }

  export type VehicleTelemetryHistoryMaxAggregateOutputType = {
    id: bigint | null
    lat: Decimal | null
    lon: Decimal | null
    speed: Decimal | null
    ignition: boolean | null
    trackedOn: Date | null
    vehicleId: bigint | null
  }

  export type VehicleTelemetryHistoryCountAggregateOutputType = {
    id: number
    lat: number
    lon: number
    speed: number
    ignition: number
    trackedOn: number
    vehicleId: number
    _all: number
  }


  export type VehicleTelemetryHistoryAvgAggregateInputType = {
    id?: true
    lat?: true
    lon?: true
    speed?: true
    vehicleId?: true
  }

  export type VehicleTelemetryHistorySumAggregateInputType = {
    id?: true
    lat?: true
    lon?: true
    speed?: true
    vehicleId?: true
  }

  export type VehicleTelemetryHistoryMinAggregateInputType = {
    id?: true
    lat?: true
    lon?: true
    speed?: true
    ignition?: true
    trackedOn?: true
    vehicleId?: true
  }

  export type VehicleTelemetryHistoryMaxAggregateInputType = {
    id?: true
    lat?: true
    lon?: true
    speed?: true
    ignition?: true
    trackedOn?: true
    vehicleId?: true
  }

  export type VehicleTelemetryHistoryCountAggregateInputType = {
    id?: true
    lat?: true
    lon?: true
    speed?: true
    ignition?: true
    trackedOn?: true
    vehicleId?: true
    _all?: true
  }

  export type VehicleTelemetryHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VehicleTelemetryHistory to aggregate.
     */
    where?: VehicleTelemetryHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleTelemetryHistories to fetch.
     */
    orderBy?: VehicleTelemetryHistoryOrderByWithRelationInput | VehicleTelemetryHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VehicleTelemetryHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleTelemetryHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleTelemetryHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VehicleTelemetryHistories
    **/
    _count?: true | VehicleTelemetryHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VehicleTelemetryHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VehicleTelemetryHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VehicleTelemetryHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VehicleTelemetryHistoryMaxAggregateInputType
  }

  export type GetVehicleTelemetryHistoryAggregateType<T extends VehicleTelemetryHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateVehicleTelemetryHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVehicleTelemetryHistory[P]>
      : GetScalarType<T[P], AggregateVehicleTelemetryHistory[P]>
  }




  export type VehicleTelemetryHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VehicleTelemetryHistoryWhereInput
    orderBy?: VehicleTelemetryHistoryOrderByWithAggregationInput | VehicleTelemetryHistoryOrderByWithAggregationInput[]
    by: VehicleTelemetryHistoryScalarFieldEnum[] | VehicleTelemetryHistoryScalarFieldEnum
    having?: VehicleTelemetryHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VehicleTelemetryHistoryCountAggregateInputType | true
    _avg?: VehicleTelemetryHistoryAvgAggregateInputType
    _sum?: VehicleTelemetryHistorySumAggregateInputType
    _min?: VehicleTelemetryHistoryMinAggregateInputType
    _max?: VehicleTelemetryHistoryMaxAggregateInputType
  }

  export type VehicleTelemetryHistoryGroupByOutputType = {
    id: bigint
    lat: Decimal
    lon: Decimal
    speed: Decimal | null
    ignition: boolean
    trackedOn: Date
    vehicleId: bigint
    _count: VehicleTelemetryHistoryCountAggregateOutputType | null
    _avg: VehicleTelemetryHistoryAvgAggregateOutputType | null
    _sum: VehicleTelemetryHistorySumAggregateOutputType | null
    _min: VehicleTelemetryHistoryMinAggregateOutputType | null
    _max: VehicleTelemetryHistoryMaxAggregateOutputType | null
  }

  type GetVehicleTelemetryHistoryGroupByPayload<T extends VehicleTelemetryHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VehicleTelemetryHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VehicleTelemetryHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VehicleTelemetryHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], VehicleTelemetryHistoryGroupByOutputType[P]>
        }
      >
    >


  export type VehicleTelemetryHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lat?: boolean
    lon?: boolean
    speed?: boolean
    ignition?: boolean
    trackedOn?: boolean
    vehicleId?: boolean
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicleTelemetryHistory"]>

  export type VehicleTelemetryHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lat?: boolean
    lon?: boolean
    speed?: boolean
    ignition?: boolean
    trackedOn?: boolean
    vehicleId?: boolean
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicleTelemetryHistory"]>

  export type VehicleTelemetryHistorySelectScalar = {
    id?: boolean
    lat?: boolean
    lon?: boolean
    speed?: boolean
    ignition?: boolean
    trackedOn?: boolean
    vehicleId?: boolean
  }

  export type VehicleTelemetryHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
  }
  export type VehicleTelemetryHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
  }

  export type $VehicleTelemetryHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VehicleTelemetryHistory"
    objects: {
      vehicle: Prisma.$VehiclePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      lat: Prisma.Decimal
      lon: Prisma.Decimal
      speed: Prisma.Decimal | null
      ignition: boolean
      trackedOn: Date
      vehicleId: bigint
    }, ExtArgs["result"]["vehicleTelemetryHistory"]>
    composites: {}
  }

  type VehicleTelemetryHistoryGetPayload<S extends boolean | null | undefined | VehicleTelemetryHistoryDefaultArgs> = $Result.GetResult<Prisma.$VehicleTelemetryHistoryPayload, S>

  type VehicleTelemetryHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VehicleTelemetryHistoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VehicleTelemetryHistoryCountAggregateInputType | true
    }

  export interface VehicleTelemetryHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VehicleTelemetryHistory'], meta: { name: 'VehicleTelemetryHistory' } }
    /**
     * Find zero or one VehicleTelemetryHistory that matches the filter.
     * @param {VehicleTelemetryHistoryFindUniqueArgs} args - Arguments to find a VehicleTelemetryHistory
     * @example
     * // Get one VehicleTelemetryHistory
     * const vehicleTelemetryHistory = await prisma.vehicleTelemetryHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VehicleTelemetryHistoryFindUniqueArgs>(args: SelectSubset<T, VehicleTelemetryHistoryFindUniqueArgs<ExtArgs>>): Prisma__VehicleTelemetryHistoryClient<$Result.GetResult<Prisma.$VehicleTelemetryHistoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one VehicleTelemetryHistory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VehicleTelemetryHistoryFindUniqueOrThrowArgs} args - Arguments to find a VehicleTelemetryHistory
     * @example
     * // Get one VehicleTelemetryHistory
     * const vehicleTelemetryHistory = await prisma.vehicleTelemetryHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VehicleTelemetryHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, VehicleTelemetryHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VehicleTelemetryHistoryClient<$Result.GetResult<Prisma.$VehicleTelemetryHistoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first VehicleTelemetryHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleTelemetryHistoryFindFirstArgs} args - Arguments to find a VehicleTelemetryHistory
     * @example
     * // Get one VehicleTelemetryHistory
     * const vehicleTelemetryHistory = await prisma.vehicleTelemetryHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VehicleTelemetryHistoryFindFirstArgs>(args?: SelectSubset<T, VehicleTelemetryHistoryFindFirstArgs<ExtArgs>>): Prisma__VehicleTelemetryHistoryClient<$Result.GetResult<Prisma.$VehicleTelemetryHistoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first VehicleTelemetryHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleTelemetryHistoryFindFirstOrThrowArgs} args - Arguments to find a VehicleTelemetryHistory
     * @example
     * // Get one VehicleTelemetryHistory
     * const vehicleTelemetryHistory = await prisma.vehicleTelemetryHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VehicleTelemetryHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, VehicleTelemetryHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__VehicleTelemetryHistoryClient<$Result.GetResult<Prisma.$VehicleTelemetryHistoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more VehicleTelemetryHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleTelemetryHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VehicleTelemetryHistories
     * const vehicleTelemetryHistories = await prisma.vehicleTelemetryHistory.findMany()
     * 
     * // Get first 10 VehicleTelemetryHistories
     * const vehicleTelemetryHistories = await prisma.vehicleTelemetryHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vehicleTelemetryHistoryWithIdOnly = await prisma.vehicleTelemetryHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VehicleTelemetryHistoryFindManyArgs>(args?: SelectSubset<T, VehicleTelemetryHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehicleTelemetryHistoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a VehicleTelemetryHistory.
     * @param {VehicleTelemetryHistoryCreateArgs} args - Arguments to create a VehicleTelemetryHistory.
     * @example
     * // Create one VehicleTelemetryHistory
     * const VehicleTelemetryHistory = await prisma.vehicleTelemetryHistory.create({
     *   data: {
     *     // ... data to create a VehicleTelemetryHistory
     *   }
     * })
     * 
     */
    create<T extends VehicleTelemetryHistoryCreateArgs>(args: SelectSubset<T, VehicleTelemetryHistoryCreateArgs<ExtArgs>>): Prisma__VehicleTelemetryHistoryClient<$Result.GetResult<Prisma.$VehicleTelemetryHistoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many VehicleTelemetryHistories.
     * @param {VehicleTelemetryHistoryCreateManyArgs} args - Arguments to create many VehicleTelemetryHistories.
     * @example
     * // Create many VehicleTelemetryHistories
     * const vehicleTelemetryHistory = await prisma.vehicleTelemetryHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VehicleTelemetryHistoryCreateManyArgs>(args?: SelectSubset<T, VehicleTelemetryHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VehicleTelemetryHistories and returns the data saved in the database.
     * @param {VehicleTelemetryHistoryCreateManyAndReturnArgs} args - Arguments to create many VehicleTelemetryHistories.
     * @example
     * // Create many VehicleTelemetryHistories
     * const vehicleTelemetryHistory = await prisma.vehicleTelemetryHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VehicleTelemetryHistories and only return the `id`
     * const vehicleTelemetryHistoryWithIdOnly = await prisma.vehicleTelemetryHistory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VehicleTelemetryHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, VehicleTelemetryHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehicleTelemetryHistoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a VehicleTelemetryHistory.
     * @param {VehicleTelemetryHistoryDeleteArgs} args - Arguments to delete one VehicleTelemetryHistory.
     * @example
     * // Delete one VehicleTelemetryHistory
     * const VehicleTelemetryHistory = await prisma.vehicleTelemetryHistory.delete({
     *   where: {
     *     // ... filter to delete one VehicleTelemetryHistory
     *   }
     * })
     * 
     */
    delete<T extends VehicleTelemetryHistoryDeleteArgs>(args: SelectSubset<T, VehicleTelemetryHistoryDeleteArgs<ExtArgs>>): Prisma__VehicleTelemetryHistoryClient<$Result.GetResult<Prisma.$VehicleTelemetryHistoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one VehicleTelemetryHistory.
     * @param {VehicleTelemetryHistoryUpdateArgs} args - Arguments to update one VehicleTelemetryHistory.
     * @example
     * // Update one VehicleTelemetryHistory
     * const vehicleTelemetryHistory = await prisma.vehicleTelemetryHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VehicleTelemetryHistoryUpdateArgs>(args: SelectSubset<T, VehicleTelemetryHistoryUpdateArgs<ExtArgs>>): Prisma__VehicleTelemetryHistoryClient<$Result.GetResult<Prisma.$VehicleTelemetryHistoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more VehicleTelemetryHistories.
     * @param {VehicleTelemetryHistoryDeleteManyArgs} args - Arguments to filter VehicleTelemetryHistories to delete.
     * @example
     * // Delete a few VehicleTelemetryHistories
     * const { count } = await prisma.vehicleTelemetryHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VehicleTelemetryHistoryDeleteManyArgs>(args?: SelectSubset<T, VehicleTelemetryHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VehicleTelemetryHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleTelemetryHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VehicleTelemetryHistories
     * const vehicleTelemetryHistory = await prisma.vehicleTelemetryHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VehicleTelemetryHistoryUpdateManyArgs>(args: SelectSubset<T, VehicleTelemetryHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VehicleTelemetryHistory.
     * @param {VehicleTelemetryHistoryUpsertArgs} args - Arguments to update or create a VehicleTelemetryHistory.
     * @example
     * // Update or create a VehicleTelemetryHistory
     * const vehicleTelemetryHistory = await prisma.vehicleTelemetryHistory.upsert({
     *   create: {
     *     // ... data to create a VehicleTelemetryHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VehicleTelemetryHistory we want to update
     *   }
     * })
     */
    upsert<T extends VehicleTelemetryHistoryUpsertArgs>(args: SelectSubset<T, VehicleTelemetryHistoryUpsertArgs<ExtArgs>>): Prisma__VehicleTelemetryHistoryClient<$Result.GetResult<Prisma.$VehicleTelemetryHistoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of VehicleTelemetryHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleTelemetryHistoryCountArgs} args - Arguments to filter VehicleTelemetryHistories to count.
     * @example
     * // Count the number of VehicleTelemetryHistories
     * const count = await prisma.vehicleTelemetryHistory.count({
     *   where: {
     *     // ... the filter for the VehicleTelemetryHistories we want to count
     *   }
     * })
    **/
    count<T extends VehicleTelemetryHistoryCountArgs>(
      args?: Subset<T, VehicleTelemetryHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VehicleTelemetryHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VehicleTelemetryHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleTelemetryHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VehicleTelemetryHistoryAggregateArgs>(args: Subset<T, VehicleTelemetryHistoryAggregateArgs>): Prisma.PrismaPromise<GetVehicleTelemetryHistoryAggregateType<T>>

    /**
     * Group by VehicleTelemetryHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleTelemetryHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VehicleTelemetryHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VehicleTelemetryHistoryGroupByArgs['orderBy'] }
        : { orderBy?: VehicleTelemetryHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VehicleTelemetryHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVehicleTelemetryHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VehicleTelemetryHistory model
   */
  readonly fields: VehicleTelemetryHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VehicleTelemetryHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VehicleTelemetryHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vehicle<T extends VehicleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VehicleDefaultArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VehicleTelemetryHistory model
   */ 
  interface VehicleTelemetryHistoryFieldRefs {
    readonly id: FieldRef<"VehicleTelemetryHistory", 'BigInt'>
    readonly lat: FieldRef<"VehicleTelemetryHistory", 'Decimal'>
    readonly lon: FieldRef<"VehicleTelemetryHistory", 'Decimal'>
    readonly speed: FieldRef<"VehicleTelemetryHistory", 'Decimal'>
    readonly ignition: FieldRef<"VehicleTelemetryHistory", 'Boolean'>
    readonly trackedOn: FieldRef<"VehicleTelemetryHistory", 'DateTime'>
    readonly vehicleId: FieldRef<"VehicleTelemetryHistory", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * VehicleTelemetryHistory findUnique
   */
  export type VehicleTelemetryHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleTelemetryHistory
     */
    select?: VehicleTelemetryHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleTelemetryHistoryInclude<ExtArgs> | null
    /**
     * Filter, which VehicleTelemetryHistory to fetch.
     */
    where: VehicleTelemetryHistoryWhereUniqueInput
  }

  /**
   * VehicleTelemetryHistory findUniqueOrThrow
   */
  export type VehicleTelemetryHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleTelemetryHistory
     */
    select?: VehicleTelemetryHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleTelemetryHistoryInclude<ExtArgs> | null
    /**
     * Filter, which VehicleTelemetryHistory to fetch.
     */
    where: VehicleTelemetryHistoryWhereUniqueInput
  }

  /**
   * VehicleTelemetryHistory findFirst
   */
  export type VehicleTelemetryHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleTelemetryHistory
     */
    select?: VehicleTelemetryHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleTelemetryHistoryInclude<ExtArgs> | null
    /**
     * Filter, which VehicleTelemetryHistory to fetch.
     */
    where?: VehicleTelemetryHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleTelemetryHistories to fetch.
     */
    orderBy?: VehicleTelemetryHistoryOrderByWithRelationInput | VehicleTelemetryHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VehicleTelemetryHistories.
     */
    cursor?: VehicleTelemetryHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleTelemetryHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleTelemetryHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VehicleTelemetryHistories.
     */
    distinct?: VehicleTelemetryHistoryScalarFieldEnum | VehicleTelemetryHistoryScalarFieldEnum[]
  }

  /**
   * VehicleTelemetryHistory findFirstOrThrow
   */
  export type VehicleTelemetryHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleTelemetryHistory
     */
    select?: VehicleTelemetryHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleTelemetryHistoryInclude<ExtArgs> | null
    /**
     * Filter, which VehicleTelemetryHistory to fetch.
     */
    where?: VehicleTelemetryHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleTelemetryHistories to fetch.
     */
    orderBy?: VehicleTelemetryHistoryOrderByWithRelationInput | VehicleTelemetryHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VehicleTelemetryHistories.
     */
    cursor?: VehicleTelemetryHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleTelemetryHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleTelemetryHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VehicleTelemetryHistories.
     */
    distinct?: VehicleTelemetryHistoryScalarFieldEnum | VehicleTelemetryHistoryScalarFieldEnum[]
  }

  /**
   * VehicleTelemetryHistory findMany
   */
  export type VehicleTelemetryHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleTelemetryHistory
     */
    select?: VehicleTelemetryHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleTelemetryHistoryInclude<ExtArgs> | null
    /**
     * Filter, which VehicleTelemetryHistories to fetch.
     */
    where?: VehicleTelemetryHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleTelemetryHistories to fetch.
     */
    orderBy?: VehicleTelemetryHistoryOrderByWithRelationInput | VehicleTelemetryHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VehicleTelemetryHistories.
     */
    cursor?: VehicleTelemetryHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleTelemetryHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleTelemetryHistories.
     */
    skip?: number
    distinct?: VehicleTelemetryHistoryScalarFieldEnum | VehicleTelemetryHistoryScalarFieldEnum[]
  }

  /**
   * VehicleTelemetryHistory create
   */
  export type VehicleTelemetryHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleTelemetryHistory
     */
    select?: VehicleTelemetryHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleTelemetryHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a VehicleTelemetryHistory.
     */
    data: XOR<VehicleTelemetryHistoryCreateInput, VehicleTelemetryHistoryUncheckedCreateInput>
  }

  /**
   * VehicleTelemetryHistory createMany
   */
  export type VehicleTelemetryHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VehicleTelemetryHistories.
     */
    data: VehicleTelemetryHistoryCreateManyInput | VehicleTelemetryHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VehicleTelemetryHistory createManyAndReturn
   */
  export type VehicleTelemetryHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleTelemetryHistory
     */
    select?: VehicleTelemetryHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many VehicleTelemetryHistories.
     */
    data: VehicleTelemetryHistoryCreateManyInput | VehicleTelemetryHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleTelemetryHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VehicleTelemetryHistory update
   */
  export type VehicleTelemetryHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleTelemetryHistory
     */
    select?: VehicleTelemetryHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleTelemetryHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a VehicleTelemetryHistory.
     */
    data: XOR<VehicleTelemetryHistoryUpdateInput, VehicleTelemetryHistoryUncheckedUpdateInput>
    /**
     * Choose, which VehicleTelemetryHistory to update.
     */
    where: VehicleTelemetryHistoryWhereUniqueInput
  }

  /**
   * VehicleTelemetryHistory updateMany
   */
  export type VehicleTelemetryHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VehicleTelemetryHistories.
     */
    data: XOR<VehicleTelemetryHistoryUpdateManyMutationInput, VehicleTelemetryHistoryUncheckedUpdateManyInput>
    /**
     * Filter which VehicleTelemetryHistories to update
     */
    where?: VehicleTelemetryHistoryWhereInput
  }

  /**
   * VehicleTelemetryHistory upsert
   */
  export type VehicleTelemetryHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleTelemetryHistory
     */
    select?: VehicleTelemetryHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleTelemetryHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the VehicleTelemetryHistory to update in case it exists.
     */
    where: VehicleTelemetryHistoryWhereUniqueInput
    /**
     * In case the VehicleTelemetryHistory found by the `where` argument doesn't exist, create a new VehicleTelemetryHistory with this data.
     */
    create: XOR<VehicleTelemetryHistoryCreateInput, VehicleTelemetryHistoryUncheckedCreateInput>
    /**
     * In case the VehicleTelemetryHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VehicleTelemetryHistoryUpdateInput, VehicleTelemetryHistoryUncheckedUpdateInput>
  }

  /**
   * VehicleTelemetryHistory delete
   */
  export type VehicleTelemetryHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleTelemetryHistory
     */
    select?: VehicleTelemetryHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleTelemetryHistoryInclude<ExtArgs> | null
    /**
     * Filter which VehicleTelemetryHistory to delete.
     */
    where: VehicleTelemetryHistoryWhereUniqueInput
  }

  /**
   * VehicleTelemetryHistory deleteMany
   */
  export type VehicleTelemetryHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VehicleTelemetryHistories to delete
     */
    where?: VehicleTelemetryHistoryWhereInput
  }

  /**
   * VehicleTelemetryHistory without action
   */
  export type VehicleTelemetryHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleTelemetryHistory
     */
    select?: VehicleTelemetryHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleTelemetryHistoryInclude<ExtArgs> | null
  }


  /**
   * Model Shift
   */

  export type AggregateShift = {
    _count: ShiftCountAggregateOutputType | null
    _avg: ShiftAvgAggregateOutputType | null
    _sum: ShiftSumAggregateOutputType | null
    _min: ShiftMinAggregateOutputType | null
    _max: ShiftMaxAggregateOutputType | null
  }

  export type ShiftAvgAggregateOutputType = {
    id: number | null
    vehicleId: number | null
    driverId: number | null
  }

  export type ShiftSumAggregateOutputType = {
    id: bigint | null
    vehicleId: bigint | null
    driverId: bigint | null
  }

  export type ShiftMinAggregateOutputType = {
    id: bigint | null
    startTime: Date | null
    endTime: Date | null
    vehicleId: bigint | null
    driverId: bigint | null
  }

  export type ShiftMaxAggregateOutputType = {
    id: bigint | null
    startTime: Date | null
    endTime: Date | null
    vehicleId: bigint | null
    driverId: bigint | null
  }

  export type ShiftCountAggregateOutputType = {
    id: number
    startTime: number
    endTime: number
    vehicleId: number
    driverId: number
    _all: number
  }


  export type ShiftAvgAggregateInputType = {
    id?: true
    vehicleId?: true
    driverId?: true
  }

  export type ShiftSumAggregateInputType = {
    id?: true
    vehicleId?: true
    driverId?: true
  }

  export type ShiftMinAggregateInputType = {
    id?: true
    startTime?: true
    endTime?: true
    vehicleId?: true
    driverId?: true
  }

  export type ShiftMaxAggregateInputType = {
    id?: true
    startTime?: true
    endTime?: true
    vehicleId?: true
    driverId?: true
  }

  export type ShiftCountAggregateInputType = {
    id?: true
    startTime?: true
    endTime?: true
    vehicleId?: true
    driverId?: true
    _all?: true
  }

  export type ShiftAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shift to aggregate.
     */
    where?: ShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shifts to fetch.
     */
    orderBy?: ShiftOrderByWithRelationInput | ShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Shifts
    **/
    _count?: true | ShiftCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShiftAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShiftSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShiftMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShiftMaxAggregateInputType
  }

  export type GetShiftAggregateType<T extends ShiftAggregateArgs> = {
        [P in keyof T & keyof AggregateShift]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShift[P]>
      : GetScalarType<T[P], AggregateShift[P]>
  }




  export type ShiftGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShiftWhereInput
    orderBy?: ShiftOrderByWithAggregationInput | ShiftOrderByWithAggregationInput[]
    by: ShiftScalarFieldEnum[] | ShiftScalarFieldEnum
    having?: ShiftScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShiftCountAggregateInputType | true
    _avg?: ShiftAvgAggregateInputType
    _sum?: ShiftSumAggregateInputType
    _min?: ShiftMinAggregateInputType
    _max?: ShiftMaxAggregateInputType
  }

  export type ShiftGroupByOutputType = {
    id: bigint
    startTime: Date
    endTime: Date
    vehicleId: bigint
    driverId: bigint
    _count: ShiftCountAggregateOutputType | null
    _avg: ShiftAvgAggregateOutputType | null
    _sum: ShiftSumAggregateOutputType | null
    _min: ShiftMinAggregateOutputType | null
    _max: ShiftMaxAggregateOutputType | null
  }

  type GetShiftGroupByPayload<T extends ShiftGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShiftGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShiftGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShiftGroupByOutputType[P]>
            : GetScalarType<T[P], ShiftGroupByOutputType[P]>
        }
      >
    >


  export type ShiftSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    startTime?: boolean
    endTime?: boolean
    vehicleId?: boolean
    driverId?: boolean
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
    driver?: boolean | DriverDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shift"]>

  export type ShiftSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    startTime?: boolean
    endTime?: boolean
    vehicleId?: boolean
    driverId?: boolean
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
    driver?: boolean | DriverDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shift"]>

  export type ShiftSelectScalar = {
    id?: boolean
    startTime?: boolean
    endTime?: boolean
    vehicleId?: boolean
    driverId?: boolean
  }

  export type ShiftInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
    driver?: boolean | DriverDefaultArgs<ExtArgs>
  }
  export type ShiftIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
    driver?: boolean | DriverDefaultArgs<ExtArgs>
  }

  export type $ShiftPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Shift"
    objects: {
      vehicle: Prisma.$VehiclePayload<ExtArgs>
      driver: Prisma.$DriverPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      startTime: Date
      endTime: Date
      vehicleId: bigint
      driverId: bigint
    }, ExtArgs["result"]["shift"]>
    composites: {}
  }

  type ShiftGetPayload<S extends boolean | null | undefined | ShiftDefaultArgs> = $Result.GetResult<Prisma.$ShiftPayload, S>

  type ShiftCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ShiftFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ShiftCountAggregateInputType | true
    }

  export interface ShiftDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Shift'], meta: { name: 'Shift' } }
    /**
     * Find zero or one Shift that matches the filter.
     * @param {ShiftFindUniqueArgs} args - Arguments to find a Shift
     * @example
     * // Get one Shift
     * const shift = await prisma.shift.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShiftFindUniqueArgs>(args: SelectSubset<T, ShiftFindUniqueArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Shift that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ShiftFindUniqueOrThrowArgs} args - Arguments to find a Shift
     * @example
     * // Get one Shift
     * const shift = await prisma.shift.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShiftFindUniqueOrThrowArgs>(args: SelectSubset<T, ShiftFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Shift that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftFindFirstArgs} args - Arguments to find a Shift
     * @example
     * // Get one Shift
     * const shift = await prisma.shift.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShiftFindFirstArgs>(args?: SelectSubset<T, ShiftFindFirstArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Shift that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftFindFirstOrThrowArgs} args - Arguments to find a Shift
     * @example
     * // Get one Shift
     * const shift = await prisma.shift.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShiftFindFirstOrThrowArgs>(args?: SelectSubset<T, ShiftFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Shifts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Shifts
     * const shifts = await prisma.shift.findMany()
     * 
     * // Get first 10 Shifts
     * const shifts = await prisma.shift.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shiftWithIdOnly = await prisma.shift.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShiftFindManyArgs>(args?: SelectSubset<T, ShiftFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Shift.
     * @param {ShiftCreateArgs} args - Arguments to create a Shift.
     * @example
     * // Create one Shift
     * const Shift = await prisma.shift.create({
     *   data: {
     *     // ... data to create a Shift
     *   }
     * })
     * 
     */
    create<T extends ShiftCreateArgs>(args: SelectSubset<T, ShiftCreateArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Shifts.
     * @param {ShiftCreateManyArgs} args - Arguments to create many Shifts.
     * @example
     * // Create many Shifts
     * const shift = await prisma.shift.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShiftCreateManyArgs>(args?: SelectSubset<T, ShiftCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Shifts and returns the data saved in the database.
     * @param {ShiftCreateManyAndReturnArgs} args - Arguments to create many Shifts.
     * @example
     * // Create many Shifts
     * const shift = await prisma.shift.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Shifts and only return the `id`
     * const shiftWithIdOnly = await prisma.shift.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ShiftCreateManyAndReturnArgs>(args?: SelectSubset<T, ShiftCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Shift.
     * @param {ShiftDeleteArgs} args - Arguments to delete one Shift.
     * @example
     * // Delete one Shift
     * const Shift = await prisma.shift.delete({
     *   where: {
     *     // ... filter to delete one Shift
     *   }
     * })
     * 
     */
    delete<T extends ShiftDeleteArgs>(args: SelectSubset<T, ShiftDeleteArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Shift.
     * @param {ShiftUpdateArgs} args - Arguments to update one Shift.
     * @example
     * // Update one Shift
     * const shift = await prisma.shift.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShiftUpdateArgs>(args: SelectSubset<T, ShiftUpdateArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Shifts.
     * @param {ShiftDeleteManyArgs} args - Arguments to filter Shifts to delete.
     * @example
     * // Delete a few Shifts
     * const { count } = await prisma.shift.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShiftDeleteManyArgs>(args?: SelectSubset<T, ShiftDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Shifts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Shifts
     * const shift = await prisma.shift.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShiftUpdateManyArgs>(args: SelectSubset<T, ShiftUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Shift.
     * @param {ShiftUpsertArgs} args - Arguments to update or create a Shift.
     * @example
     * // Update or create a Shift
     * const shift = await prisma.shift.upsert({
     *   create: {
     *     // ... data to create a Shift
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Shift we want to update
     *   }
     * })
     */
    upsert<T extends ShiftUpsertArgs>(args: SelectSubset<T, ShiftUpsertArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Shifts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftCountArgs} args - Arguments to filter Shifts to count.
     * @example
     * // Count the number of Shifts
     * const count = await prisma.shift.count({
     *   where: {
     *     // ... the filter for the Shifts we want to count
     *   }
     * })
    **/
    count<T extends ShiftCountArgs>(
      args?: Subset<T, ShiftCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShiftCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Shift.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShiftAggregateArgs>(args: Subset<T, ShiftAggregateArgs>): Prisma.PrismaPromise<GetShiftAggregateType<T>>

    /**
     * Group by Shift.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShiftGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShiftGroupByArgs['orderBy'] }
        : { orderBy?: ShiftGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShiftGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShiftGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Shift model
   */
  readonly fields: ShiftFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Shift.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShiftClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vehicle<T extends VehicleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VehicleDefaultArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    driver<T extends DriverDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DriverDefaultArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Shift model
   */ 
  interface ShiftFieldRefs {
    readonly id: FieldRef<"Shift", 'BigInt'>
    readonly startTime: FieldRef<"Shift", 'DateTime'>
    readonly endTime: FieldRef<"Shift", 'DateTime'>
    readonly vehicleId: FieldRef<"Shift", 'BigInt'>
    readonly driverId: FieldRef<"Shift", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * Shift findUnique
   */
  export type ShiftFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * Filter, which Shift to fetch.
     */
    where: ShiftWhereUniqueInput
  }

  /**
   * Shift findUniqueOrThrow
   */
  export type ShiftFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * Filter, which Shift to fetch.
     */
    where: ShiftWhereUniqueInput
  }

  /**
   * Shift findFirst
   */
  export type ShiftFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * Filter, which Shift to fetch.
     */
    where?: ShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shifts to fetch.
     */
    orderBy?: ShiftOrderByWithRelationInput | ShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shifts.
     */
    cursor?: ShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shifts.
     */
    distinct?: ShiftScalarFieldEnum | ShiftScalarFieldEnum[]
  }

  /**
   * Shift findFirstOrThrow
   */
  export type ShiftFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * Filter, which Shift to fetch.
     */
    where?: ShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shifts to fetch.
     */
    orderBy?: ShiftOrderByWithRelationInput | ShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shifts.
     */
    cursor?: ShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shifts.
     */
    distinct?: ShiftScalarFieldEnum | ShiftScalarFieldEnum[]
  }

  /**
   * Shift findMany
   */
  export type ShiftFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * Filter, which Shifts to fetch.
     */
    where?: ShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shifts to fetch.
     */
    orderBy?: ShiftOrderByWithRelationInput | ShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Shifts.
     */
    cursor?: ShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shifts.
     */
    skip?: number
    distinct?: ShiftScalarFieldEnum | ShiftScalarFieldEnum[]
  }

  /**
   * Shift create
   */
  export type ShiftCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * The data needed to create a Shift.
     */
    data: XOR<ShiftCreateInput, ShiftUncheckedCreateInput>
  }

  /**
   * Shift createMany
   */
  export type ShiftCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Shifts.
     */
    data: ShiftCreateManyInput | ShiftCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Shift createManyAndReturn
   */
  export type ShiftCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Shifts.
     */
    data: ShiftCreateManyInput | ShiftCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Shift update
   */
  export type ShiftUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * The data needed to update a Shift.
     */
    data: XOR<ShiftUpdateInput, ShiftUncheckedUpdateInput>
    /**
     * Choose, which Shift to update.
     */
    where: ShiftWhereUniqueInput
  }

  /**
   * Shift updateMany
   */
  export type ShiftUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Shifts.
     */
    data: XOR<ShiftUpdateManyMutationInput, ShiftUncheckedUpdateManyInput>
    /**
     * Filter which Shifts to update
     */
    where?: ShiftWhereInput
  }

  /**
   * Shift upsert
   */
  export type ShiftUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * The filter to search for the Shift to update in case it exists.
     */
    where: ShiftWhereUniqueInput
    /**
     * In case the Shift found by the `where` argument doesn't exist, create a new Shift with this data.
     */
    create: XOR<ShiftCreateInput, ShiftUncheckedCreateInput>
    /**
     * In case the Shift was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShiftUpdateInput, ShiftUncheckedUpdateInput>
  }

  /**
   * Shift delete
   */
  export type ShiftDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * Filter which Shift to delete.
     */
    where: ShiftWhereUniqueInput
  }

  /**
   * Shift deleteMany
   */
  export type ShiftDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shifts to delete
     */
    where?: ShiftWhereInput
  }

  /**
   * Shift without action
   */
  export type ShiftDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
  }


  /**
   * Model ServiceSchedule
   */

  export type AggregateServiceSchedule = {
    _count: ServiceScheduleCountAggregateOutputType | null
    _avg: ServiceScheduleAvgAggregateOutputType | null
    _sum: ServiceScheduleSumAggregateOutputType | null
    _min: ServiceScheduleMinAggregateOutputType | null
    _max: ServiceScheduleMaxAggregateOutputType | null
  }

  export type ServiceScheduleAvgAggregateOutputType = {
    id: number | null
  }

  export type ServiceScheduleSumAggregateOutputType = {
    id: bigint | null
  }

  export type ServiceScheduleMinAggregateOutputType = {
    id: bigint | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceScheduleMaxAggregateOutputType = {
    id: bigint | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceScheduleCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ServiceScheduleAvgAggregateInputType = {
    id?: true
  }

  export type ServiceScheduleSumAggregateInputType = {
    id?: true
  }

  export type ServiceScheduleMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceScheduleMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceScheduleCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ServiceScheduleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceSchedule to aggregate.
     */
    where?: ServiceScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceSchedules to fetch.
     */
    orderBy?: ServiceScheduleOrderByWithRelationInput | ServiceScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceSchedules
    **/
    _count?: true | ServiceScheduleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceScheduleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceScheduleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceScheduleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceScheduleMaxAggregateInputType
  }

  export type GetServiceScheduleAggregateType<T extends ServiceScheduleAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceSchedule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceSchedule[P]>
      : GetScalarType<T[P], AggregateServiceSchedule[P]>
  }




  export type ServiceScheduleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceScheduleWhereInput
    orderBy?: ServiceScheduleOrderByWithAggregationInput | ServiceScheduleOrderByWithAggregationInput[]
    by: ServiceScheduleScalarFieldEnum[] | ServiceScheduleScalarFieldEnum
    having?: ServiceScheduleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceScheduleCountAggregateInputType | true
    _avg?: ServiceScheduleAvgAggregateInputType
    _sum?: ServiceScheduleSumAggregateInputType
    _min?: ServiceScheduleMinAggregateInputType
    _max?: ServiceScheduleMaxAggregateInputType
  }

  export type ServiceScheduleGroupByOutputType = {
    id: bigint
    name: string
    createdAt: Date
    updatedAt: Date
    _count: ServiceScheduleCountAggregateOutputType | null
    _avg: ServiceScheduleAvgAggregateOutputType | null
    _sum: ServiceScheduleSumAggregateOutputType | null
    _min: ServiceScheduleMinAggregateOutputType | null
    _max: ServiceScheduleMaxAggregateOutputType | null
  }

  type GetServiceScheduleGroupByPayload<T extends ServiceScheduleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceScheduleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceScheduleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceScheduleGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceScheduleGroupByOutputType[P]>
        }
      >
    >


  export type ServiceScheduleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dutyTemplates?: boolean | ServiceSchedule$dutyTemplatesArgs<ExtArgs>
    vehicleBlockTemplates?: boolean | ServiceSchedule$vehicleBlockTemplatesArgs<ExtArgs>
    driverRunTemplates?: boolean | ServiceSchedule$driverRunTemplatesArgs<ExtArgs>
    _count?: boolean | ServiceScheduleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceSchedule"]>

  export type ServiceScheduleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["serviceSchedule"]>

  export type ServiceScheduleSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ServiceScheduleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dutyTemplates?: boolean | ServiceSchedule$dutyTemplatesArgs<ExtArgs>
    vehicleBlockTemplates?: boolean | ServiceSchedule$vehicleBlockTemplatesArgs<ExtArgs>
    driverRunTemplates?: boolean | ServiceSchedule$driverRunTemplatesArgs<ExtArgs>
    _count?: boolean | ServiceScheduleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ServiceScheduleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ServiceSchedulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceSchedule"
    objects: {
      dutyTemplates: Prisma.$DutyTemplatePayload<ExtArgs>[]
      vehicleBlockTemplates: Prisma.$VehicleBlockTemplatePayload<ExtArgs>[]
      driverRunTemplates: Prisma.$DriverRunTemplatePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["serviceSchedule"]>
    composites: {}
  }

  type ServiceScheduleGetPayload<S extends boolean | null | undefined | ServiceScheduleDefaultArgs> = $Result.GetResult<Prisma.$ServiceSchedulePayload, S>

  type ServiceScheduleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ServiceScheduleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ServiceScheduleCountAggregateInputType | true
    }

  export interface ServiceScheduleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceSchedule'], meta: { name: 'ServiceSchedule' } }
    /**
     * Find zero or one ServiceSchedule that matches the filter.
     * @param {ServiceScheduleFindUniqueArgs} args - Arguments to find a ServiceSchedule
     * @example
     * // Get one ServiceSchedule
     * const serviceSchedule = await prisma.serviceSchedule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceScheduleFindUniqueArgs>(args: SelectSubset<T, ServiceScheduleFindUniqueArgs<ExtArgs>>): Prisma__ServiceScheduleClient<$Result.GetResult<Prisma.$ServiceSchedulePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ServiceSchedule that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ServiceScheduleFindUniqueOrThrowArgs} args - Arguments to find a ServiceSchedule
     * @example
     * // Get one ServiceSchedule
     * const serviceSchedule = await prisma.serviceSchedule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceScheduleFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceScheduleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceScheduleClient<$Result.GetResult<Prisma.$ServiceSchedulePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ServiceSchedule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceScheduleFindFirstArgs} args - Arguments to find a ServiceSchedule
     * @example
     * // Get one ServiceSchedule
     * const serviceSchedule = await prisma.serviceSchedule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceScheduleFindFirstArgs>(args?: SelectSubset<T, ServiceScheduleFindFirstArgs<ExtArgs>>): Prisma__ServiceScheduleClient<$Result.GetResult<Prisma.$ServiceSchedulePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ServiceSchedule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceScheduleFindFirstOrThrowArgs} args - Arguments to find a ServiceSchedule
     * @example
     * // Get one ServiceSchedule
     * const serviceSchedule = await prisma.serviceSchedule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceScheduleFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceScheduleFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceScheduleClient<$Result.GetResult<Prisma.$ServiceSchedulePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ServiceSchedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceScheduleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceSchedules
     * const serviceSchedules = await prisma.serviceSchedule.findMany()
     * 
     * // Get first 10 ServiceSchedules
     * const serviceSchedules = await prisma.serviceSchedule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceScheduleWithIdOnly = await prisma.serviceSchedule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceScheduleFindManyArgs>(args?: SelectSubset<T, ServiceScheduleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceSchedulePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ServiceSchedule.
     * @param {ServiceScheduleCreateArgs} args - Arguments to create a ServiceSchedule.
     * @example
     * // Create one ServiceSchedule
     * const ServiceSchedule = await prisma.serviceSchedule.create({
     *   data: {
     *     // ... data to create a ServiceSchedule
     *   }
     * })
     * 
     */
    create<T extends ServiceScheduleCreateArgs>(args: SelectSubset<T, ServiceScheduleCreateArgs<ExtArgs>>): Prisma__ServiceScheduleClient<$Result.GetResult<Prisma.$ServiceSchedulePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ServiceSchedules.
     * @param {ServiceScheduleCreateManyArgs} args - Arguments to create many ServiceSchedules.
     * @example
     * // Create many ServiceSchedules
     * const serviceSchedule = await prisma.serviceSchedule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceScheduleCreateManyArgs>(args?: SelectSubset<T, ServiceScheduleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServiceSchedules and returns the data saved in the database.
     * @param {ServiceScheduleCreateManyAndReturnArgs} args - Arguments to create many ServiceSchedules.
     * @example
     * // Create many ServiceSchedules
     * const serviceSchedule = await prisma.serviceSchedule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServiceSchedules and only return the `id`
     * const serviceScheduleWithIdOnly = await prisma.serviceSchedule.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceScheduleCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceScheduleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceSchedulePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ServiceSchedule.
     * @param {ServiceScheduleDeleteArgs} args - Arguments to delete one ServiceSchedule.
     * @example
     * // Delete one ServiceSchedule
     * const ServiceSchedule = await prisma.serviceSchedule.delete({
     *   where: {
     *     // ... filter to delete one ServiceSchedule
     *   }
     * })
     * 
     */
    delete<T extends ServiceScheduleDeleteArgs>(args: SelectSubset<T, ServiceScheduleDeleteArgs<ExtArgs>>): Prisma__ServiceScheduleClient<$Result.GetResult<Prisma.$ServiceSchedulePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ServiceSchedule.
     * @param {ServiceScheduleUpdateArgs} args - Arguments to update one ServiceSchedule.
     * @example
     * // Update one ServiceSchedule
     * const serviceSchedule = await prisma.serviceSchedule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceScheduleUpdateArgs>(args: SelectSubset<T, ServiceScheduleUpdateArgs<ExtArgs>>): Prisma__ServiceScheduleClient<$Result.GetResult<Prisma.$ServiceSchedulePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ServiceSchedules.
     * @param {ServiceScheduleDeleteManyArgs} args - Arguments to filter ServiceSchedules to delete.
     * @example
     * // Delete a few ServiceSchedules
     * const { count } = await prisma.serviceSchedule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceScheduleDeleteManyArgs>(args?: SelectSubset<T, ServiceScheduleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceScheduleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceSchedules
     * const serviceSchedule = await prisma.serviceSchedule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceScheduleUpdateManyArgs>(args: SelectSubset<T, ServiceScheduleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ServiceSchedule.
     * @param {ServiceScheduleUpsertArgs} args - Arguments to update or create a ServiceSchedule.
     * @example
     * // Update or create a ServiceSchedule
     * const serviceSchedule = await prisma.serviceSchedule.upsert({
     *   create: {
     *     // ... data to create a ServiceSchedule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceSchedule we want to update
     *   }
     * })
     */
    upsert<T extends ServiceScheduleUpsertArgs>(args: SelectSubset<T, ServiceScheduleUpsertArgs<ExtArgs>>): Prisma__ServiceScheduleClient<$Result.GetResult<Prisma.$ServiceSchedulePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ServiceSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceScheduleCountArgs} args - Arguments to filter ServiceSchedules to count.
     * @example
     * // Count the number of ServiceSchedules
     * const count = await prisma.serviceSchedule.count({
     *   where: {
     *     // ... the filter for the ServiceSchedules we want to count
     *   }
     * })
    **/
    count<T extends ServiceScheduleCountArgs>(
      args?: Subset<T, ServiceScheduleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceScheduleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceScheduleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceScheduleAggregateArgs>(args: Subset<T, ServiceScheduleAggregateArgs>): Prisma.PrismaPromise<GetServiceScheduleAggregateType<T>>

    /**
     * Group by ServiceSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceScheduleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceScheduleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceScheduleGroupByArgs['orderBy'] }
        : { orderBy?: ServiceScheduleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceScheduleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceScheduleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceSchedule model
   */
  readonly fields: ServiceScheduleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceSchedule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceScheduleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    dutyTemplates<T extends ServiceSchedule$dutyTemplatesArgs<ExtArgs> = {}>(args?: Subset<T, ServiceSchedule$dutyTemplatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DutyTemplatePayload<ExtArgs>, T, "findMany"> | Null>
    vehicleBlockTemplates<T extends ServiceSchedule$vehicleBlockTemplatesArgs<ExtArgs> = {}>(args?: Subset<T, ServiceSchedule$vehicleBlockTemplatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehicleBlockTemplatePayload<ExtArgs>, T, "findMany"> | Null>
    driverRunTemplates<T extends ServiceSchedule$driverRunTemplatesArgs<ExtArgs> = {}>(args?: Subset<T, ServiceSchedule$driverRunTemplatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DriverRunTemplatePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceSchedule model
   */ 
  interface ServiceScheduleFieldRefs {
    readonly id: FieldRef<"ServiceSchedule", 'BigInt'>
    readonly name: FieldRef<"ServiceSchedule", 'String'>
    readonly createdAt: FieldRef<"ServiceSchedule", 'DateTime'>
    readonly updatedAt: FieldRef<"ServiceSchedule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ServiceSchedule findUnique
   */
  export type ServiceScheduleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSchedule
     */
    select?: ServiceScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceScheduleInclude<ExtArgs> | null
    /**
     * Filter, which ServiceSchedule to fetch.
     */
    where: ServiceScheduleWhereUniqueInput
  }

  /**
   * ServiceSchedule findUniqueOrThrow
   */
  export type ServiceScheduleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSchedule
     */
    select?: ServiceScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceScheduleInclude<ExtArgs> | null
    /**
     * Filter, which ServiceSchedule to fetch.
     */
    where: ServiceScheduleWhereUniqueInput
  }

  /**
   * ServiceSchedule findFirst
   */
  export type ServiceScheduleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSchedule
     */
    select?: ServiceScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceScheduleInclude<ExtArgs> | null
    /**
     * Filter, which ServiceSchedule to fetch.
     */
    where?: ServiceScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceSchedules to fetch.
     */
    orderBy?: ServiceScheduleOrderByWithRelationInput | ServiceScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceSchedules.
     */
    cursor?: ServiceScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceSchedules.
     */
    distinct?: ServiceScheduleScalarFieldEnum | ServiceScheduleScalarFieldEnum[]
  }

  /**
   * ServiceSchedule findFirstOrThrow
   */
  export type ServiceScheduleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSchedule
     */
    select?: ServiceScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceScheduleInclude<ExtArgs> | null
    /**
     * Filter, which ServiceSchedule to fetch.
     */
    where?: ServiceScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceSchedules to fetch.
     */
    orderBy?: ServiceScheduleOrderByWithRelationInput | ServiceScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceSchedules.
     */
    cursor?: ServiceScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceSchedules.
     */
    distinct?: ServiceScheduleScalarFieldEnum | ServiceScheduleScalarFieldEnum[]
  }

  /**
   * ServiceSchedule findMany
   */
  export type ServiceScheduleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSchedule
     */
    select?: ServiceScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceScheduleInclude<ExtArgs> | null
    /**
     * Filter, which ServiceSchedules to fetch.
     */
    where?: ServiceScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceSchedules to fetch.
     */
    orderBy?: ServiceScheduleOrderByWithRelationInput | ServiceScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceSchedules.
     */
    cursor?: ServiceScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceSchedules.
     */
    skip?: number
    distinct?: ServiceScheduleScalarFieldEnum | ServiceScheduleScalarFieldEnum[]
  }

  /**
   * ServiceSchedule create
   */
  export type ServiceScheduleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSchedule
     */
    select?: ServiceScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceScheduleInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceSchedule.
     */
    data: XOR<ServiceScheduleCreateInput, ServiceScheduleUncheckedCreateInput>
  }

  /**
   * ServiceSchedule createMany
   */
  export type ServiceScheduleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceSchedules.
     */
    data: ServiceScheduleCreateManyInput | ServiceScheduleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceSchedule createManyAndReturn
   */
  export type ServiceScheduleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSchedule
     */
    select?: ServiceScheduleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ServiceSchedules.
     */
    data: ServiceScheduleCreateManyInput | ServiceScheduleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceSchedule update
   */
  export type ServiceScheduleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSchedule
     */
    select?: ServiceScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceScheduleInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceSchedule.
     */
    data: XOR<ServiceScheduleUpdateInput, ServiceScheduleUncheckedUpdateInput>
    /**
     * Choose, which ServiceSchedule to update.
     */
    where: ServiceScheduleWhereUniqueInput
  }

  /**
   * ServiceSchedule updateMany
   */
  export type ServiceScheduleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceSchedules.
     */
    data: XOR<ServiceScheduleUpdateManyMutationInput, ServiceScheduleUncheckedUpdateManyInput>
    /**
     * Filter which ServiceSchedules to update
     */
    where?: ServiceScheduleWhereInput
  }

  /**
   * ServiceSchedule upsert
   */
  export type ServiceScheduleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSchedule
     */
    select?: ServiceScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceScheduleInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceSchedule to update in case it exists.
     */
    where: ServiceScheduleWhereUniqueInput
    /**
     * In case the ServiceSchedule found by the `where` argument doesn't exist, create a new ServiceSchedule with this data.
     */
    create: XOR<ServiceScheduleCreateInput, ServiceScheduleUncheckedCreateInput>
    /**
     * In case the ServiceSchedule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceScheduleUpdateInput, ServiceScheduleUncheckedUpdateInput>
  }

  /**
   * ServiceSchedule delete
   */
  export type ServiceScheduleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSchedule
     */
    select?: ServiceScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceScheduleInclude<ExtArgs> | null
    /**
     * Filter which ServiceSchedule to delete.
     */
    where: ServiceScheduleWhereUniqueInput
  }

  /**
   * ServiceSchedule deleteMany
   */
  export type ServiceScheduleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceSchedules to delete
     */
    where?: ServiceScheduleWhereInput
  }

  /**
   * ServiceSchedule.dutyTemplates
   */
  export type ServiceSchedule$dutyTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DutyTemplate
     */
    select?: DutyTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DutyTemplateInclude<ExtArgs> | null
    where?: DutyTemplateWhereInput
    orderBy?: DutyTemplateOrderByWithRelationInput | DutyTemplateOrderByWithRelationInput[]
    cursor?: DutyTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DutyTemplateScalarFieldEnum | DutyTemplateScalarFieldEnum[]
  }

  /**
   * ServiceSchedule.vehicleBlockTemplates
   */
  export type ServiceSchedule$vehicleBlockTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleBlockTemplate
     */
    select?: VehicleBlockTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleBlockTemplateInclude<ExtArgs> | null
    where?: VehicleBlockTemplateWhereInput
    orderBy?: VehicleBlockTemplateOrderByWithRelationInput | VehicleBlockTemplateOrderByWithRelationInput[]
    cursor?: VehicleBlockTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VehicleBlockTemplateScalarFieldEnum | VehicleBlockTemplateScalarFieldEnum[]
  }

  /**
   * ServiceSchedule.driverRunTemplates
   */
  export type ServiceSchedule$driverRunTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverRunTemplate
     */
    select?: DriverRunTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverRunTemplateInclude<ExtArgs> | null
    where?: DriverRunTemplateWhereInput
    orderBy?: DriverRunTemplateOrderByWithRelationInput | DriverRunTemplateOrderByWithRelationInput[]
    cursor?: DriverRunTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DriverRunTemplateScalarFieldEnum | DriverRunTemplateScalarFieldEnum[]
  }

  /**
   * ServiceSchedule without action
   */
  export type ServiceScheduleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSchedule
     */
    select?: ServiceScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceScheduleInclude<ExtArgs> | null
  }


  /**
   * Model VehicleBlockTemplate
   */

  export type AggregateVehicleBlockTemplate = {
    _count: VehicleBlockTemplateCountAggregateOutputType | null
    _avg: VehicleBlockTemplateAvgAggregateOutputType | null
    _sum: VehicleBlockTemplateSumAggregateOutputType | null
    _min: VehicleBlockTemplateMinAggregateOutputType | null
    _max: VehicleBlockTemplateMaxAggregateOutputType | null
  }

  export type VehicleBlockTemplateAvgAggregateOutputType = {
    id: number | null
    scheduleId: number | null
  }

  export type VehicleBlockTemplateSumAggregateOutputType = {
    id: bigint | null
    scheduleId: bigint | null
  }

  export type VehicleBlockTemplateMinAggregateOutputType = {
    id: bigint | null
    scheduleId: bigint | null
    code: string | null
    color: string | null
  }

  export type VehicleBlockTemplateMaxAggregateOutputType = {
    id: bigint | null
    scheduleId: bigint | null
    code: string | null
    color: string | null
  }

  export type VehicleBlockTemplateCountAggregateOutputType = {
    id: number
    scheduleId: number
    code: number
    color: number
    _all: number
  }


  export type VehicleBlockTemplateAvgAggregateInputType = {
    id?: true
    scheduleId?: true
  }

  export type VehicleBlockTemplateSumAggregateInputType = {
    id?: true
    scheduleId?: true
  }

  export type VehicleBlockTemplateMinAggregateInputType = {
    id?: true
    scheduleId?: true
    code?: true
    color?: true
  }

  export type VehicleBlockTemplateMaxAggregateInputType = {
    id?: true
    scheduleId?: true
    code?: true
    color?: true
  }

  export type VehicleBlockTemplateCountAggregateInputType = {
    id?: true
    scheduleId?: true
    code?: true
    color?: true
    _all?: true
  }

  export type VehicleBlockTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VehicleBlockTemplate to aggregate.
     */
    where?: VehicleBlockTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleBlockTemplates to fetch.
     */
    orderBy?: VehicleBlockTemplateOrderByWithRelationInput | VehicleBlockTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VehicleBlockTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleBlockTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleBlockTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VehicleBlockTemplates
    **/
    _count?: true | VehicleBlockTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VehicleBlockTemplateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VehicleBlockTemplateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VehicleBlockTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VehicleBlockTemplateMaxAggregateInputType
  }

  export type GetVehicleBlockTemplateAggregateType<T extends VehicleBlockTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateVehicleBlockTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVehicleBlockTemplate[P]>
      : GetScalarType<T[P], AggregateVehicleBlockTemplate[P]>
  }




  export type VehicleBlockTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VehicleBlockTemplateWhereInput
    orderBy?: VehicleBlockTemplateOrderByWithAggregationInput | VehicleBlockTemplateOrderByWithAggregationInput[]
    by: VehicleBlockTemplateScalarFieldEnum[] | VehicleBlockTemplateScalarFieldEnum
    having?: VehicleBlockTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VehicleBlockTemplateCountAggregateInputType | true
    _avg?: VehicleBlockTemplateAvgAggregateInputType
    _sum?: VehicleBlockTemplateSumAggregateInputType
    _min?: VehicleBlockTemplateMinAggregateInputType
    _max?: VehicleBlockTemplateMaxAggregateInputType
  }

  export type VehicleBlockTemplateGroupByOutputType = {
    id: bigint
    scheduleId: bigint
    code: string
    color: string
    _count: VehicleBlockTemplateCountAggregateOutputType | null
    _avg: VehicleBlockTemplateAvgAggregateOutputType | null
    _sum: VehicleBlockTemplateSumAggregateOutputType | null
    _min: VehicleBlockTemplateMinAggregateOutputType | null
    _max: VehicleBlockTemplateMaxAggregateOutputType | null
  }

  type GetVehicleBlockTemplateGroupByPayload<T extends VehicleBlockTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VehicleBlockTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VehicleBlockTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VehicleBlockTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], VehicleBlockTemplateGroupByOutputType[P]>
        }
      >
    >


  export type VehicleBlockTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    scheduleId?: boolean
    code?: boolean
    color?: boolean
    schedule?: boolean | ServiceScheduleDefaultArgs<ExtArgs>
    DutyTemplate?: boolean | VehicleBlockTemplate$DutyTemplateArgs<ExtArgs>
    VehicleBlock?: boolean | VehicleBlockTemplate$VehicleBlockArgs<ExtArgs>
    _count?: boolean | VehicleBlockTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicleBlockTemplate"]>

  export type VehicleBlockTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    scheduleId?: boolean
    code?: boolean
    color?: boolean
    schedule?: boolean | ServiceScheduleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicleBlockTemplate"]>

  export type VehicleBlockTemplateSelectScalar = {
    id?: boolean
    scheduleId?: boolean
    code?: boolean
    color?: boolean
  }

  export type VehicleBlockTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    schedule?: boolean | ServiceScheduleDefaultArgs<ExtArgs>
    DutyTemplate?: boolean | VehicleBlockTemplate$DutyTemplateArgs<ExtArgs>
    VehicleBlock?: boolean | VehicleBlockTemplate$VehicleBlockArgs<ExtArgs>
    _count?: boolean | VehicleBlockTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VehicleBlockTemplateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    schedule?: boolean | ServiceScheduleDefaultArgs<ExtArgs>
  }

  export type $VehicleBlockTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VehicleBlockTemplate"
    objects: {
      schedule: Prisma.$ServiceSchedulePayload<ExtArgs>
      DutyTemplate: Prisma.$DutyTemplatePayload<ExtArgs>[]
      VehicleBlock: Prisma.$VehicleBlockPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      scheduleId: bigint
      code: string
      color: string
    }, ExtArgs["result"]["vehicleBlockTemplate"]>
    composites: {}
  }

  type VehicleBlockTemplateGetPayload<S extends boolean | null | undefined | VehicleBlockTemplateDefaultArgs> = $Result.GetResult<Prisma.$VehicleBlockTemplatePayload, S>

  type VehicleBlockTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VehicleBlockTemplateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VehicleBlockTemplateCountAggregateInputType | true
    }

  export interface VehicleBlockTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VehicleBlockTemplate'], meta: { name: 'VehicleBlockTemplate' } }
    /**
     * Find zero or one VehicleBlockTemplate that matches the filter.
     * @param {VehicleBlockTemplateFindUniqueArgs} args - Arguments to find a VehicleBlockTemplate
     * @example
     * // Get one VehicleBlockTemplate
     * const vehicleBlockTemplate = await prisma.vehicleBlockTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VehicleBlockTemplateFindUniqueArgs>(args: SelectSubset<T, VehicleBlockTemplateFindUniqueArgs<ExtArgs>>): Prisma__VehicleBlockTemplateClient<$Result.GetResult<Prisma.$VehicleBlockTemplatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one VehicleBlockTemplate that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VehicleBlockTemplateFindUniqueOrThrowArgs} args - Arguments to find a VehicleBlockTemplate
     * @example
     * // Get one VehicleBlockTemplate
     * const vehicleBlockTemplate = await prisma.vehicleBlockTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VehicleBlockTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, VehicleBlockTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VehicleBlockTemplateClient<$Result.GetResult<Prisma.$VehicleBlockTemplatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first VehicleBlockTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleBlockTemplateFindFirstArgs} args - Arguments to find a VehicleBlockTemplate
     * @example
     * // Get one VehicleBlockTemplate
     * const vehicleBlockTemplate = await prisma.vehicleBlockTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VehicleBlockTemplateFindFirstArgs>(args?: SelectSubset<T, VehicleBlockTemplateFindFirstArgs<ExtArgs>>): Prisma__VehicleBlockTemplateClient<$Result.GetResult<Prisma.$VehicleBlockTemplatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first VehicleBlockTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleBlockTemplateFindFirstOrThrowArgs} args - Arguments to find a VehicleBlockTemplate
     * @example
     * // Get one VehicleBlockTemplate
     * const vehicleBlockTemplate = await prisma.vehicleBlockTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VehicleBlockTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, VehicleBlockTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__VehicleBlockTemplateClient<$Result.GetResult<Prisma.$VehicleBlockTemplatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more VehicleBlockTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleBlockTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VehicleBlockTemplates
     * const vehicleBlockTemplates = await prisma.vehicleBlockTemplate.findMany()
     * 
     * // Get first 10 VehicleBlockTemplates
     * const vehicleBlockTemplates = await prisma.vehicleBlockTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vehicleBlockTemplateWithIdOnly = await prisma.vehicleBlockTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VehicleBlockTemplateFindManyArgs>(args?: SelectSubset<T, VehicleBlockTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehicleBlockTemplatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a VehicleBlockTemplate.
     * @param {VehicleBlockTemplateCreateArgs} args - Arguments to create a VehicleBlockTemplate.
     * @example
     * // Create one VehicleBlockTemplate
     * const VehicleBlockTemplate = await prisma.vehicleBlockTemplate.create({
     *   data: {
     *     // ... data to create a VehicleBlockTemplate
     *   }
     * })
     * 
     */
    create<T extends VehicleBlockTemplateCreateArgs>(args: SelectSubset<T, VehicleBlockTemplateCreateArgs<ExtArgs>>): Prisma__VehicleBlockTemplateClient<$Result.GetResult<Prisma.$VehicleBlockTemplatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many VehicleBlockTemplates.
     * @param {VehicleBlockTemplateCreateManyArgs} args - Arguments to create many VehicleBlockTemplates.
     * @example
     * // Create many VehicleBlockTemplates
     * const vehicleBlockTemplate = await prisma.vehicleBlockTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VehicleBlockTemplateCreateManyArgs>(args?: SelectSubset<T, VehicleBlockTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VehicleBlockTemplates and returns the data saved in the database.
     * @param {VehicleBlockTemplateCreateManyAndReturnArgs} args - Arguments to create many VehicleBlockTemplates.
     * @example
     * // Create many VehicleBlockTemplates
     * const vehicleBlockTemplate = await prisma.vehicleBlockTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VehicleBlockTemplates and only return the `id`
     * const vehicleBlockTemplateWithIdOnly = await prisma.vehicleBlockTemplate.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VehicleBlockTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, VehicleBlockTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehicleBlockTemplatePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a VehicleBlockTemplate.
     * @param {VehicleBlockTemplateDeleteArgs} args - Arguments to delete one VehicleBlockTemplate.
     * @example
     * // Delete one VehicleBlockTemplate
     * const VehicleBlockTemplate = await prisma.vehicleBlockTemplate.delete({
     *   where: {
     *     // ... filter to delete one VehicleBlockTemplate
     *   }
     * })
     * 
     */
    delete<T extends VehicleBlockTemplateDeleteArgs>(args: SelectSubset<T, VehicleBlockTemplateDeleteArgs<ExtArgs>>): Prisma__VehicleBlockTemplateClient<$Result.GetResult<Prisma.$VehicleBlockTemplatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one VehicleBlockTemplate.
     * @param {VehicleBlockTemplateUpdateArgs} args - Arguments to update one VehicleBlockTemplate.
     * @example
     * // Update one VehicleBlockTemplate
     * const vehicleBlockTemplate = await prisma.vehicleBlockTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VehicleBlockTemplateUpdateArgs>(args: SelectSubset<T, VehicleBlockTemplateUpdateArgs<ExtArgs>>): Prisma__VehicleBlockTemplateClient<$Result.GetResult<Prisma.$VehicleBlockTemplatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more VehicleBlockTemplates.
     * @param {VehicleBlockTemplateDeleteManyArgs} args - Arguments to filter VehicleBlockTemplates to delete.
     * @example
     * // Delete a few VehicleBlockTemplates
     * const { count } = await prisma.vehicleBlockTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VehicleBlockTemplateDeleteManyArgs>(args?: SelectSubset<T, VehicleBlockTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VehicleBlockTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleBlockTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VehicleBlockTemplates
     * const vehicleBlockTemplate = await prisma.vehicleBlockTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VehicleBlockTemplateUpdateManyArgs>(args: SelectSubset<T, VehicleBlockTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VehicleBlockTemplate.
     * @param {VehicleBlockTemplateUpsertArgs} args - Arguments to update or create a VehicleBlockTemplate.
     * @example
     * // Update or create a VehicleBlockTemplate
     * const vehicleBlockTemplate = await prisma.vehicleBlockTemplate.upsert({
     *   create: {
     *     // ... data to create a VehicleBlockTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VehicleBlockTemplate we want to update
     *   }
     * })
     */
    upsert<T extends VehicleBlockTemplateUpsertArgs>(args: SelectSubset<T, VehicleBlockTemplateUpsertArgs<ExtArgs>>): Prisma__VehicleBlockTemplateClient<$Result.GetResult<Prisma.$VehicleBlockTemplatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of VehicleBlockTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleBlockTemplateCountArgs} args - Arguments to filter VehicleBlockTemplates to count.
     * @example
     * // Count the number of VehicleBlockTemplates
     * const count = await prisma.vehicleBlockTemplate.count({
     *   where: {
     *     // ... the filter for the VehicleBlockTemplates we want to count
     *   }
     * })
    **/
    count<T extends VehicleBlockTemplateCountArgs>(
      args?: Subset<T, VehicleBlockTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VehicleBlockTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VehicleBlockTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleBlockTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VehicleBlockTemplateAggregateArgs>(args: Subset<T, VehicleBlockTemplateAggregateArgs>): Prisma.PrismaPromise<GetVehicleBlockTemplateAggregateType<T>>

    /**
     * Group by VehicleBlockTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleBlockTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VehicleBlockTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VehicleBlockTemplateGroupByArgs['orderBy'] }
        : { orderBy?: VehicleBlockTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VehicleBlockTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVehicleBlockTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VehicleBlockTemplate model
   */
  readonly fields: VehicleBlockTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VehicleBlockTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VehicleBlockTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    schedule<T extends ServiceScheduleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceScheduleDefaultArgs<ExtArgs>>): Prisma__ServiceScheduleClient<$Result.GetResult<Prisma.$ServiceSchedulePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    DutyTemplate<T extends VehicleBlockTemplate$DutyTemplateArgs<ExtArgs> = {}>(args?: Subset<T, VehicleBlockTemplate$DutyTemplateArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DutyTemplatePayload<ExtArgs>, T, "findMany"> | Null>
    VehicleBlock<T extends VehicleBlockTemplate$VehicleBlockArgs<ExtArgs> = {}>(args?: Subset<T, VehicleBlockTemplate$VehicleBlockArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehicleBlockPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VehicleBlockTemplate model
   */ 
  interface VehicleBlockTemplateFieldRefs {
    readonly id: FieldRef<"VehicleBlockTemplate", 'BigInt'>
    readonly scheduleId: FieldRef<"VehicleBlockTemplate", 'BigInt'>
    readonly code: FieldRef<"VehicleBlockTemplate", 'String'>
    readonly color: FieldRef<"VehicleBlockTemplate", 'String'>
  }
    

  // Custom InputTypes
  /**
   * VehicleBlockTemplate findUnique
   */
  export type VehicleBlockTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleBlockTemplate
     */
    select?: VehicleBlockTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleBlockTemplateInclude<ExtArgs> | null
    /**
     * Filter, which VehicleBlockTemplate to fetch.
     */
    where: VehicleBlockTemplateWhereUniqueInput
  }

  /**
   * VehicleBlockTemplate findUniqueOrThrow
   */
  export type VehicleBlockTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleBlockTemplate
     */
    select?: VehicleBlockTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleBlockTemplateInclude<ExtArgs> | null
    /**
     * Filter, which VehicleBlockTemplate to fetch.
     */
    where: VehicleBlockTemplateWhereUniqueInput
  }

  /**
   * VehicleBlockTemplate findFirst
   */
  export type VehicleBlockTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleBlockTemplate
     */
    select?: VehicleBlockTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleBlockTemplateInclude<ExtArgs> | null
    /**
     * Filter, which VehicleBlockTemplate to fetch.
     */
    where?: VehicleBlockTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleBlockTemplates to fetch.
     */
    orderBy?: VehicleBlockTemplateOrderByWithRelationInput | VehicleBlockTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VehicleBlockTemplates.
     */
    cursor?: VehicleBlockTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleBlockTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleBlockTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VehicleBlockTemplates.
     */
    distinct?: VehicleBlockTemplateScalarFieldEnum | VehicleBlockTemplateScalarFieldEnum[]
  }

  /**
   * VehicleBlockTemplate findFirstOrThrow
   */
  export type VehicleBlockTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleBlockTemplate
     */
    select?: VehicleBlockTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleBlockTemplateInclude<ExtArgs> | null
    /**
     * Filter, which VehicleBlockTemplate to fetch.
     */
    where?: VehicleBlockTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleBlockTemplates to fetch.
     */
    orderBy?: VehicleBlockTemplateOrderByWithRelationInput | VehicleBlockTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VehicleBlockTemplates.
     */
    cursor?: VehicleBlockTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleBlockTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleBlockTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VehicleBlockTemplates.
     */
    distinct?: VehicleBlockTemplateScalarFieldEnum | VehicleBlockTemplateScalarFieldEnum[]
  }

  /**
   * VehicleBlockTemplate findMany
   */
  export type VehicleBlockTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleBlockTemplate
     */
    select?: VehicleBlockTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleBlockTemplateInclude<ExtArgs> | null
    /**
     * Filter, which VehicleBlockTemplates to fetch.
     */
    where?: VehicleBlockTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleBlockTemplates to fetch.
     */
    orderBy?: VehicleBlockTemplateOrderByWithRelationInput | VehicleBlockTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VehicleBlockTemplates.
     */
    cursor?: VehicleBlockTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleBlockTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleBlockTemplates.
     */
    skip?: number
    distinct?: VehicleBlockTemplateScalarFieldEnum | VehicleBlockTemplateScalarFieldEnum[]
  }

  /**
   * VehicleBlockTemplate create
   */
  export type VehicleBlockTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleBlockTemplate
     */
    select?: VehicleBlockTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleBlockTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a VehicleBlockTemplate.
     */
    data: XOR<VehicleBlockTemplateCreateInput, VehicleBlockTemplateUncheckedCreateInput>
  }

  /**
   * VehicleBlockTemplate createMany
   */
  export type VehicleBlockTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VehicleBlockTemplates.
     */
    data: VehicleBlockTemplateCreateManyInput | VehicleBlockTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VehicleBlockTemplate createManyAndReturn
   */
  export type VehicleBlockTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleBlockTemplate
     */
    select?: VehicleBlockTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many VehicleBlockTemplates.
     */
    data: VehicleBlockTemplateCreateManyInput | VehicleBlockTemplateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleBlockTemplateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VehicleBlockTemplate update
   */
  export type VehicleBlockTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleBlockTemplate
     */
    select?: VehicleBlockTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleBlockTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a VehicleBlockTemplate.
     */
    data: XOR<VehicleBlockTemplateUpdateInput, VehicleBlockTemplateUncheckedUpdateInput>
    /**
     * Choose, which VehicleBlockTemplate to update.
     */
    where: VehicleBlockTemplateWhereUniqueInput
  }

  /**
   * VehicleBlockTemplate updateMany
   */
  export type VehicleBlockTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VehicleBlockTemplates.
     */
    data: XOR<VehicleBlockTemplateUpdateManyMutationInput, VehicleBlockTemplateUncheckedUpdateManyInput>
    /**
     * Filter which VehicleBlockTemplates to update
     */
    where?: VehicleBlockTemplateWhereInput
  }

  /**
   * VehicleBlockTemplate upsert
   */
  export type VehicleBlockTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleBlockTemplate
     */
    select?: VehicleBlockTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleBlockTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the VehicleBlockTemplate to update in case it exists.
     */
    where: VehicleBlockTemplateWhereUniqueInput
    /**
     * In case the VehicleBlockTemplate found by the `where` argument doesn't exist, create a new VehicleBlockTemplate with this data.
     */
    create: XOR<VehicleBlockTemplateCreateInput, VehicleBlockTemplateUncheckedCreateInput>
    /**
     * In case the VehicleBlockTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VehicleBlockTemplateUpdateInput, VehicleBlockTemplateUncheckedUpdateInput>
  }

  /**
   * VehicleBlockTemplate delete
   */
  export type VehicleBlockTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleBlockTemplate
     */
    select?: VehicleBlockTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleBlockTemplateInclude<ExtArgs> | null
    /**
     * Filter which VehicleBlockTemplate to delete.
     */
    where: VehicleBlockTemplateWhereUniqueInput
  }

  /**
   * VehicleBlockTemplate deleteMany
   */
  export type VehicleBlockTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VehicleBlockTemplates to delete
     */
    where?: VehicleBlockTemplateWhereInput
  }

  /**
   * VehicleBlockTemplate.DutyTemplate
   */
  export type VehicleBlockTemplate$DutyTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DutyTemplate
     */
    select?: DutyTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DutyTemplateInclude<ExtArgs> | null
    where?: DutyTemplateWhereInput
    orderBy?: DutyTemplateOrderByWithRelationInput | DutyTemplateOrderByWithRelationInput[]
    cursor?: DutyTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DutyTemplateScalarFieldEnum | DutyTemplateScalarFieldEnum[]
  }

  /**
   * VehicleBlockTemplate.VehicleBlock
   */
  export type VehicleBlockTemplate$VehicleBlockArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleBlock
     */
    select?: VehicleBlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleBlockInclude<ExtArgs> | null
    where?: VehicleBlockWhereInput
    orderBy?: VehicleBlockOrderByWithRelationInput | VehicleBlockOrderByWithRelationInput[]
    cursor?: VehicleBlockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VehicleBlockScalarFieldEnum | VehicleBlockScalarFieldEnum[]
  }

  /**
   * VehicleBlockTemplate without action
   */
  export type VehicleBlockTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleBlockTemplate
     */
    select?: VehicleBlockTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleBlockTemplateInclude<ExtArgs> | null
  }


  /**
   * Model DriverRunTemplate
   */

  export type AggregateDriverRunTemplate = {
    _count: DriverRunTemplateCountAggregateOutputType | null
    _avg: DriverRunTemplateAvgAggregateOutputType | null
    _sum: DriverRunTemplateSumAggregateOutputType | null
    _min: DriverRunTemplateMinAggregateOutputType | null
    _max: DriverRunTemplateMaxAggregateOutputType | null
  }

  export type DriverRunTemplateAvgAggregateOutputType = {
    id: number | null
    scheduleId: number | null
  }

  export type DriverRunTemplateSumAggregateOutputType = {
    id: bigint | null
    scheduleId: bigint | null
  }

  export type DriverRunTemplateMinAggregateOutputType = {
    id: bigint | null
    scheduleId: bigint | null
    code: string | null
    color: string | null
  }

  export type DriverRunTemplateMaxAggregateOutputType = {
    id: bigint | null
    scheduleId: bigint | null
    code: string | null
    color: string | null
  }

  export type DriverRunTemplateCountAggregateOutputType = {
    id: number
    scheduleId: number
    code: number
    color: number
    _all: number
  }


  export type DriverRunTemplateAvgAggregateInputType = {
    id?: true
    scheduleId?: true
  }

  export type DriverRunTemplateSumAggregateInputType = {
    id?: true
    scheduleId?: true
  }

  export type DriverRunTemplateMinAggregateInputType = {
    id?: true
    scheduleId?: true
    code?: true
    color?: true
  }

  export type DriverRunTemplateMaxAggregateInputType = {
    id?: true
    scheduleId?: true
    code?: true
    color?: true
  }

  export type DriverRunTemplateCountAggregateInputType = {
    id?: true
    scheduleId?: true
    code?: true
    color?: true
    _all?: true
  }

  export type DriverRunTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DriverRunTemplate to aggregate.
     */
    where?: DriverRunTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DriverRunTemplates to fetch.
     */
    orderBy?: DriverRunTemplateOrderByWithRelationInput | DriverRunTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DriverRunTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DriverRunTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DriverRunTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DriverRunTemplates
    **/
    _count?: true | DriverRunTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DriverRunTemplateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DriverRunTemplateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DriverRunTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DriverRunTemplateMaxAggregateInputType
  }

  export type GetDriverRunTemplateAggregateType<T extends DriverRunTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateDriverRunTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDriverRunTemplate[P]>
      : GetScalarType<T[P], AggregateDriverRunTemplate[P]>
  }




  export type DriverRunTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DriverRunTemplateWhereInput
    orderBy?: DriverRunTemplateOrderByWithAggregationInput | DriverRunTemplateOrderByWithAggregationInput[]
    by: DriverRunTemplateScalarFieldEnum[] | DriverRunTemplateScalarFieldEnum
    having?: DriverRunTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DriverRunTemplateCountAggregateInputType | true
    _avg?: DriverRunTemplateAvgAggregateInputType
    _sum?: DriverRunTemplateSumAggregateInputType
    _min?: DriverRunTemplateMinAggregateInputType
    _max?: DriverRunTemplateMaxAggregateInputType
  }

  export type DriverRunTemplateGroupByOutputType = {
    id: bigint
    scheduleId: bigint
    code: string
    color: string
    _count: DriverRunTemplateCountAggregateOutputType | null
    _avg: DriverRunTemplateAvgAggregateOutputType | null
    _sum: DriverRunTemplateSumAggregateOutputType | null
    _min: DriverRunTemplateMinAggregateOutputType | null
    _max: DriverRunTemplateMaxAggregateOutputType | null
  }

  type GetDriverRunTemplateGroupByPayload<T extends DriverRunTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DriverRunTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DriverRunTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DriverRunTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], DriverRunTemplateGroupByOutputType[P]>
        }
      >
    >


  export type DriverRunTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    scheduleId?: boolean
    code?: boolean
    color?: boolean
    schedule?: boolean | ServiceScheduleDefaultArgs<ExtArgs>
    DutyTemplate?: boolean | DriverRunTemplate$DutyTemplateArgs<ExtArgs>
    DriverRun?: boolean | DriverRunTemplate$DriverRunArgs<ExtArgs>
    _count?: boolean | DriverRunTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["driverRunTemplate"]>

  export type DriverRunTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    scheduleId?: boolean
    code?: boolean
    color?: boolean
    schedule?: boolean | ServiceScheduleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["driverRunTemplate"]>

  export type DriverRunTemplateSelectScalar = {
    id?: boolean
    scheduleId?: boolean
    code?: boolean
    color?: boolean
  }

  export type DriverRunTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    schedule?: boolean | ServiceScheduleDefaultArgs<ExtArgs>
    DutyTemplate?: boolean | DriverRunTemplate$DutyTemplateArgs<ExtArgs>
    DriverRun?: boolean | DriverRunTemplate$DriverRunArgs<ExtArgs>
    _count?: boolean | DriverRunTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DriverRunTemplateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    schedule?: boolean | ServiceScheduleDefaultArgs<ExtArgs>
  }

  export type $DriverRunTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DriverRunTemplate"
    objects: {
      schedule: Prisma.$ServiceSchedulePayload<ExtArgs>
      DutyTemplate: Prisma.$DutyTemplatePayload<ExtArgs>[]
      DriverRun: Prisma.$DriverRunPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      scheduleId: bigint
      code: string
      color: string
    }, ExtArgs["result"]["driverRunTemplate"]>
    composites: {}
  }

  type DriverRunTemplateGetPayload<S extends boolean | null | undefined | DriverRunTemplateDefaultArgs> = $Result.GetResult<Prisma.$DriverRunTemplatePayload, S>

  type DriverRunTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DriverRunTemplateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DriverRunTemplateCountAggregateInputType | true
    }

  export interface DriverRunTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DriverRunTemplate'], meta: { name: 'DriverRunTemplate' } }
    /**
     * Find zero or one DriverRunTemplate that matches the filter.
     * @param {DriverRunTemplateFindUniqueArgs} args - Arguments to find a DriverRunTemplate
     * @example
     * // Get one DriverRunTemplate
     * const driverRunTemplate = await prisma.driverRunTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DriverRunTemplateFindUniqueArgs>(args: SelectSubset<T, DriverRunTemplateFindUniqueArgs<ExtArgs>>): Prisma__DriverRunTemplateClient<$Result.GetResult<Prisma.$DriverRunTemplatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DriverRunTemplate that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DriverRunTemplateFindUniqueOrThrowArgs} args - Arguments to find a DriverRunTemplate
     * @example
     * // Get one DriverRunTemplate
     * const driverRunTemplate = await prisma.driverRunTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DriverRunTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, DriverRunTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DriverRunTemplateClient<$Result.GetResult<Prisma.$DriverRunTemplatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DriverRunTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverRunTemplateFindFirstArgs} args - Arguments to find a DriverRunTemplate
     * @example
     * // Get one DriverRunTemplate
     * const driverRunTemplate = await prisma.driverRunTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DriverRunTemplateFindFirstArgs>(args?: SelectSubset<T, DriverRunTemplateFindFirstArgs<ExtArgs>>): Prisma__DriverRunTemplateClient<$Result.GetResult<Prisma.$DriverRunTemplatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DriverRunTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverRunTemplateFindFirstOrThrowArgs} args - Arguments to find a DriverRunTemplate
     * @example
     * // Get one DriverRunTemplate
     * const driverRunTemplate = await prisma.driverRunTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DriverRunTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, DriverRunTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__DriverRunTemplateClient<$Result.GetResult<Prisma.$DriverRunTemplatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DriverRunTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverRunTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DriverRunTemplates
     * const driverRunTemplates = await prisma.driverRunTemplate.findMany()
     * 
     * // Get first 10 DriverRunTemplates
     * const driverRunTemplates = await prisma.driverRunTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const driverRunTemplateWithIdOnly = await prisma.driverRunTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DriverRunTemplateFindManyArgs>(args?: SelectSubset<T, DriverRunTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DriverRunTemplatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DriverRunTemplate.
     * @param {DriverRunTemplateCreateArgs} args - Arguments to create a DriverRunTemplate.
     * @example
     * // Create one DriverRunTemplate
     * const DriverRunTemplate = await prisma.driverRunTemplate.create({
     *   data: {
     *     // ... data to create a DriverRunTemplate
     *   }
     * })
     * 
     */
    create<T extends DriverRunTemplateCreateArgs>(args: SelectSubset<T, DriverRunTemplateCreateArgs<ExtArgs>>): Prisma__DriverRunTemplateClient<$Result.GetResult<Prisma.$DriverRunTemplatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DriverRunTemplates.
     * @param {DriverRunTemplateCreateManyArgs} args - Arguments to create many DriverRunTemplates.
     * @example
     * // Create many DriverRunTemplates
     * const driverRunTemplate = await prisma.driverRunTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DriverRunTemplateCreateManyArgs>(args?: SelectSubset<T, DriverRunTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DriverRunTemplates and returns the data saved in the database.
     * @param {DriverRunTemplateCreateManyAndReturnArgs} args - Arguments to create many DriverRunTemplates.
     * @example
     * // Create many DriverRunTemplates
     * const driverRunTemplate = await prisma.driverRunTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DriverRunTemplates and only return the `id`
     * const driverRunTemplateWithIdOnly = await prisma.driverRunTemplate.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DriverRunTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, DriverRunTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DriverRunTemplatePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DriverRunTemplate.
     * @param {DriverRunTemplateDeleteArgs} args - Arguments to delete one DriverRunTemplate.
     * @example
     * // Delete one DriverRunTemplate
     * const DriverRunTemplate = await prisma.driverRunTemplate.delete({
     *   where: {
     *     // ... filter to delete one DriverRunTemplate
     *   }
     * })
     * 
     */
    delete<T extends DriverRunTemplateDeleteArgs>(args: SelectSubset<T, DriverRunTemplateDeleteArgs<ExtArgs>>): Prisma__DriverRunTemplateClient<$Result.GetResult<Prisma.$DriverRunTemplatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DriverRunTemplate.
     * @param {DriverRunTemplateUpdateArgs} args - Arguments to update one DriverRunTemplate.
     * @example
     * // Update one DriverRunTemplate
     * const driverRunTemplate = await prisma.driverRunTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DriverRunTemplateUpdateArgs>(args: SelectSubset<T, DriverRunTemplateUpdateArgs<ExtArgs>>): Prisma__DriverRunTemplateClient<$Result.GetResult<Prisma.$DriverRunTemplatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DriverRunTemplates.
     * @param {DriverRunTemplateDeleteManyArgs} args - Arguments to filter DriverRunTemplates to delete.
     * @example
     * // Delete a few DriverRunTemplates
     * const { count } = await prisma.driverRunTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DriverRunTemplateDeleteManyArgs>(args?: SelectSubset<T, DriverRunTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DriverRunTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverRunTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DriverRunTemplates
     * const driverRunTemplate = await prisma.driverRunTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DriverRunTemplateUpdateManyArgs>(args: SelectSubset<T, DriverRunTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DriverRunTemplate.
     * @param {DriverRunTemplateUpsertArgs} args - Arguments to update or create a DriverRunTemplate.
     * @example
     * // Update or create a DriverRunTemplate
     * const driverRunTemplate = await prisma.driverRunTemplate.upsert({
     *   create: {
     *     // ... data to create a DriverRunTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DriverRunTemplate we want to update
     *   }
     * })
     */
    upsert<T extends DriverRunTemplateUpsertArgs>(args: SelectSubset<T, DriverRunTemplateUpsertArgs<ExtArgs>>): Prisma__DriverRunTemplateClient<$Result.GetResult<Prisma.$DriverRunTemplatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DriverRunTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverRunTemplateCountArgs} args - Arguments to filter DriverRunTemplates to count.
     * @example
     * // Count the number of DriverRunTemplates
     * const count = await prisma.driverRunTemplate.count({
     *   where: {
     *     // ... the filter for the DriverRunTemplates we want to count
     *   }
     * })
    **/
    count<T extends DriverRunTemplateCountArgs>(
      args?: Subset<T, DriverRunTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DriverRunTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DriverRunTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverRunTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DriverRunTemplateAggregateArgs>(args: Subset<T, DriverRunTemplateAggregateArgs>): Prisma.PrismaPromise<GetDriverRunTemplateAggregateType<T>>

    /**
     * Group by DriverRunTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverRunTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DriverRunTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DriverRunTemplateGroupByArgs['orderBy'] }
        : { orderBy?: DriverRunTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DriverRunTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDriverRunTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DriverRunTemplate model
   */
  readonly fields: DriverRunTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DriverRunTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DriverRunTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    schedule<T extends ServiceScheduleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceScheduleDefaultArgs<ExtArgs>>): Prisma__ServiceScheduleClient<$Result.GetResult<Prisma.$ServiceSchedulePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    DutyTemplate<T extends DriverRunTemplate$DutyTemplateArgs<ExtArgs> = {}>(args?: Subset<T, DriverRunTemplate$DutyTemplateArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DutyTemplatePayload<ExtArgs>, T, "findMany"> | Null>
    DriverRun<T extends DriverRunTemplate$DriverRunArgs<ExtArgs> = {}>(args?: Subset<T, DriverRunTemplate$DriverRunArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DriverRunPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DriverRunTemplate model
   */ 
  interface DriverRunTemplateFieldRefs {
    readonly id: FieldRef<"DriverRunTemplate", 'BigInt'>
    readonly scheduleId: FieldRef<"DriverRunTemplate", 'BigInt'>
    readonly code: FieldRef<"DriverRunTemplate", 'String'>
    readonly color: FieldRef<"DriverRunTemplate", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DriverRunTemplate findUnique
   */
  export type DriverRunTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverRunTemplate
     */
    select?: DriverRunTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverRunTemplateInclude<ExtArgs> | null
    /**
     * Filter, which DriverRunTemplate to fetch.
     */
    where: DriverRunTemplateWhereUniqueInput
  }

  /**
   * DriverRunTemplate findUniqueOrThrow
   */
  export type DriverRunTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverRunTemplate
     */
    select?: DriverRunTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverRunTemplateInclude<ExtArgs> | null
    /**
     * Filter, which DriverRunTemplate to fetch.
     */
    where: DriverRunTemplateWhereUniqueInput
  }

  /**
   * DriverRunTemplate findFirst
   */
  export type DriverRunTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverRunTemplate
     */
    select?: DriverRunTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverRunTemplateInclude<ExtArgs> | null
    /**
     * Filter, which DriverRunTemplate to fetch.
     */
    where?: DriverRunTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DriverRunTemplates to fetch.
     */
    orderBy?: DriverRunTemplateOrderByWithRelationInput | DriverRunTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DriverRunTemplates.
     */
    cursor?: DriverRunTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DriverRunTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DriverRunTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DriverRunTemplates.
     */
    distinct?: DriverRunTemplateScalarFieldEnum | DriverRunTemplateScalarFieldEnum[]
  }

  /**
   * DriverRunTemplate findFirstOrThrow
   */
  export type DriverRunTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverRunTemplate
     */
    select?: DriverRunTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverRunTemplateInclude<ExtArgs> | null
    /**
     * Filter, which DriverRunTemplate to fetch.
     */
    where?: DriverRunTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DriverRunTemplates to fetch.
     */
    orderBy?: DriverRunTemplateOrderByWithRelationInput | DriverRunTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DriverRunTemplates.
     */
    cursor?: DriverRunTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DriverRunTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DriverRunTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DriverRunTemplates.
     */
    distinct?: DriverRunTemplateScalarFieldEnum | DriverRunTemplateScalarFieldEnum[]
  }

  /**
   * DriverRunTemplate findMany
   */
  export type DriverRunTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverRunTemplate
     */
    select?: DriverRunTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverRunTemplateInclude<ExtArgs> | null
    /**
     * Filter, which DriverRunTemplates to fetch.
     */
    where?: DriverRunTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DriverRunTemplates to fetch.
     */
    orderBy?: DriverRunTemplateOrderByWithRelationInput | DriverRunTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DriverRunTemplates.
     */
    cursor?: DriverRunTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DriverRunTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DriverRunTemplates.
     */
    skip?: number
    distinct?: DriverRunTemplateScalarFieldEnum | DriverRunTemplateScalarFieldEnum[]
  }

  /**
   * DriverRunTemplate create
   */
  export type DriverRunTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverRunTemplate
     */
    select?: DriverRunTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverRunTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a DriverRunTemplate.
     */
    data: XOR<DriverRunTemplateCreateInput, DriverRunTemplateUncheckedCreateInput>
  }

  /**
   * DriverRunTemplate createMany
   */
  export type DriverRunTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DriverRunTemplates.
     */
    data: DriverRunTemplateCreateManyInput | DriverRunTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DriverRunTemplate createManyAndReturn
   */
  export type DriverRunTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverRunTemplate
     */
    select?: DriverRunTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DriverRunTemplates.
     */
    data: DriverRunTemplateCreateManyInput | DriverRunTemplateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverRunTemplateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DriverRunTemplate update
   */
  export type DriverRunTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverRunTemplate
     */
    select?: DriverRunTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverRunTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a DriverRunTemplate.
     */
    data: XOR<DriverRunTemplateUpdateInput, DriverRunTemplateUncheckedUpdateInput>
    /**
     * Choose, which DriverRunTemplate to update.
     */
    where: DriverRunTemplateWhereUniqueInput
  }

  /**
   * DriverRunTemplate updateMany
   */
  export type DriverRunTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DriverRunTemplates.
     */
    data: XOR<DriverRunTemplateUpdateManyMutationInput, DriverRunTemplateUncheckedUpdateManyInput>
    /**
     * Filter which DriverRunTemplates to update
     */
    where?: DriverRunTemplateWhereInput
  }

  /**
   * DriverRunTemplate upsert
   */
  export type DriverRunTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverRunTemplate
     */
    select?: DriverRunTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverRunTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the DriverRunTemplate to update in case it exists.
     */
    where: DriverRunTemplateWhereUniqueInput
    /**
     * In case the DriverRunTemplate found by the `where` argument doesn't exist, create a new DriverRunTemplate with this data.
     */
    create: XOR<DriverRunTemplateCreateInput, DriverRunTemplateUncheckedCreateInput>
    /**
     * In case the DriverRunTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DriverRunTemplateUpdateInput, DriverRunTemplateUncheckedUpdateInput>
  }

  /**
   * DriverRunTemplate delete
   */
  export type DriverRunTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverRunTemplate
     */
    select?: DriverRunTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverRunTemplateInclude<ExtArgs> | null
    /**
     * Filter which DriverRunTemplate to delete.
     */
    where: DriverRunTemplateWhereUniqueInput
  }

  /**
   * DriverRunTemplate deleteMany
   */
  export type DriverRunTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DriverRunTemplates to delete
     */
    where?: DriverRunTemplateWhereInput
  }

  /**
   * DriverRunTemplate.DutyTemplate
   */
  export type DriverRunTemplate$DutyTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DutyTemplate
     */
    select?: DutyTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DutyTemplateInclude<ExtArgs> | null
    where?: DutyTemplateWhereInput
    orderBy?: DutyTemplateOrderByWithRelationInput | DutyTemplateOrderByWithRelationInput[]
    cursor?: DutyTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DutyTemplateScalarFieldEnum | DutyTemplateScalarFieldEnum[]
  }

  /**
   * DriverRunTemplate.DriverRun
   */
  export type DriverRunTemplate$DriverRunArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverRun
     */
    select?: DriverRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverRunInclude<ExtArgs> | null
    where?: DriverRunWhereInput
    orderBy?: DriverRunOrderByWithRelationInput | DriverRunOrderByWithRelationInput[]
    cursor?: DriverRunWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DriverRunScalarFieldEnum | DriverRunScalarFieldEnum[]
  }

  /**
   * DriverRunTemplate without action
   */
  export type DriverRunTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverRunTemplate
     */
    select?: DriverRunTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverRunTemplateInclude<ExtArgs> | null
  }


  /**
   * Model DutyTemplate
   */

  export type AggregateDutyTemplate = {
    _count: DutyTemplateCountAggregateOutputType | null
    _avg: DutyTemplateAvgAggregateOutputType | null
    _sum: DutyTemplateSumAggregateOutputType | null
    _min: DutyTemplateMinAggregateOutputType | null
    _max: DutyTemplateMaxAggregateOutputType | null
  }

  export type DutyTemplateAvgAggregateOutputType = {
    id: number | null
    vehicleBlockTemplateId: number | null
    driverRunTemplateId: number | null
    scheduleId: number | null
  }

  export type DutyTemplateSumAggregateOutputType = {
    id: bigint | null
    vehicleBlockTemplateId: bigint | null
    driverRunTemplateId: bigint | null
    scheduleId: bigint | null
  }

  export type DutyTemplateMinAggregateOutputType = {
    id: bigint | null
    name: string | null
    startTime: Date | null
    endTime: Date | null
    dutyType: $Enums.DutyType | null
    vehicleBlockTemplateId: bigint | null
    driverRunTemplateId: bigint | null
    scheduleId: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DutyTemplateMaxAggregateOutputType = {
    id: bigint | null
    name: string | null
    startTime: Date | null
    endTime: Date | null
    dutyType: $Enums.DutyType | null
    vehicleBlockTemplateId: bigint | null
    driverRunTemplateId: bigint | null
    scheduleId: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DutyTemplateCountAggregateOutputType = {
    id: number
    name: number
    startTime: number
    endTime: number
    dutyType: number
    vehicleBlockTemplateId: number
    driverRunTemplateId: number
    scheduleId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DutyTemplateAvgAggregateInputType = {
    id?: true
    vehicleBlockTemplateId?: true
    driverRunTemplateId?: true
    scheduleId?: true
  }

  export type DutyTemplateSumAggregateInputType = {
    id?: true
    vehicleBlockTemplateId?: true
    driverRunTemplateId?: true
    scheduleId?: true
  }

  export type DutyTemplateMinAggregateInputType = {
    id?: true
    name?: true
    startTime?: true
    endTime?: true
    dutyType?: true
    vehicleBlockTemplateId?: true
    driverRunTemplateId?: true
    scheduleId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DutyTemplateMaxAggregateInputType = {
    id?: true
    name?: true
    startTime?: true
    endTime?: true
    dutyType?: true
    vehicleBlockTemplateId?: true
    driverRunTemplateId?: true
    scheduleId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DutyTemplateCountAggregateInputType = {
    id?: true
    name?: true
    startTime?: true
    endTime?: true
    dutyType?: true
    vehicleBlockTemplateId?: true
    driverRunTemplateId?: true
    scheduleId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DutyTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DutyTemplate to aggregate.
     */
    where?: DutyTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DutyTemplates to fetch.
     */
    orderBy?: DutyTemplateOrderByWithRelationInput | DutyTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DutyTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DutyTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DutyTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DutyTemplates
    **/
    _count?: true | DutyTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DutyTemplateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DutyTemplateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DutyTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DutyTemplateMaxAggregateInputType
  }

  export type GetDutyTemplateAggregateType<T extends DutyTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateDutyTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDutyTemplate[P]>
      : GetScalarType<T[P], AggregateDutyTemplate[P]>
  }




  export type DutyTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DutyTemplateWhereInput
    orderBy?: DutyTemplateOrderByWithAggregationInput | DutyTemplateOrderByWithAggregationInput[]
    by: DutyTemplateScalarFieldEnum[] | DutyTemplateScalarFieldEnum
    having?: DutyTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DutyTemplateCountAggregateInputType | true
    _avg?: DutyTemplateAvgAggregateInputType
    _sum?: DutyTemplateSumAggregateInputType
    _min?: DutyTemplateMinAggregateInputType
    _max?: DutyTemplateMaxAggregateInputType
  }

  export type DutyTemplateGroupByOutputType = {
    id: bigint
    name: string | null
    startTime: Date
    endTime: Date
    dutyType: $Enums.DutyType
    vehicleBlockTemplateId: bigint | null
    driverRunTemplateId: bigint | null
    scheduleId: bigint
    createdAt: Date
    updatedAt: Date
    _count: DutyTemplateCountAggregateOutputType | null
    _avg: DutyTemplateAvgAggregateOutputType | null
    _sum: DutyTemplateSumAggregateOutputType | null
    _min: DutyTemplateMinAggregateOutputType | null
    _max: DutyTemplateMaxAggregateOutputType | null
  }

  type GetDutyTemplateGroupByPayload<T extends DutyTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DutyTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DutyTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DutyTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], DutyTemplateGroupByOutputType[P]>
        }
      >
    >


  export type DutyTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    startTime?: boolean
    endTime?: boolean
    dutyType?: boolean
    vehicleBlockTemplateId?: boolean
    driverRunTemplateId?: boolean
    scheduleId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vehicleBlockTemplate?: boolean | DutyTemplate$vehicleBlockTemplateArgs<ExtArgs>
    driverRunTemplate?: boolean | DutyTemplate$driverRunTemplateArgs<ExtArgs>
    schedule?: boolean | ServiceScheduleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dutyTemplate"]>

  export type DutyTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    startTime?: boolean
    endTime?: boolean
    dutyType?: boolean
    vehicleBlockTemplateId?: boolean
    driverRunTemplateId?: boolean
    scheduleId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vehicleBlockTemplate?: boolean | DutyTemplate$vehicleBlockTemplateArgs<ExtArgs>
    driverRunTemplate?: boolean | DutyTemplate$driverRunTemplateArgs<ExtArgs>
    schedule?: boolean | ServiceScheduleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dutyTemplate"]>

  export type DutyTemplateSelectScalar = {
    id?: boolean
    name?: boolean
    startTime?: boolean
    endTime?: boolean
    dutyType?: boolean
    vehicleBlockTemplateId?: boolean
    driverRunTemplateId?: boolean
    scheduleId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DutyTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vehicleBlockTemplate?: boolean | DutyTemplate$vehicleBlockTemplateArgs<ExtArgs>
    driverRunTemplate?: boolean | DutyTemplate$driverRunTemplateArgs<ExtArgs>
    schedule?: boolean | ServiceScheduleDefaultArgs<ExtArgs>
  }
  export type DutyTemplateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vehicleBlockTemplate?: boolean | DutyTemplate$vehicleBlockTemplateArgs<ExtArgs>
    driverRunTemplate?: boolean | DutyTemplate$driverRunTemplateArgs<ExtArgs>
    schedule?: boolean | ServiceScheduleDefaultArgs<ExtArgs>
  }

  export type $DutyTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DutyTemplate"
    objects: {
      vehicleBlockTemplate: Prisma.$VehicleBlockTemplatePayload<ExtArgs> | null
      driverRunTemplate: Prisma.$DriverRunTemplatePayload<ExtArgs> | null
      schedule: Prisma.$ServiceSchedulePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      name: string | null
      startTime: Date
      endTime: Date
      dutyType: $Enums.DutyType
      vehicleBlockTemplateId: bigint | null
      driverRunTemplateId: bigint | null
      scheduleId: bigint
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["dutyTemplate"]>
    composites: {}
  }

  type DutyTemplateGetPayload<S extends boolean | null | undefined | DutyTemplateDefaultArgs> = $Result.GetResult<Prisma.$DutyTemplatePayload, S>

  type DutyTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DutyTemplateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DutyTemplateCountAggregateInputType | true
    }

  export interface DutyTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DutyTemplate'], meta: { name: 'DutyTemplate' } }
    /**
     * Find zero or one DutyTemplate that matches the filter.
     * @param {DutyTemplateFindUniqueArgs} args - Arguments to find a DutyTemplate
     * @example
     * // Get one DutyTemplate
     * const dutyTemplate = await prisma.dutyTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DutyTemplateFindUniqueArgs>(args: SelectSubset<T, DutyTemplateFindUniqueArgs<ExtArgs>>): Prisma__DutyTemplateClient<$Result.GetResult<Prisma.$DutyTemplatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DutyTemplate that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DutyTemplateFindUniqueOrThrowArgs} args - Arguments to find a DutyTemplate
     * @example
     * // Get one DutyTemplate
     * const dutyTemplate = await prisma.dutyTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DutyTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, DutyTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DutyTemplateClient<$Result.GetResult<Prisma.$DutyTemplatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DutyTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DutyTemplateFindFirstArgs} args - Arguments to find a DutyTemplate
     * @example
     * // Get one DutyTemplate
     * const dutyTemplate = await prisma.dutyTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DutyTemplateFindFirstArgs>(args?: SelectSubset<T, DutyTemplateFindFirstArgs<ExtArgs>>): Prisma__DutyTemplateClient<$Result.GetResult<Prisma.$DutyTemplatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DutyTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DutyTemplateFindFirstOrThrowArgs} args - Arguments to find a DutyTemplate
     * @example
     * // Get one DutyTemplate
     * const dutyTemplate = await prisma.dutyTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DutyTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, DutyTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__DutyTemplateClient<$Result.GetResult<Prisma.$DutyTemplatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DutyTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DutyTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DutyTemplates
     * const dutyTemplates = await prisma.dutyTemplate.findMany()
     * 
     * // Get first 10 DutyTemplates
     * const dutyTemplates = await prisma.dutyTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dutyTemplateWithIdOnly = await prisma.dutyTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DutyTemplateFindManyArgs>(args?: SelectSubset<T, DutyTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DutyTemplatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DutyTemplate.
     * @param {DutyTemplateCreateArgs} args - Arguments to create a DutyTemplate.
     * @example
     * // Create one DutyTemplate
     * const DutyTemplate = await prisma.dutyTemplate.create({
     *   data: {
     *     // ... data to create a DutyTemplate
     *   }
     * })
     * 
     */
    create<T extends DutyTemplateCreateArgs>(args: SelectSubset<T, DutyTemplateCreateArgs<ExtArgs>>): Prisma__DutyTemplateClient<$Result.GetResult<Prisma.$DutyTemplatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DutyTemplates.
     * @param {DutyTemplateCreateManyArgs} args - Arguments to create many DutyTemplates.
     * @example
     * // Create many DutyTemplates
     * const dutyTemplate = await prisma.dutyTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DutyTemplateCreateManyArgs>(args?: SelectSubset<T, DutyTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DutyTemplates and returns the data saved in the database.
     * @param {DutyTemplateCreateManyAndReturnArgs} args - Arguments to create many DutyTemplates.
     * @example
     * // Create many DutyTemplates
     * const dutyTemplate = await prisma.dutyTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DutyTemplates and only return the `id`
     * const dutyTemplateWithIdOnly = await prisma.dutyTemplate.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DutyTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, DutyTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DutyTemplatePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DutyTemplate.
     * @param {DutyTemplateDeleteArgs} args - Arguments to delete one DutyTemplate.
     * @example
     * // Delete one DutyTemplate
     * const DutyTemplate = await prisma.dutyTemplate.delete({
     *   where: {
     *     // ... filter to delete one DutyTemplate
     *   }
     * })
     * 
     */
    delete<T extends DutyTemplateDeleteArgs>(args: SelectSubset<T, DutyTemplateDeleteArgs<ExtArgs>>): Prisma__DutyTemplateClient<$Result.GetResult<Prisma.$DutyTemplatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DutyTemplate.
     * @param {DutyTemplateUpdateArgs} args - Arguments to update one DutyTemplate.
     * @example
     * // Update one DutyTemplate
     * const dutyTemplate = await prisma.dutyTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DutyTemplateUpdateArgs>(args: SelectSubset<T, DutyTemplateUpdateArgs<ExtArgs>>): Prisma__DutyTemplateClient<$Result.GetResult<Prisma.$DutyTemplatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DutyTemplates.
     * @param {DutyTemplateDeleteManyArgs} args - Arguments to filter DutyTemplates to delete.
     * @example
     * // Delete a few DutyTemplates
     * const { count } = await prisma.dutyTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DutyTemplateDeleteManyArgs>(args?: SelectSubset<T, DutyTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DutyTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DutyTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DutyTemplates
     * const dutyTemplate = await prisma.dutyTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DutyTemplateUpdateManyArgs>(args: SelectSubset<T, DutyTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DutyTemplate.
     * @param {DutyTemplateUpsertArgs} args - Arguments to update or create a DutyTemplate.
     * @example
     * // Update or create a DutyTemplate
     * const dutyTemplate = await prisma.dutyTemplate.upsert({
     *   create: {
     *     // ... data to create a DutyTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DutyTemplate we want to update
     *   }
     * })
     */
    upsert<T extends DutyTemplateUpsertArgs>(args: SelectSubset<T, DutyTemplateUpsertArgs<ExtArgs>>): Prisma__DutyTemplateClient<$Result.GetResult<Prisma.$DutyTemplatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DutyTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DutyTemplateCountArgs} args - Arguments to filter DutyTemplates to count.
     * @example
     * // Count the number of DutyTemplates
     * const count = await prisma.dutyTemplate.count({
     *   where: {
     *     // ... the filter for the DutyTemplates we want to count
     *   }
     * })
    **/
    count<T extends DutyTemplateCountArgs>(
      args?: Subset<T, DutyTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DutyTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DutyTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DutyTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DutyTemplateAggregateArgs>(args: Subset<T, DutyTemplateAggregateArgs>): Prisma.PrismaPromise<GetDutyTemplateAggregateType<T>>

    /**
     * Group by DutyTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DutyTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DutyTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DutyTemplateGroupByArgs['orderBy'] }
        : { orderBy?: DutyTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DutyTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDutyTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DutyTemplate model
   */
  readonly fields: DutyTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DutyTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DutyTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vehicleBlockTemplate<T extends DutyTemplate$vehicleBlockTemplateArgs<ExtArgs> = {}>(args?: Subset<T, DutyTemplate$vehicleBlockTemplateArgs<ExtArgs>>): Prisma__VehicleBlockTemplateClient<$Result.GetResult<Prisma.$VehicleBlockTemplatePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    driverRunTemplate<T extends DutyTemplate$driverRunTemplateArgs<ExtArgs> = {}>(args?: Subset<T, DutyTemplate$driverRunTemplateArgs<ExtArgs>>): Prisma__DriverRunTemplateClient<$Result.GetResult<Prisma.$DriverRunTemplatePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    schedule<T extends ServiceScheduleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceScheduleDefaultArgs<ExtArgs>>): Prisma__ServiceScheduleClient<$Result.GetResult<Prisma.$ServiceSchedulePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DutyTemplate model
   */ 
  interface DutyTemplateFieldRefs {
    readonly id: FieldRef<"DutyTemplate", 'BigInt'>
    readonly name: FieldRef<"DutyTemplate", 'String'>
    readonly startTime: FieldRef<"DutyTemplate", 'DateTime'>
    readonly endTime: FieldRef<"DutyTemplate", 'DateTime'>
    readonly dutyType: FieldRef<"DutyTemplate", 'DutyType'>
    readonly vehicleBlockTemplateId: FieldRef<"DutyTemplate", 'BigInt'>
    readonly driverRunTemplateId: FieldRef<"DutyTemplate", 'BigInt'>
    readonly scheduleId: FieldRef<"DutyTemplate", 'BigInt'>
    readonly createdAt: FieldRef<"DutyTemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"DutyTemplate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DutyTemplate findUnique
   */
  export type DutyTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DutyTemplate
     */
    select?: DutyTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DutyTemplateInclude<ExtArgs> | null
    /**
     * Filter, which DutyTemplate to fetch.
     */
    where: DutyTemplateWhereUniqueInput
  }

  /**
   * DutyTemplate findUniqueOrThrow
   */
  export type DutyTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DutyTemplate
     */
    select?: DutyTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DutyTemplateInclude<ExtArgs> | null
    /**
     * Filter, which DutyTemplate to fetch.
     */
    where: DutyTemplateWhereUniqueInput
  }

  /**
   * DutyTemplate findFirst
   */
  export type DutyTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DutyTemplate
     */
    select?: DutyTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DutyTemplateInclude<ExtArgs> | null
    /**
     * Filter, which DutyTemplate to fetch.
     */
    where?: DutyTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DutyTemplates to fetch.
     */
    orderBy?: DutyTemplateOrderByWithRelationInput | DutyTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DutyTemplates.
     */
    cursor?: DutyTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DutyTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DutyTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DutyTemplates.
     */
    distinct?: DutyTemplateScalarFieldEnum | DutyTemplateScalarFieldEnum[]
  }

  /**
   * DutyTemplate findFirstOrThrow
   */
  export type DutyTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DutyTemplate
     */
    select?: DutyTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DutyTemplateInclude<ExtArgs> | null
    /**
     * Filter, which DutyTemplate to fetch.
     */
    where?: DutyTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DutyTemplates to fetch.
     */
    orderBy?: DutyTemplateOrderByWithRelationInput | DutyTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DutyTemplates.
     */
    cursor?: DutyTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DutyTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DutyTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DutyTemplates.
     */
    distinct?: DutyTemplateScalarFieldEnum | DutyTemplateScalarFieldEnum[]
  }

  /**
   * DutyTemplate findMany
   */
  export type DutyTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DutyTemplate
     */
    select?: DutyTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DutyTemplateInclude<ExtArgs> | null
    /**
     * Filter, which DutyTemplates to fetch.
     */
    where?: DutyTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DutyTemplates to fetch.
     */
    orderBy?: DutyTemplateOrderByWithRelationInput | DutyTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DutyTemplates.
     */
    cursor?: DutyTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DutyTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DutyTemplates.
     */
    skip?: number
    distinct?: DutyTemplateScalarFieldEnum | DutyTemplateScalarFieldEnum[]
  }

  /**
   * DutyTemplate create
   */
  export type DutyTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DutyTemplate
     */
    select?: DutyTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DutyTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a DutyTemplate.
     */
    data: XOR<DutyTemplateCreateInput, DutyTemplateUncheckedCreateInput>
  }

  /**
   * DutyTemplate createMany
   */
  export type DutyTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DutyTemplates.
     */
    data: DutyTemplateCreateManyInput | DutyTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DutyTemplate createManyAndReturn
   */
  export type DutyTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DutyTemplate
     */
    select?: DutyTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DutyTemplates.
     */
    data: DutyTemplateCreateManyInput | DutyTemplateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DutyTemplateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DutyTemplate update
   */
  export type DutyTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DutyTemplate
     */
    select?: DutyTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DutyTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a DutyTemplate.
     */
    data: XOR<DutyTemplateUpdateInput, DutyTemplateUncheckedUpdateInput>
    /**
     * Choose, which DutyTemplate to update.
     */
    where: DutyTemplateWhereUniqueInput
  }

  /**
   * DutyTemplate updateMany
   */
  export type DutyTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DutyTemplates.
     */
    data: XOR<DutyTemplateUpdateManyMutationInput, DutyTemplateUncheckedUpdateManyInput>
    /**
     * Filter which DutyTemplates to update
     */
    where?: DutyTemplateWhereInput
  }

  /**
   * DutyTemplate upsert
   */
  export type DutyTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DutyTemplate
     */
    select?: DutyTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DutyTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the DutyTemplate to update in case it exists.
     */
    where: DutyTemplateWhereUniqueInput
    /**
     * In case the DutyTemplate found by the `where` argument doesn't exist, create a new DutyTemplate with this data.
     */
    create: XOR<DutyTemplateCreateInput, DutyTemplateUncheckedCreateInput>
    /**
     * In case the DutyTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DutyTemplateUpdateInput, DutyTemplateUncheckedUpdateInput>
  }

  /**
   * DutyTemplate delete
   */
  export type DutyTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DutyTemplate
     */
    select?: DutyTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DutyTemplateInclude<ExtArgs> | null
    /**
     * Filter which DutyTemplate to delete.
     */
    where: DutyTemplateWhereUniqueInput
  }

  /**
   * DutyTemplate deleteMany
   */
  export type DutyTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DutyTemplates to delete
     */
    where?: DutyTemplateWhereInput
  }

  /**
   * DutyTemplate.vehicleBlockTemplate
   */
  export type DutyTemplate$vehicleBlockTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleBlockTemplate
     */
    select?: VehicleBlockTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleBlockTemplateInclude<ExtArgs> | null
    where?: VehicleBlockTemplateWhereInput
  }

  /**
   * DutyTemplate.driverRunTemplate
   */
  export type DutyTemplate$driverRunTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverRunTemplate
     */
    select?: DriverRunTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverRunTemplateInclude<ExtArgs> | null
    where?: DriverRunTemplateWhereInput
  }

  /**
   * DutyTemplate without action
   */
  export type DutyTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DutyTemplate
     */
    select?: DutyTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DutyTemplateInclude<ExtArgs> | null
  }


  /**
   * Model VehicleBlock
   */

  export type AggregateVehicleBlock = {
    _count: VehicleBlockCountAggregateOutputType | null
    _avg: VehicleBlockAvgAggregateOutputType | null
    _sum: VehicleBlockSumAggregateOutputType | null
    _min: VehicleBlockMinAggregateOutputType | null
    _max: VehicleBlockMaxAggregateOutputType | null
  }

  export type VehicleBlockAvgAggregateOutputType = {
    id: number | null
    vehicleBlockTemplateId: number | null
  }

  export type VehicleBlockSumAggregateOutputType = {
    id: bigint | null
    vehicleBlockTemplateId: bigint | null
  }

  export type VehicleBlockMinAggregateOutputType = {
    id: bigint | null
    vehicleBlockTemplateId: bigint | null
    code: string | null
  }

  export type VehicleBlockMaxAggregateOutputType = {
    id: bigint | null
    vehicleBlockTemplateId: bigint | null
    code: string | null
  }

  export type VehicleBlockCountAggregateOutputType = {
    id: number
    vehicleBlockTemplateId: number
    code: number
    _all: number
  }


  export type VehicleBlockAvgAggregateInputType = {
    id?: true
    vehicleBlockTemplateId?: true
  }

  export type VehicleBlockSumAggregateInputType = {
    id?: true
    vehicleBlockTemplateId?: true
  }

  export type VehicleBlockMinAggregateInputType = {
    id?: true
    vehicleBlockTemplateId?: true
    code?: true
  }

  export type VehicleBlockMaxAggregateInputType = {
    id?: true
    vehicleBlockTemplateId?: true
    code?: true
  }

  export type VehicleBlockCountAggregateInputType = {
    id?: true
    vehicleBlockTemplateId?: true
    code?: true
    _all?: true
  }

  export type VehicleBlockAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VehicleBlock to aggregate.
     */
    where?: VehicleBlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleBlocks to fetch.
     */
    orderBy?: VehicleBlockOrderByWithRelationInput | VehicleBlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VehicleBlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleBlocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleBlocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VehicleBlocks
    **/
    _count?: true | VehicleBlockCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VehicleBlockAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VehicleBlockSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VehicleBlockMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VehicleBlockMaxAggregateInputType
  }

  export type GetVehicleBlockAggregateType<T extends VehicleBlockAggregateArgs> = {
        [P in keyof T & keyof AggregateVehicleBlock]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVehicleBlock[P]>
      : GetScalarType<T[P], AggregateVehicleBlock[P]>
  }




  export type VehicleBlockGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VehicleBlockWhereInput
    orderBy?: VehicleBlockOrderByWithAggregationInput | VehicleBlockOrderByWithAggregationInput[]
    by: VehicleBlockScalarFieldEnum[] | VehicleBlockScalarFieldEnum
    having?: VehicleBlockScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VehicleBlockCountAggregateInputType | true
    _avg?: VehicleBlockAvgAggregateInputType
    _sum?: VehicleBlockSumAggregateInputType
    _min?: VehicleBlockMinAggregateInputType
    _max?: VehicleBlockMaxAggregateInputType
  }

  export type VehicleBlockGroupByOutputType = {
    id: bigint
    vehicleBlockTemplateId: bigint
    code: string
    _count: VehicleBlockCountAggregateOutputType | null
    _avg: VehicleBlockAvgAggregateOutputType | null
    _sum: VehicleBlockSumAggregateOutputType | null
    _min: VehicleBlockMinAggregateOutputType | null
    _max: VehicleBlockMaxAggregateOutputType | null
  }

  type GetVehicleBlockGroupByPayload<T extends VehicleBlockGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VehicleBlockGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VehicleBlockGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VehicleBlockGroupByOutputType[P]>
            : GetScalarType<T[P], VehicleBlockGroupByOutputType[P]>
        }
      >
    >


  export type VehicleBlockSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vehicleBlockTemplateId?: boolean
    code?: boolean
    vehicleBlockTemplate?: boolean | VehicleBlockTemplateDefaultArgs<ExtArgs>
    Duty?: boolean | VehicleBlock$DutyArgs<ExtArgs>
    _count?: boolean | VehicleBlockCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicleBlock"]>

  export type VehicleBlockSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vehicleBlockTemplateId?: boolean
    code?: boolean
    vehicleBlockTemplate?: boolean | VehicleBlockTemplateDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicleBlock"]>

  export type VehicleBlockSelectScalar = {
    id?: boolean
    vehicleBlockTemplateId?: boolean
    code?: boolean
  }

  export type VehicleBlockInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vehicleBlockTemplate?: boolean | VehicleBlockTemplateDefaultArgs<ExtArgs>
    Duty?: boolean | VehicleBlock$DutyArgs<ExtArgs>
    _count?: boolean | VehicleBlockCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VehicleBlockIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vehicleBlockTemplate?: boolean | VehicleBlockTemplateDefaultArgs<ExtArgs>
  }

  export type $VehicleBlockPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VehicleBlock"
    objects: {
      vehicleBlockTemplate: Prisma.$VehicleBlockTemplatePayload<ExtArgs>
      Duty: Prisma.$DutyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      vehicleBlockTemplateId: bigint
      code: string
    }, ExtArgs["result"]["vehicleBlock"]>
    composites: {}
  }

  type VehicleBlockGetPayload<S extends boolean | null | undefined | VehicleBlockDefaultArgs> = $Result.GetResult<Prisma.$VehicleBlockPayload, S>

  type VehicleBlockCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VehicleBlockFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VehicleBlockCountAggregateInputType | true
    }

  export interface VehicleBlockDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VehicleBlock'], meta: { name: 'VehicleBlock' } }
    /**
     * Find zero or one VehicleBlock that matches the filter.
     * @param {VehicleBlockFindUniqueArgs} args - Arguments to find a VehicleBlock
     * @example
     * // Get one VehicleBlock
     * const vehicleBlock = await prisma.vehicleBlock.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VehicleBlockFindUniqueArgs>(args: SelectSubset<T, VehicleBlockFindUniqueArgs<ExtArgs>>): Prisma__VehicleBlockClient<$Result.GetResult<Prisma.$VehicleBlockPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one VehicleBlock that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VehicleBlockFindUniqueOrThrowArgs} args - Arguments to find a VehicleBlock
     * @example
     * // Get one VehicleBlock
     * const vehicleBlock = await prisma.vehicleBlock.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VehicleBlockFindUniqueOrThrowArgs>(args: SelectSubset<T, VehicleBlockFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VehicleBlockClient<$Result.GetResult<Prisma.$VehicleBlockPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first VehicleBlock that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleBlockFindFirstArgs} args - Arguments to find a VehicleBlock
     * @example
     * // Get one VehicleBlock
     * const vehicleBlock = await prisma.vehicleBlock.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VehicleBlockFindFirstArgs>(args?: SelectSubset<T, VehicleBlockFindFirstArgs<ExtArgs>>): Prisma__VehicleBlockClient<$Result.GetResult<Prisma.$VehicleBlockPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first VehicleBlock that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleBlockFindFirstOrThrowArgs} args - Arguments to find a VehicleBlock
     * @example
     * // Get one VehicleBlock
     * const vehicleBlock = await prisma.vehicleBlock.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VehicleBlockFindFirstOrThrowArgs>(args?: SelectSubset<T, VehicleBlockFindFirstOrThrowArgs<ExtArgs>>): Prisma__VehicleBlockClient<$Result.GetResult<Prisma.$VehicleBlockPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more VehicleBlocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleBlockFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VehicleBlocks
     * const vehicleBlocks = await prisma.vehicleBlock.findMany()
     * 
     * // Get first 10 VehicleBlocks
     * const vehicleBlocks = await prisma.vehicleBlock.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vehicleBlockWithIdOnly = await prisma.vehicleBlock.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VehicleBlockFindManyArgs>(args?: SelectSubset<T, VehicleBlockFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehicleBlockPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a VehicleBlock.
     * @param {VehicleBlockCreateArgs} args - Arguments to create a VehicleBlock.
     * @example
     * // Create one VehicleBlock
     * const VehicleBlock = await prisma.vehicleBlock.create({
     *   data: {
     *     // ... data to create a VehicleBlock
     *   }
     * })
     * 
     */
    create<T extends VehicleBlockCreateArgs>(args: SelectSubset<T, VehicleBlockCreateArgs<ExtArgs>>): Prisma__VehicleBlockClient<$Result.GetResult<Prisma.$VehicleBlockPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many VehicleBlocks.
     * @param {VehicleBlockCreateManyArgs} args - Arguments to create many VehicleBlocks.
     * @example
     * // Create many VehicleBlocks
     * const vehicleBlock = await prisma.vehicleBlock.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VehicleBlockCreateManyArgs>(args?: SelectSubset<T, VehicleBlockCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VehicleBlocks and returns the data saved in the database.
     * @param {VehicleBlockCreateManyAndReturnArgs} args - Arguments to create many VehicleBlocks.
     * @example
     * // Create many VehicleBlocks
     * const vehicleBlock = await prisma.vehicleBlock.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VehicleBlocks and only return the `id`
     * const vehicleBlockWithIdOnly = await prisma.vehicleBlock.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VehicleBlockCreateManyAndReturnArgs>(args?: SelectSubset<T, VehicleBlockCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehicleBlockPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a VehicleBlock.
     * @param {VehicleBlockDeleteArgs} args - Arguments to delete one VehicleBlock.
     * @example
     * // Delete one VehicleBlock
     * const VehicleBlock = await prisma.vehicleBlock.delete({
     *   where: {
     *     // ... filter to delete one VehicleBlock
     *   }
     * })
     * 
     */
    delete<T extends VehicleBlockDeleteArgs>(args: SelectSubset<T, VehicleBlockDeleteArgs<ExtArgs>>): Prisma__VehicleBlockClient<$Result.GetResult<Prisma.$VehicleBlockPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one VehicleBlock.
     * @param {VehicleBlockUpdateArgs} args - Arguments to update one VehicleBlock.
     * @example
     * // Update one VehicleBlock
     * const vehicleBlock = await prisma.vehicleBlock.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VehicleBlockUpdateArgs>(args: SelectSubset<T, VehicleBlockUpdateArgs<ExtArgs>>): Prisma__VehicleBlockClient<$Result.GetResult<Prisma.$VehicleBlockPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more VehicleBlocks.
     * @param {VehicleBlockDeleteManyArgs} args - Arguments to filter VehicleBlocks to delete.
     * @example
     * // Delete a few VehicleBlocks
     * const { count } = await prisma.vehicleBlock.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VehicleBlockDeleteManyArgs>(args?: SelectSubset<T, VehicleBlockDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VehicleBlocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleBlockUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VehicleBlocks
     * const vehicleBlock = await prisma.vehicleBlock.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VehicleBlockUpdateManyArgs>(args: SelectSubset<T, VehicleBlockUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VehicleBlock.
     * @param {VehicleBlockUpsertArgs} args - Arguments to update or create a VehicleBlock.
     * @example
     * // Update or create a VehicleBlock
     * const vehicleBlock = await prisma.vehicleBlock.upsert({
     *   create: {
     *     // ... data to create a VehicleBlock
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VehicleBlock we want to update
     *   }
     * })
     */
    upsert<T extends VehicleBlockUpsertArgs>(args: SelectSubset<T, VehicleBlockUpsertArgs<ExtArgs>>): Prisma__VehicleBlockClient<$Result.GetResult<Prisma.$VehicleBlockPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of VehicleBlocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleBlockCountArgs} args - Arguments to filter VehicleBlocks to count.
     * @example
     * // Count the number of VehicleBlocks
     * const count = await prisma.vehicleBlock.count({
     *   where: {
     *     // ... the filter for the VehicleBlocks we want to count
     *   }
     * })
    **/
    count<T extends VehicleBlockCountArgs>(
      args?: Subset<T, VehicleBlockCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VehicleBlockCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VehicleBlock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleBlockAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VehicleBlockAggregateArgs>(args: Subset<T, VehicleBlockAggregateArgs>): Prisma.PrismaPromise<GetVehicleBlockAggregateType<T>>

    /**
     * Group by VehicleBlock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleBlockGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VehicleBlockGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VehicleBlockGroupByArgs['orderBy'] }
        : { orderBy?: VehicleBlockGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VehicleBlockGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVehicleBlockGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VehicleBlock model
   */
  readonly fields: VehicleBlockFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VehicleBlock.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VehicleBlockClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vehicleBlockTemplate<T extends VehicleBlockTemplateDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VehicleBlockTemplateDefaultArgs<ExtArgs>>): Prisma__VehicleBlockTemplateClient<$Result.GetResult<Prisma.$VehicleBlockTemplatePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Duty<T extends VehicleBlock$DutyArgs<ExtArgs> = {}>(args?: Subset<T, VehicleBlock$DutyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DutyPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VehicleBlock model
   */ 
  interface VehicleBlockFieldRefs {
    readonly id: FieldRef<"VehicleBlock", 'BigInt'>
    readonly vehicleBlockTemplateId: FieldRef<"VehicleBlock", 'BigInt'>
    readonly code: FieldRef<"VehicleBlock", 'String'>
  }
    

  // Custom InputTypes
  /**
   * VehicleBlock findUnique
   */
  export type VehicleBlockFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleBlock
     */
    select?: VehicleBlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleBlockInclude<ExtArgs> | null
    /**
     * Filter, which VehicleBlock to fetch.
     */
    where: VehicleBlockWhereUniqueInput
  }

  /**
   * VehicleBlock findUniqueOrThrow
   */
  export type VehicleBlockFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleBlock
     */
    select?: VehicleBlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleBlockInclude<ExtArgs> | null
    /**
     * Filter, which VehicleBlock to fetch.
     */
    where: VehicleBlockWhereUniqueInput
  }

  /**
   * VehicleBlock findFirst
   */
  export type VehicleBlockFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleBlock
     */
    select?: VehicleBlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleBlockInclude<ExtArgs> | null
    /**
     * Filter, which VehicleBlock to fetch.
     */
    where?: VehicleBlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleBlocks to fetch.
     */
    orderBy?: VehicleBlockOrderByWithRelationInput | VehicleBlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VehicleBlocks.
     */
    cursor?: VehicleBlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleBlocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleBlocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VehicleBlocks.
     */
    distinct?: VehicleBlockScalarFieldEnum | VehicleBlockScalarFieldEnum[]
  }

  /**
   * VehicleBlock findFirstOrThrow
   */
  export type VehicleBlockFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleBlock
     */
    select?: VehicleBlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleBlockInclude<ExtArgs> | null
    /**
     * Filter, which VehicleBlock to fetch.
     */
    where?: VehicleBlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleBlocks to fetch.
     */
    orderBy?: VehicleBlockOrderByWithRelationInput | VehicleBlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VehicleBlocks.
     */
    cursor?: VehicleBlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleBlocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleBlocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VehicleBlocks.
     */
    distinct?: VehicleBlockScalarFieldEnum | VehicleBlockScalarFieldEnum[]
  }

  /**
   * VehicleBlock findMany
   */
  export type VehicleBlockFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleBlock
     */
    select?: VehicleBlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleBlockInclude<ExtArgs> | null
    /**
     * Filter, which VehicleBlocks to fetch.
     */
    where?: VehicleBlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleBlocks to fetch.
     */
    orderBy?: VehicleBlockOrderByWithRelationInput | VehicleBlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VehicleBlocks.
     */
    cursor?: VehicleBlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleBlocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleBlocks.
     */
    skip?: number
    distinct?: VehicleBlockScalarFieldEnum | VehicleBlockScalarFieldEnum[]
  }

  /**
   * VehicleBlock create
   */
  export type VehicleBlockCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleBlock
     */
    select?: VehicleBlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleBlockInclude<ExtArgs> | null
    /**
     * The data needed to create a VehicleBlock.
     */
    data: XOR<VehicleBlockCreateInput, VehicleBlockUncheckedCreateInput>
  }

  /**
   * VehicleBlock createMany
   */
  export type VehicleBlockCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VehicleBlocks.
     */
    data: VehicleBlockCreateManyInput | VehicleBlockCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VehicleBlock createManyAndReturn
   */
  export type VehicleBlockCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleBlock
     */
    select?: VehicleBlockSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many VehicleBlocks.
     */
    data: VehicleBlockCreateManyInput | VehicleBlockCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleBlockIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VehicleBlock update
   */
  export type VehicleBlockUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleBlock
     */
    select?: VehicleBlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleBlockInclude<ExtArgs> | null
    /**
     * The data needed to update a VehicleBlock.
     */
    data: XOR<VehicleBlockUpdateInput, VehicleBlockUncheckedUpdateInput>
    /**
     * Choose, which VehicleBlock to update.
     */
    where: VehicleBlockWhereUniqueInput
  }

  /**
   * VehicleBlock updateMany
   */
  export type VehicleBlockUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VehicleBlocks.
     */
    data: XOR<VehicleBlockUpdateManyMutationInput, VehicleBlockUncheckedUpdateManyInput>
    /**
     * Filter which VehicleBlocks to update
     */
    where?: VehicleBlockWhereInput
  }

  /**
   * VehicleBlock upsert
   */
  export type VehicleBlockUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleBlock
     */
    select?: VehicleBlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleBlockInclude<ExtArgs> | null
    /**
     * The filter to search for the VehicleBlock to update in case it exists.
     */
    where: VehicleBlockWhereUniqueInput
    /**
     * In case the VehicleBlock found by the `where` argument doesn't exist, create a new VehicleBlock with this data.
     */
    create: XOR<VehicleBlockCreateInput, VehicleBlockUncheckedCreateInput>
    /**
     * In case the VehicleBlock was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VehicleBlockUpdateInput, VehicleBlockUncheckedUpdateInput>
  }

  /**
   * VehicleBlock delete
   */
  export type VehicleBlockDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleBlock
     */
    select?: VehicleBlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleBlockInclude<ExtArgs> | null
    /**
     * Filter which VehicleBlock to delete.
     */
    where: VehicleBlockWhereUniqueInput
  }

  /**
   * VehicleBlock deleteMany
   */
  export type VehicleBlockDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VehicleBlocks to delete
     */
    where?: VehicleBlockWhereInput
  }

  /**
   * VehicleBlock.Duty
   */
  export type VehicleBlock$DutyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Duty
     */
    select?: DutySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DutyInclude<ExtArgs> | null
    where?: DutyWhereInput
    orderBy?: DutyOrderByWithRelationInput | DutyOrderByWithRelationInput[]
    cursor?: DutyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DutyScalarFieldEnum | DutyScalarFieldEnum[]
  }

  /**
   * VehicleBlock without action
   */
  export type VehicleBlockDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleBlock
     */
    select?: VehicleBlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleBlockInclude<ExtArgs> | null
  }


  /**
   * Model DriverRun
   */

  export type AggregateDriverRun = {
    _count: DriverRunCountAggregateOutputType | null
    _avg: DriverRunAvgAggregateOutputType | null
    _sum: DriverRunSumAggregateOutputType | null
    _min: DriverRunMinAggregateOutputType | null
    _max: DriverRunMaxAggregateOutputType | null
  }

  export type DriverRunAvgAggregateOutputType = {
    id: number | null
    driverRunTemplateId: number | null
  }

  export type DriverRunSumAggregateOutputType = {
    id: bigint | null
    driverRunTemplateId: bigint | null
  }

  export type DriverRunMinAggregateOutputType = {
    id: bigint | null
    driverRunTemplateId: bigint | null
    code: string | null
  }

  export type DriverRunMaxAggregateOutputType = {
    id: bigint | null
    driverRunTemplateId: bigint | null
    code: string | null
  }

  export type DriverRunCountAggregateOutputType = {
    id: number
    driverRunTemplateId: number
    code: number
    _all: number
  }


  export type DriverRunAvgAggregateInputType = {
    id?: true
    driverRunTemplateId?: true
  }

  export type DriverRunSumAggregateInputType = {
    id?: true
    driverRunTemplateId?: true
  }

  export type DriverRunMinAggregateInputType = {
    id?: true
    driverRunTemplateId?: true
    code?: true
  }

  export type DriverRunMaxAggregateInputType = {
    id?: true
    driverRunTemplateId?: true
    code?: true
  }

  export type DriverRunCountAggregateInputType = {
    id?: true
    driverRunTemplateId?: true
    code?: true
    _all?: true
  }

  export type DriverRunAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DriverRun to aggregate.
     */
    where?: DriverRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DriverRuns to fetch.
     */
    orderBy?: DriverRunOrderByWithRelationInput | DriverRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DriverRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DriverRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DriverRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DriverRuns
    **/
    _count?: true | DriverRunCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DriverRunAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DriverRunSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DriverRunMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DriverRunMaxAggregateInputType
  }

  export type GetDriverRunAggregateType<T extends DriverRunAggregateArgs> = {
        [P in keyof T & keyof AggregateDriverRun]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDriverRun[P]>
      : GetScalarType<T[P], AggregateDriverRun[P]>
  }




  export type DriverRunGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DriverRunWhereInput
    orderBy?: DriverRunOrderByWithAggregationInput | DriverRunOrderByWithAggregationInput[]
    by: DriverRunScalarFieldEnum[] | DriverRunScalarFieldEnum
    having?: DriverRunScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DriverRunCountAggregateInputType | true
    _avg?: DriverRunAvgAggregateInputType
    _sum?: DriverRunSumAggregateInputType
    _min?: DriverRunMinAggregateInputType
    _max?: DriverRunMaxAggregateInputType
  }

  export type DriverRunGroupByOutputType = {
    id: bigint
    driverRunTemplateId: bigint
    code: string
    _count: DriverRunCountAggregateOutputType | null
    _avg: DriverRunAvgAggregateOutputType | null
    _sum: DriverRunSumAggregateOutputType | null
    _min: DriverRunMinAggregateOutputType | null
    _max: DriverRunMaxAggregateOutputType | null
  }

  type GetDriverRunGroupByPayload<T extends DriverRunGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DriverRunGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DriverRunGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DriverRunGroupByOutputType[P]>
            : GetScalarType<T[P], DriverRunGroupByOutputType[P]>
        }
      >
    >


  export type DriverRunSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    driverRunTemplateId?: boolean
    code?: boolean
    driverRunTemplate?: boolean | DriverRunTemplateDefaultArgs<ExtArgs>
    Duty?: boolean | DriverRun$DutyArgs<ExtArgs>
    _count?: boolean | DriverRunCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["driverRun"]>

  export type DriverRunSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    driverRunTemplateId?: boolean
    code?: boolean
    driverRunTemplate?: boolean | DriverRunTemplateDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["driverRun"]>

  export type DriverRunSelectScalar = {
    id?: boolean
    driverRunTemplateId?: boolean
    code?: boolean
  }

  export type DriverRunInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    driverRunTemplate?: boolean | DriverRunTemplateDefaultArgs<ExtArgs>
    Duty?: boolean | DriverRun$DutyArgs<ExtArgs>
    _count?: boolean | DriverRunCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DriverRunIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    driverRunTemplate?: boolean | DriverRunTemplateDefaultArgs<ExtArgs>
  }

  export type $DriverRunPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DriverRun"
    objects: {
      driverRunTemplate: Prisma.$DriverRunTemplatePayload<ExtArgs>
      Duty: Prisma.$DutyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      driverRunTemplateId: bigint
      code: string
    }, ExtArgs["result"]["driverRun"]>
    composites: {}
  }

  type DriverRunGetPayload<S extends boolean | null | undefined | DriverRunDefaultArgs> = $Result.GetResult<Prisma.$DriverRunPayload, S>

  type DriverRunCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DriverRunFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DriverRunCountAggregateInputType | true
    }

  export interface DriverRunDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DriverRun'], meta: { name: 'DriverRun' } }
    /**
     * Find zero or one DriverRun that matches the filter.
     * @param {DriverRunFindUniqueArgs} args - Arguments to find a DriverRun
     * @example
     * // Get one DriverRun
     * const driverRun = await prisma.driverRun.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DriverRunFindUniqueArgs>(args: SelectSubset<T, DriverRunFindUniqueArgs<ExtArgs>>): Prisma__DriverRunClient<$Result.GetResult<Prisma.$DriverRunPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DriverRun that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DriverRunFindUniqueOrThrowArgs} args - Arguments to find a DriverRun
     * @example
     * // Get one DriverRun
     * const driverRun = await prisma.driverRun.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DriverRunFindUniqueOrThrowArgs>(args: SelectSubset<T, DriverRunFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DriverRunClient<$Result.GetResult<Prisma.$DriverRunPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DriverRun that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverRunFindFirstArgs} args - Arguments to find a DriverRun
     * @example
     * // Get one DriverRun
     * const driverRun = await prisma.driverRun.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DriverRunFindFirstArgs>(args?: SelectSubset<T, DriverRunFindFirstArgs<ExtArgs>>): Prisma__DriverRunClient<$Result.GetResult<Prisma.$DriverRunPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DriverRun that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverRunFindFirstOrThrowArgs} args - Arguments to find a DriverRun
     * @example
     * // Get one DriverRun
     * const driverRun = await prisma.driverRun.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DriverRunFindFirstOrThrowArgs>(args?: SelectSubset<T, DriverRunFindFirstOrThrowArgs<ExtArgs>>): Prisma__DriverRunClient<$Result.GetResult<Prisma.$DriverRunPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DriverRuns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverRunFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DriverRuns
     * const driverRuns = await prisma.driverRun.findMany()
     * 
     * // Get first 10 DriverRuns
     * const driverRuns = await prisma.driverRun.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const driverRunWithIdOnly = await prisma.driverRun.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DriverRunFindManyArgs>(args?: SelectSubset<T, DriverRunFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DriverRunPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DriverRun.
     * @param {DriverRunCreateArgs} args - Arguments to create a DriverRun.
     * @example
     * // Create one DriverRun
     * const DriverRun = await prisma.driverRun.create({
     *   data: {
     *     // ... data to create a DriverRun
     *   }
     * })
     * 
     */
    create<T extends DriverRunCreateArgs>(args: SelectSubset<T, DriverRunCreateArgs<ExtArgs>>): Prisma__DriverRunClient<$Result.GetResult<Prisma.$DriverRunPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DriverRuns.
     * @param {DriverRunCreateManyArgs} args - Arguments to create many DriverRuns.
     * @example
     * // Create many DriverRuns
     * const driverRun = await prisma.driverRun.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DriverRunCreateManyArgs>(args?: SelectSubset<T, DriverRunCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DriverRuns and returns the data saved in the database.
     * @param {DriverRunCreateManyAndReturnArgs} args - Arguments to create many DriverRuns.
     * @example
     * // Create many DriverRuns
     * const driverRun = await prisma.driverRun.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DriverRuns and only return the `id`
     * const driverRunWithIdOnly = await prisma.driverRun.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DriverRunCreateManyAndReturnArgs>(args?: SelectSubset<T, DriverRunCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DriverRunPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DriverRun.
     * @param {DriverRunDeleteArgs} args - Arguments to delete one DriverRun.
     * @example
     * // Delete one DriverRun
     * const DriverRun = await prisma.driverRun.delete({
     *   where: {
     *     // ... filter to delete one DriverRun
     *   }
     * })
     * 
     */
    delete<T extends DriverRunDeleteArgs>(args: SelectSubset<T, DriverRunDeleteArgs<ExtArgs>>): Prisma__DriverRunClient<$Result.GetResult<Prisma.$DriverRunPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DriverRun.
     * @param {DriverRunUpdateArgs} args - Arguments to update one DriverRun.
     * @example
     * // Update one DriverRun
     * const driverRun = await prisma.driverRun.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DriverRunUpdateArgs>(args: SelectSubset<T, DriverRunUpdateArgs<ExtArgs>>): Prisma__DriverRunClient<$Result.GetResult<Prisma.$DriverRunPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DriverRuns.
     * @param {DriverRunDeleteManyArgs} args - Arguments to filter DriverRuns to delete.
     * @example
     * // Delete a few DriverRuns
     * const { count } = await prisma.driverRun.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DriverRunDeleteManyArgs>(args?: SelectSubset<T, DriverRunDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DriverRuns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverRunUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DriverRuns
     * const driverRun = await prisma.driverRun.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DriverRunUpdateManyArgs>(args: SelectSubset<T, DriverRunUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DriverRun.
     * @param {DriverRunUpsertArgs} args - Arguments to update or create a DriverRun.
     * @example
     * // Update or create a DriverRun
     * const driverRun = await prisma.driverRun.upsert({
     *   create: {
     *     // ... data to create a DriverRun
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DriverRun we want to update
     *   }
     * })
     */
    upsert<T extends DriverRunUpsertArgs>(args: SelectSubset<T, DriverRunUpsertArgs<ExtArgs>>): Prisma__DriverRunClient<$Result.GetResult<Prisma.$DriverRunPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DriverRuns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverRunCountArgs} args - Arguments to filter DriverRuns to count.
     * @example
     * // Count the number of DriverRuns
     * const count = await prisma.driverRun.count({
     *   where: {
     *     // ... the filter for the DriverRuns we want to count
     *   }
     * })
    **/
    count<T extends DriverRunCountArgs>(
      args?: Subset<T, DriverRunCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DriverRunCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DriverRun.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverRunAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DriverRunAggregateArgs>(args: Subset<T, DriverRunAggregateArgs>): Prisma.PrismaPromise<GetDriverRunAggregateType<T>>

    /**
     * Group by DriverRun.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverRunGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DriverRunGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DriverRunGroupByArgs['orderBy'] }
        : { orderBy?: DriverRunGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DriverRunGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDriverRunGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DriverRun model
   */
  readonly fields: DriverRunFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DriverRun.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DriverRunClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    driverRunTemplate<T extends DriverRunTemplateDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DriverRunTemplateDefaultArgs<ExtArgs>>): Prisma__DriverRunTemplateClient<$Result.GetResult<Prisma.$DriverRunTemplatePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Duty<T extends DriverRun$DutyArgs<ExtArgs> = {}>(args?: Subset<T, DriverRun$DutyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DutyPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DriverRun model
   */ 
  interface DriverRunFieldRefs {
    readonly id: FieldRef<"DriverRun", 'BigInt'>
    readonly driverRunTemplateId: FieldRef<"DriverRun", 'BigInt'>
    readonly code: FieldRef<"DriverRun", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DriverRun findUnique
   */
  export type DriverRunFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverRun
     */
    select?: DriverRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverRunInclude<ExtArgs> | null
    /**
     * Filter, which DriverRun to fetch.
     */
    where: DriverRunWhereUniqueInput
  }

  /**
   * DriverRun findUniqueOrThrow
   */
  export type DriverRunFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverRun
     */
    select?: DriverRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverRunInclude<ExtArgs> | null
    /**
     * Filter, which DriverRun to fetch.
     */
    where: DriverRunWhereUniqueInput
  }

  /**
   * DriverRun findFirst
   */
  export type DriverRunFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverRun
     */
    select?: DriverRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverRunInclude<ExtArgs> | null
    /**
     * Filter, which DriverRun to fetch.
     */
    where?: DriverRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DriverRuns to fetch.
     */
    orderBy?: DriverRunOrderByWithRelationInput | DriverRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DriverRuns.
     */
    cursor?: DriverRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DriverRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DriverRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DriverRuns.
     */
    distinct?: DriverRunScalarFieldEnum | DriverRunScalarFieldEnum[]
  }

  /**
   * DriverRun findFirstOrThrow
   */
  export type DriverRunFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverRun
     */
    select?: DriverRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverRunInclude<ExtArgs> | null
    /**
     * Filter, which DriverRun to fetch.
     */
    where?: DriverRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DriverRuns to fetch.
     */
    orderBy?: DriverRunOrderByWithRelationInput | DriverRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DriverRuns.
     */
    cursor?: DriverRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DriverRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DriverRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DriverRuns.
     */
    distinct?: DriverRunScalarFieldEnum | DriverRunScalarFieldEnum[]
  }

  /**
   * DriverRun findMany
   */
  export type DriverRunFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverRun
     */
    select?: DriverRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverRunInclude<ExtArgs> | null
    /**
     * Filter, which DriverRuns to fetch.
     */
    where?: DriverRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DriverRuns to fetch.
     */
    orderBy?: DriverRunOrderByWithRelationInput | DriverRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DriverRuns.
     */
    cursor?: DriverRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DriverRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DriverRuns.
     */
    skip?: number
    distinct?: DriverRunScalarFieldEnum | DriverRunScalarFieldEnum[]
  }

  /**
   * DriverRun create
   */
  export type DriverRunCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverRun
     */
    select?: DriverRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverRunInclude<ExtArgs> | null
    /**
     * The data needed to create a DriverRun.
     */
    data: XOR<DriverRunCreateInput, DriverRunUncheckedCreateInput>
  }

  /**
   * DriverRun createMany
   */
  export type DriverRunCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DriverRuns.
     */
    data: DriverRunCreateManyInput | DriverRunCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DriverRun createManyAndReturn
   */
  export type DriverRunCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverRun
     */
    select?: DriverRunSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DriverRuns.
     */
    data: DriverRunCreateManyInput | DriverRunCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverRunIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DriverRun update
   */
  export type DriverRunUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverRun
     */
    select?: DriverRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverRunInclude<ExtArgs> | null
    /**
     * The data needed to update a DriverRun.
     */
    data: XOR<DriverRunUpdateInput, DriverRunUncheckedUpdateInput>
    /**
     * Choose, which DriverRun to update.
     */
    where: DriverRunWhereUniqueInput
  }

  /**
   * DriverRun updateMany
   */
  export type DriverRunUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DriverRuns.
     */
    data: XOR<DriverRunUpdateManyMutationInput, DriverRunUncheckedUpdateManyInput>
    /**
     * Filter which DriverRuns to update
     */
    where?: DriverRunWhereInput
  }

  /**
   * DriverRun upsert
   */
  export type DriverRunUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverRun
     */
    select?: DriverRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverRunInclude<ExtArgs> | null
    /**
     * The filter to search for the DriverRun to update in case it exists.
     */
    where: DriverRunWhereUniqueInput
    /**
     * In case the DriverRun found by the `where` argument doesn't exist, create a new DriverRun with this data.
     */
    create: XOR<DriverRunCreateInput, DriverRunUncheckedCreateInput>
    /**
     * In case the DriverRun was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DriverRunUpdateInput, DriverRunUncheckedUpdateInput>
  }

  /**
   * DriverRun delete
   */
  export type DriverRunDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverRun
     */
    select?: DriverRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverRunInclude<ExtArgs> | null
    /**
     * Filter which DriverRun to delete.
     */
    where: DriverRunWhereUniqueInput
  }

  /**
   * DriverRun deleteMany
   */
  export type DriverRunDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DriverRuns to delete
     */
    where?: DriverRunWhereInput
  }

  /**
   * DriverRun.Duty
   */
  export type DriverRun$DutyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Duty
     */
    select?: DutySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DutyInclude<ExtArgs> | null
    where?: DutyWhereInput
    orderBy?: DutyOrderByWithRelationInput | DutyOrderByWithRelationInput[]
    cursor?: DutyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DutyScalarFieldEnum | DutyScalarFieldEnum[]
  }

  /**
   * DriverRun without action
   */
  export type DriverRunDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverRun
     */
    select?: DriverRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverRunInclude<ExtArgs> | null
  }


  /**
   * Model Duty
   */

  export type AggregateDuty = {
    _count: DutyCountAggregateOutputType | null
    _avg: DutyAvgAggregateOutputType | null
    _sum: DutySumAggregateOutputType | null
    _min: DutyMinAggregateOutputType | null
    _max: DutyMaxAggregateOutputType | null
  }

  export type DutyAvgAggregateOutputType = {
    id: number | null
    driverId: number | null
    vehicleId: number | null
    dutyTemplateId: number | null
    blockId: number | null
    runId: number | null
  }

  export type DutySumAggregateOutputType = {
    id: bigint | null
    driverId: bigint | null
    vehicleId: bigint | null
    dutyTemplateId: bigint | null
    blockId: bigint | null
    runId: bigint | null
  }

  export type DutyMinAggregateOutputType = {
    id: bigint | null
    date: Date | null
    startTime: Date | null
    endTime: Date | null
    driverId: bigint | null
    vehicleId: bigint | null
    dutyTemplateId: bigint | null
    blockId: bigint | null
    runId: bigint | null
    dutyType: $Enums.DutyType | null
  }

  export type DutyMaxAggregateOutputType = {
    id: bigint | null
    date: Date | null
    startTime: Date | null
    endTime: Date | null
    driverId: bigint | null
    vehicleId: bigint | null
    dutyTemplateId: bigint | null
    blockId: bigint | null
    runId: bigint | null
    dutyType: $Enums.DutyType | null
  }

  export type DutyCountAggregateOutputType = {
    id: number
    date: number
    startTime: number
    endTime: number
    driverId: number
    vehicleId: number
    dutyTemplateId: number
    blockId: number
    runId: number
    dutyType: number
    _all: number
  }


  export type DutyAvgAggregateInputType = {
    id?: true
    driverId?: true
    vehicleId?: true
    dutyTemplateId?: true
    blockId?: true
    runId?: true
  }

  export type DutySumAggregateInputType = {
    id?: true
    driverId?: true
    vehicleId?: true
    dutyTemplateId?: true
    blockId?: true
    runId?: true
  }

  export type DutyMinAggregateInputType = {
    id?: true
    date?: true
    startTime?: true
    endTime?: true
    driverId?: true
    vehicleId?: true
    dutyTemplateId?: true
    blockId?: true
    runId?: true
    dutyType?: true
  }

  export type DutyMaxAggregateInputType = {
    id?: true
    date?: true
    startTime?: true
    endTime?: true
    driverId?: true
    vehicleId?: true
    dutyTemplateId?: true
    blockId?: true
    runId?: true
    dutyType?: true
  }

  export type DutyCountAggregateInputType = {
    id?: true
    date?: true
    startTime?: true
    endTime?: true
    driverId?: true
    vehicleId?: true
    dutyTemplateId?: true
    blockId?: true
    runId?: true
    dutyType?: true
    _all?: true
  }

  export type DutyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Duty to aggregate.
     */
    where?: DutyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Duties to fetch.
     */
    orderBy?: DutyOrderByWithRelationInput | DutyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DutyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Duties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Duties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Duties
    **/
    _count?: true | DutyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DutyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DutySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DutyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DutyMaxAggregateInputType
  }

  export type GetDutyAggregateType<T extends DutyAggregateArgs> = {
        [P in keyof T & keyof AggregateDuty]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDuty[P]>
      : GetScalarType<T[P], AggregateDuty[P]>
  }




  export type DutyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DutyWhereInput
    orderBy?: DutyOrderByWithAggregationInput | DutyOrderByWithAggregationInput[]
    by: DutyScalarFieldEnum[] | DutyScalarFieldEnum
    having?: DutyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DutyCountAggregateInputType | true
    _avg?: DutyAvgAggregateInputType
    _sum?: DutySumAggregateInputType
    _min?: DutyMinAggregateInputType
    _max?: DutyMaxAggregateInputType
  }

  export type DutyGroupByOutputType = {
    id: bigint
    date: Date
    startTime: Date
    endTime: Date
    driverId: bigint | null
    vehicleId: bigint | null
    dutyTemplateId: bigint | null
    blockId: bigint | null
    runId: bigint | null
    dutyType: $Enums.DutyType
    _count: DutyCountAggregateOutputType | null
    _avg: DutyAvgAggregateOutputType | null
    _sum: DutySumAggregateOutputType | null
    _min: DutyMinAggregateOutputType | null
    _max: DutyMaxAggregateOutputType | null
  }

  type GetDutyGroupByPayload<T extends DutyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DutyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DutyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DutyGroupByOutputType[P]>
            : GetScalarType<T[P], DutyGroupByOutputType[P]>
        }
      >
    >


  export type DutySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    startTime?: boolean
    endTime?: boolean
    driverId?: boolean
    vehicleId?: boolean
    dutyTemplateId?: boolean
    blockId?: boolean
    runId?: boolean
    dutyType?: boolean
    block?: boolean | Duty$blockArgs<ExtArgs>
    run?: boolean | Duty$runArgs<ExtArgs>
    driver?: boolean | Duty$driverArgs<ExtArgs>
    vehicle?: boolean | Duty$vehicleArgs<ExtArgs>
    tripDuties?: boolean | Duty$tripDutiesArgs<ExtArgs>
    washingDuties?: boolean | Duty$washingDutiesArgs<ExtArgs>
    maintenanceDuties?: boolean | Duty$maintenanceDutiesArgs<ExtArgs>
    _count?: boolean | DutyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["duty"]>

  export type DutySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    startTime?: boolean
    endTime?: boolean
    driverId?: boolean
    vehicleId?: boolean
    dutyTemplateId?: boolean
    blockId?: boolean
    runId?: boolean
    dutyType?: boolean
    block?: boolean | Duty$blockArgs<ExtArgs>
    run?: boolean | Duty$runArgs<ExtArgs>
    driver?: boolean | Duty$driverArgs<ExtArgs>
    vehicle?: boolean | Duty$vehicleArgs<ExtArgs>
  }, ExtArgs["result"]["duty"]>

  export type DutySelectScalar = {
    id?: boolean
    date?: boolean
    startTime?: boolean
    endTime?: boolean
    driverId?: boolean
    vehicleId?: boolean
    dutyTemplateId?: boolean
    blockId?: boolean
    runId?: boolean
    dutyType?: boolean
  }

  export type DutyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    block?: boolean | Duty$blockArgs<ExtArgs>
    run?: boolean | Duty$runArgs<ExtArgs>
    driver?: boolean | Duty$driverArgs<ExtArgs>
    vehicle?: boolean | Duty$vehicleArgs<ExtArgs>
    tripDuties?: boolean | Duty$tripDutiesArgs<ExtArgs>
    washingDuties?: boolean | Duty$washingDutiesArgs<ExtArgs>
    maintenanceDuties?: boolean | Duty$maintenanceDutiesArgs<ExtArgs>
    _count?: boolean | DutyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DutyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    block?: boolean | Duty$blockArgs<ExtArgs>
    run?: boolean | Duty$runArgs<ExtArgs>
    driver?: boolean | Duty$driverArgs<ExtArgs>
    vehicle?: boolean | Duty$vehicleArgs<ExtArgs>
  }

  export type $DutyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Duty"
    objects: {
      block: Prisma.$VehicleBlockPayload<ExtArgs> | null
      run: Prisma.$DriverRunPayload<ExtArgs> | null
      driver: Prisma.$DriverPayload<ExtArgs> | null
      vehicle: Prisma.$VehiclePayload<ExtArgs> | null
      tripDuties: Prisma.$TripDutyPayload<ExtArgs>[]
      washingDuties: Prisma.$WashingDutyPayload<ExtArgs>[]
      maintenanceDuties: Prisma.$MaintenanceDutyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      date: Date
      startTime: Date
      endTime: Date
      driverId: bigint | null
      vehicleId: bigint | null
      dutyTemplateId: bigint | null
      blockId: bigint | null
      runId: bigint | null
      dutyType: $Enums.DutyType
    }, ExtArgs["result"]["duty"]>
    composites: {}
  }

  type DutyGetPayload<S extends boolean | null | undefined | DutyDefaultArgs> = $Result.GetResult<Prisma.$DutyPayload, S>

  type DutyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DutyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DutyCountAggregateInputType | true
    }

  export interface DutyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Duty'], meta: { name: 'Duty' } }
    /**
     * Find zero or one Duty that matches the filter.
     * @param {DutyFindUniqueArgs} args - Arguments to find a Duty
     * @example
     * // Get one Duty
     * const duty = await prisma.duty.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DutyFindUniqueArgs>(args: SelectSubset<T, DutyFindUniqueArgs<ExtArgs>>): Prisma__DutyClient<$Result.GetResult<Prisma.$DutyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Duty that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DutyFindUniqueOrThrowArgs} args - Arguments to find a Duty
     * @example
     * // Get one Duty
     * const duty = await prisma.duty.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DutyFindUniqueOrThrowArgs>(args: SelectSubset<T, DutyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DutyClient<$Result.GetResult<Prisma.$DutyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Duty that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DutyFindFirstArgs} args - Arguments to find a Duty
     * @example
     * // Get one Duty
     * const duty = await prisma.duty.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DutyFindFirstArgs>(args?: SelectSubset<T, DutyFindFirstArgs<ExtArgs>>): Prisma__DutyClient<$Result.GetResult<Prisma.$DutyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Duty that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DutyFindFirstOrThrowArgs} args - Arguments to find a Duty
     * @example
     * // Get one Duty
     * const duty = await prisma.duty.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DutyFindFirstOrThrowArgs>(args?: SelectSubset<T, DutyFindFirstOrThrowArgs<ExtArgs>>): Prisma__DutyClient<$Result.GetResult<Prisma.$DutyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Duties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DutyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Duties
     * const duties = await prisma.duty.findMany()
     * 
     * // Get first 10 Duties
     * const duties = await prisma.duty.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dutyWithIdOnly = await prisma.duty.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DutyFindManyArgs>(args?: SelectSubset<T, DutyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DutyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Duty.
     * @param {DutyCreateArgs} args - Arguments to create a Duty.
     * @example
     * // Create one Duty
     * const Duty = await prisma.duty.create({
     *   data: {
     *     // ... data to create a Duty
     *   }
     * })
     * 
     */
    create<T extends DutyCreateArgs>(args: SelectSubset<T, DutyCreateArgs<ExtArgs>>): Prisma__DutyClient<$Result.GetResult<Prisma.$DutyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Duties.
     * @param {DutyCreateManyArgs} args - Arguments to create many Duties.
     * @example
     * // Create many Duties
     * const duty = await prisma.duty.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DutyCreateManyArgs>(args?: SelectSubset<T, DutyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Duties and returns the data saved in the database.
     * @param {DutyCreateManyAndReturnArgs} args - Arguments to create many Duties.
     * @example
     * // Create many Duties
     * const duty = await prisma.duty.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Duties and only return the `id`
     * const dutyWithIdOnly = await prisma.duty.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DutyCreateManyAndReturnArgs>(args?: SelectSubset<T, DutyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DutyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Duty.
     * @param {DutyDeleteArgs} args - Arguments to delete one Duty.
     * @example
     * // Delete one Duty
     * const Duty = await prisma.duty.delete({
     *   where: {
     *     // ... filter to delete one Duty
     *   }
     * })
     * 
     */
    delete<T extends DutyDeleteArgs>(args: SelectSubset<T, DutyDeleteArgs<ExtArgs>>): Prisma__DutyClient<$Result.GetResult<Prisma.$DutyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Duty.
     * @param {DutyUpdateArgs} args - Arguments to update one Duty.
     * @example
     * // Update one Duty
     * const duty = await prisma.duty.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DutyUpdateArgs>(args: SelectSubset<T, DutyUpdateArgs<ExtArgs>>): Prisma__DutyClient<$Result.GetResult<Prisma.$DutyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Duties.
     * @param {DutyDeleteManyArgs} args - Arguments to filter Duties to delete.
     * @example
     * // Delete a few Duties
     * const { count } = await prisma.duty.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DutyDeleteManyArgs>(args?: SelectSubset<T, DutyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Duties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DutyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Duties
     * const duty = await prisma.duty.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DutyUpdateManyArgs>(args: SelectSubset<T, DutyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Duty.
     * @param {DutyUpsertArgs} args - Arguments to update or create a Duty.
     * @example
     * // Update or create a Duty
     * const duty = await prisma.duty.upsert({
     *   create: {
     *     // ... data to create a Duty
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Duty we want to update
     *   }
     * })
     */
    upsert<T extends DutyUpsertArgs>(args: SelectSubset<T, DutyUpsertArgs<ExtArgs>>): Prisma__DutyClient<$Result.GetResult<Prisma.$DutyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Duties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DutyCountArgs} args - Arguments to filter Duties to count.
     * @example
     * // Count the number of Duties
     * const count = await prisma.duty.count({
     *   where: {
     *     // ... the filter for the Duties we want to count
     *   }
     * })
    **/
    count<T extends DutyCountArgs>(
      args?: Subset<T, DutyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DutyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Duty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DutyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DutyAggregateArgs>(args: Subset<T, DutyAggregateArgs>): Prisma.PrismaPromise<GetDutyAggregateType<T>>

    /**
     * Group by Duty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DutyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DutyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DutyGroupByArgs['orderBy'] }
        : { orderBy?: DutyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DutyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDutyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Duty model
   */
  readonly fields: DutyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Duty.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DutyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    block<T extends Duty$blockArgs<ExtArgs> = {}>(args?: Subset<T, Duty$blockArgs<ExtArgs>>): Prisma__VehicleBlockClient<$Result.GetResult<Prisma.$VehicleBlockPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    run<T extends Duty$runArgs<ExtArgs> = {}>(args?: Subset<T, Duty$runArgs<ExtArgs>>): Prisma__DriverRunClient<$Result.GetResult<Prisma.$DriverRunPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    driver<T extends Duty$driverArgs<ExtArgs> = {}>(args?: Subset<T, Duty$driverArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    vehicle<T extends Duty$vehicleArgs<ExtArgs> = {}>(args?: Subset<T, Duty$vehicleArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    tripDuties<T extends Duty$tripDutiesArgs<ExtArgs> = {}>(args?: Subset<T, Duty$tripDutiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripDutyPayload<ExtArgs>, T, "findMany"> | Null>
    washingDuties<T extends Duty$washingDutiesArgs<ExtArgs> = {}>(args?: Subset<T, Duty$washingDutiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WashingDutyPayload<ExtArgs>, T, "findMany"> | Null>
    maintenanceDuties<T extends Duty$maintenanceDutiesArgs<ExtArgs> = {}>(args?: Subset<T, Duty$maintenanceDutiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenanceDutyPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Duty model
   */ 
  interface DutyFieldRefs {
    readonly id: FieldRef<"Duty", 'BigInt'>
    readonly date: FieldRef<"Duty", 'DateTime'>
    readonly startTime: FieldRef<"Duty", 'DateTime'>
    readonly endTime: FieldRef<"Duty", 'DateTime'>
    readonly driverId: FieldRef<"Duty", 'BigInt'>
    readonly vehicleId: FieldRef<"Duty", 'BigInt'>
    readonly dutyTemplateId: FieldRef<"Duty", 'BigInt'>
    readonly blockId: FieldRef<"Duty", 'BigInt'>
    readonly runId: FieldRef<"Duty", 'BigInt'>
    readonly dutyType: FieldRef<"Duty", 'DutyType'>
  }
    

  // Custom InputTypes
  /**
   * Duty findUnique
   */
  export type DutyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Duty
     */
    select?: DutySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DutyInclude<ExtArgs> | null
    /**
     * Filter, which Duty to fetch.
     */
    where: DutyWhereUniqueInput
  }

  /**
   * Duty findUniqueOrThrow
   */
  export type DutyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Duty
     */
    select?: DutySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DutyInclude<ExtArgs> | null
    /**
     * Filter, which Duty to fetch.
     */
    where: DutyWhereUniqueInput
  }

  /**
   * Duty findFirst
   */
  export type DutyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Duty
     */
    select?: DutySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DutyInclude<ExtArgs> | null
    /**
     * Filter, which Duty to fetch.
     */
    where?: DutyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Duties to fetch.
     */
    orderBy?: DutyOrderByWithRelationInput | DutyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Duties.
     */
    cursor?: DutyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Duties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Duties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Duties.
     */
    distinct?: DutyScalarFieldEnum | DutyScalarFieldEnum[]
  }

  /**
   * Duty findFirstOrThrow
   */
  export type DutyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Duty
     */
    select?: DutySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DutyInclude<ExtArgs> | null
    /**
     * Filter, which Duty to fetch.
     */
    where?: DutyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Duties to fetch.
     */
    orderBy?: DutyOrderByWithRelationInput | DutyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Duties.
     */
    cursor?: DutyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Duties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Duties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Duties.
     */
    distinct?: DutyScalarFieldEnum | DutyScalarFieldEnum[]
  }

  /**
   * Duty findMany
   */
  export type DutyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Duty
     */
    select?: DutySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DutyInclude<ExtArgs> | null
    /**
     * Filter, which Duties to fetch.
     */
    where?: DutyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Duties to fetch.
     */
    orderBy?: DutyOrderByWithRelationInput | DutyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Duties.
     */
    cursor?: DutyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Duties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Duties.
     */
    skip?: number
    distinct?: DutyScalarFieldEnum | DutyScalarFieldEnum[]
  }

  /**
   * Duty create
   */
  export type DutyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Duty
     */
    select?: DutySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DutyInclude<ExtArgs> | null
    /**
     * The data needed to create a Duty.
     */
    data: XOR<DutyCreateInput, DutyUncheckedCreateInput>
  }

  /**
   * Duty createMany
   */
  export type DutyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Duties.
     */
    data: DutyCreateManyInput | DutyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Duty createManyAndReturn
   */
  export type DutyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Duty
     */
    select?: DutySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Duties.
     */
    data: DutyCreateManyInput | DutyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DutyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Duty update
   */
  export type DutyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Duty
     */
    select?: DutySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DutyInclude<ExtArgs> | null
    /**
     * The data needed to update a Duty.
     */
    data: XOR<DutyUpdateInput, DutyUncheckedUpdateInput>
    /**
     * Choose, which Duty to update.
     */
    where: DutyWhereUniqueInput
  }

  /**
   * Duty updateMany
   */
  export type DutyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Duties.
     */
    data: XOR<DutyUpdateManyMutationInput, DutyUncheckedUpdateManyInput>
    /**
     * Filter which Duties to update
     */
    where?: DutyWhereInput
  }

  /**
   * Duty upsert
   */
  export type DutyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Duty
     */
    select?: DutySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DutyInclude<ExtArgs> | null
    /**
     * The filter to search for the Duty to update in case it exists.
     */
    where: DutyWhereUniqueInput
    /**
     * In case the Duty found by the `where` argument doesn't exist, create a new Duty with this data.
     */
    create: XOR<DutyCreateInput, DutyUncheckedCreateInput>
    /**
     * In case the Duty was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DutyUpdateInput, DutyUncheckedUpdateInput>
  }

  /**
   * Duty delete
   */
  export type DutyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Duty
     */
    select?: DutySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DutyInclude<ExtArgs> | null
    /**
     * Filter which Duty to delete.
     */
    where: DutyWhereUniqueInput
  }

  /**
   * Duty deleteMany
   */
  export type DutyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Duties to delete
     */
    where?: DutyWhereInput
  }

  /**
   * Duty.block
   */
  export type Duty$blockArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleBlock
     */
    select?: VehicleBlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleBlockInclude<ExtArgs> | null
    where?: VehicleBlockWhereInput
  }

  /**
   * Duty.run
   */
  export type Duty$runArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverRun
     */
    select?: DriverRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverRunInclude<ExtArgs> | null
    where?: DriverRunWhereInput
  }

  /**
   * Duty.driver
   */
  export type Duty$driverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    where?: DriverWhereInput
  }

  /**
   * Duty.vehicle
   */
  export type Duty$vehicleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    where?: VehicleWhereInput
  }

  /**
   * Duty.tripDuties
   */
  export type Duty$tripDutiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripDuty
     */
    select?: TripDutySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripDutyInclude<ExtArgs> | null
    where?: TripDutyWhereInput
    orderBy?: TripDutyOrderByWithRelationInput | TripDutyOrderByWithRelationInput[]
    cursor?: TripDutyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TripDutyScalarFieldEnum | TripDutyScalarFieldEnum[]
  }

  /**
   * Duty.washingDuties
   */
  export type Duty$washingDutiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WashingDuty
     */
    select?: WashingDutySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WashingDutyInclude<ExtArgs> | null
    where?: WashingDutyWhereInput
    orderBy?: WashingDutyOrderByWithRelationInput | WashingDutyOrderByWithRelationInput[]
    cursor?: WashingDutyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WashingDutyScalarFieldEnum | WashingDutyScalarFieldEnum[]
  }

  /**
   * Duty.maintenanceDuties
   */
  export type Duty$maintenanceDutiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceDuty
     */
    select?: MaintenanceDutySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceDutyInclude<ExtArgs> | null
    where?: MaintenanceDutyWhereInput
    orderBy?: MaintenanceDutyOrderByWithRelationInput | MaintenanceDutyOrderByWithRelationInput[]
    cursor?: MaintenanceDutyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaintenanceDutyScalarFieldEnum | MaintenanceDutyScalarFieldEnum[]
  }

  /**
   * Duty without action
   */
  export type DutyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Duty
     */
    select?: DutySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DutyInclude<ExtArgs> | null
  }


  /**
   * Model TripDuty
   */

  export type AggregateTripDuty = {
    _count: TripDutyCountAggregateOutputType | null
    _avg: TripDutyAvgAggregateOutputType | null
    _sum: TripDutySumAggregateOutputType | null
    _min: TripDutyMinAggregateOutputType | null
    _max: TripDutyMaxAggregateOutputType | null
  }

  export type TripDutyAvgAggregateOutputType = {
    id: number | null
    dutyId: number | null
    routeId: number | null
  }

  export type TripDutySumAggregateOutputType = {
    id: bigint | null
    dutyId: bigint | null
    routeId: bigint | null
  }

  export type TripDutyMinAggregateOutputType = {
    id: bigint | null
    dutyId: bigint | null
    routeId: bigint | null
  }

  export type TripDutyMaxAggregateOutputType = {
    id: bigint | null
    dutyId: bigint | null
    routeId: bigint | null
  }

  export type TripDutyCountAggregateOutputType = {
    id: number
    dutyId: number
    routeId: number
    _all: number
  }


  export type TripDutyAvgAggregateInputType = {
    id?: true
    dutyId?: true
    routeId?: true
  }

  export type TripDutySumAggregateInputType = {
    id?: true
    dutyId?: true
    routeId?: true
  }

  export type TripDutyMinAggregateInputType = {
    id?: true
    dutyId?: true
    routeId?: true
  }

  export type TripDutyMaxAggregateInputType = {
    id?: true
    dutyId?: true
    routeId?: true
  }

  export type TripDutyCountAggregateInputType = {
    id?: true
    dutyId?: true
    routeId?: true
    _all?: true
  }

  export type TripDutyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TripDuty to aggregate.
     */
    where?: TripDutyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TripDuties to fetch.
     */
    orderBy?: TripDutyOrderByWithRelationInput | TripDutyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TripDutyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TripDuties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TripDuties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TripDuties
    **/
    _count?: true | TripDutyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TripDutyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TripDutySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TripDutyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TripDutyMaxAggregateInputType
  }

  export type GetTripDutyAggregateType<T extends TripDutyAggregateArgs> = {
        [P in keyof T & keyof AggregateTripDuty]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTripDuty[P]>
      : GetScalarType<T[P], AggregateTripDuty[P]>
  }




  export type TripDutyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TripDutyWhereInput
    orderBy?: TripDutyOrderByWithAggregationInput | TripDutyOrderByWithAggregationInput[]
    by: TripDutyScalarFieldEnum[] | TripDutyScalarFieldEnum
    having?: TripDutyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TripDutyCountAggregateInputType | true
    _avg?: TripDutyAvgAggregateInputType
    _sum?: TripDutySumAggregateInputType
    _min?: TripDutyMinAggregateInputType
    _max?: TripDutyMaxAggregateInputType
  }

  export type TripDutyGroupByOutputType = {
    id: bigint
    dutyId: bigint
    routeId: bigint
    _count: TripDutyCountAggregateOutputType | null
    _avg: TripDutyAvgAggregateOutputType | null
    _sum: TripDutySumAggregateOutputType | null
    _min: TripDutyMinAggregateOutputType | null
    _max: TripDutyMaxAggregateOutputType | null
  }

  type GetTripDutyGroupByPayload<T extends TripDutyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TripDutyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TripDutyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TripDutyGroupByOutputType[P]>
            : GetScalarType<T[P], TripDutyGroupByOutputType[P]>
        }
      >
    >


  export type TripDutySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dutyId?: boolean
    routeId?: boolean
    duty?: boolean | DutyDefaultArgs<ExtArgs>
    route?: boolean | RouteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tripDuty"]>

  export type TripDutySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dutyId?: boolean
    routeId?: boolean
    duty?: boolean | DutyDefaultArgs<ExtArgs>
    route?: boolean | RouteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tripDuty"]>

  export type TripDutySelectScalar = {
    id?: boolean
    dutyId?: boolean
    routeId?: boolean
  }

  export type TripDutyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    duty?: boolean | DutyDefaultArgs<ExtArgs>
    route?: boolean | RouteDefaultArgs<ExtArgs>
  }
  export type TripDutyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    duty?: boolean | DutyDefaultArgs<ExtArgs>
    route?: boolean | RouteDefaultArgs<ExtArgs>
  }

  export type $TripDutyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TripDuty"
    objects: {
      duty: Prisma.$DutyPayload<ExtArgs>
      route: Prisma.$RoutePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      dutyId: bigint
      routeId: bigint
    }, ExtArgs["result"]["tripDuty"]>
    composites: {}
  }

  type TripDutyGetPayload<S extends boolean | null | undefined | TripDutyDefaultArgs> = $Result.GetResult<Prisma.$TripDutyPayload, S>

  type TripDutyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TripDutyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TripDutyCountAggregateInputType | true
    }

  export interface TripDutyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TripDuty'], meta: { name: 'TripDuty' } }
    /**
     * Find zero or one TripDuty that matches the filter.
     * @param {TripDutyFindUniqueArgs} args - Arguments to find a TripDuty
     * @example
     * // Get one TripDuty
     * const tripDuty = await prisma.tripDuty.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TripDutyFindUniqueArgs>(args: SelectSubset<T, TripDutyFindUniqueArgs<ExtArgs>>): Prisma__TripDutyClient<$Result.GetResult<Prisma.$TripDutyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TripDuty that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TripDutyFindUniqueOrThrowArgs} args - Arguments to find a TripDuty
     * @example
     * // Get one TripDuty
     * const tripDuty = await prisma.tripDuty.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TripDutyFindUniqueOrThrowArgs>(args: SelectSubset<T, TripDutyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TripDutyClient<$Result.GetResult<Prisma.$TripDutyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TripDuty that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripDutyFindFirstArgs} args - Arguments to find a TripDuty
     * @example
     * // Get one TripDuty
     * const tripDuty = await prisma.tripDuty.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TripDutyFindFirstArgs>(args?: SelectSubset<T, TripDutyFindFirstArgs<ExtArgs>>): Prisma__TripDutyClient<$Result.GetResult<Prisma.$TripDutyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TripDuty that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripDutyFindFirstOrThrowArgs} args - Arguments to find a TripDuty
     * @example
     * // Get one TripDuty
     * const tripDuty = await prisma.tripDuty.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TripDutyFindFirstOrThrowArgs>(args?: SelectSubset<T, TripDutyFindFirstOrThrowArgs<ExtArgs>>): Prisma__TripDutyClient<$Result.GetResult<Prisma.$TripDutyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TripDuties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripDutyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TripDuties
     * const tripDuties = await prisma.tripDuty.findMany()
     * 
     * // Get first 10 TripDuties
     * const tripDuties = await prisma.tripDuty.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tripDutyWithIdOnly = await prisma.tripDuty.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TripDutyFindManyArgs>(args?: SelectSubset<T, TripDutyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripDutyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TripDuty.
     * @param {TripDutyCreateArgs} args - Arguments to create a TripDuty.
     * @example
     * // Create one TripDuty
     * const TripDuty = await prisma.tripDuty.create({
     *   data: {
     *     // ... data to create a TripDuty
     *   }
     * })
     * 
     */
    create<T extends TripDutyCreateArgs>(args: SelectSubset<T, TripDutyCreateArgs<ExtArgs>>): Prisma__TripDutyClient<$Result.GetResult<Prisma.$TripDutyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TripDuties.
     * @param {TripDutyCreateManyArgs} args - Arguments to create many TripDuties.
     * @example
     * // Create many TripDuties
     * const tripDuty = await prisma.tripDuty.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TripDutyCreateManyArgs>(args?: SelectSubset<T, TripDutyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TripDuties and returns the data saved in the database.
     * @param {TripDutyCreateManyAndReturnArgs} args - Arguments to create many TripDuties.
     * @example
     * // Create many TripDuties
     * const tripDuty = await prisma.tripDuty.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TripDuties and only return the `id`
     * const tripDutyWithIdOnly = await prisma.tripDuty.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TripDutyCreateManyAndReturnArgs>(args?: SelectSubset<T, TripDutyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripDutyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TripDuty.
     * @param {TripDutyDeleteArgs} args - Arguments to delete one TripDuty.
     * @example
     * // Delete one TripDuty
     * const TripDuty = await prisma.tripDuty.delete({
     *   where: {
     *     // ... filter to delete one TripDuty
     *   }
     * })
     * 
     */
    delete<T extends TripDutyDeleteArgs>(args: SelectSubset<T, TripDutyDeleteArgs<ExtArgs>>): Prisma__TripDutyClient<$Result.GetResult<Prisma.$TripDutyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TripDuty.
     * @param {TripDutyUpdateArgs} args - Arguments to update one TripDuty.
     * @example
     * // Update one TripDuty
     * const tripDuty = await prisma.tripDuty.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TripDutyUpdateArgs>(args: SelectSubset<T, TripDutyUpdateArgs<ExtArgs>>): Prisma__TripDutyClient<$Result.GetResult<Prisma.$TripDutyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TripDuties.
     * @param {TripDutyDeleteManyArgs} args - Arguments to filter TripDuties to delete.
     * @example
     * // Delete a few TripDuties
     * const { count } = await prisma.tripDuty.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TripDutyDeleteManyArgs>(args?: SelectSubset<T, TripDutyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TripDuties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripDutyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TripDuties
     * const tripDuty = await prisma.tripDuty.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TripDutyUpdateManyArgs>(args: SelectSubset<T, TripDutyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TripDuty.
     * @param {TripDutyUpsertArgs} args - Arguments to update or create a TripDuty.
     * @example
     * // Update or create a TripDuty
     * const tripDuty = await prisma.tripDuty.upsert({
     *   create: {
     *     // ... data to create a TripDuty
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TripDuty we want to update
     *   }
     * })
     */
    upsert<T extends TripDutyUpsertArgs>(args: SelectSubset<T, TripDutyUpsertArgs<ExtArgs>>): Prisma__TripDutyClient<$Result.GetResult<Prisma.$TripDutyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TripDuties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripDutyCountArgs} args - Arguments to filter TripDuties to count.
     * @example
     * // Count the number of TripDuties
     * const count = await prisma.tripDuty.count({
     *   where: {
     *     // ... the filter for the TripDuties we want to count
     *   }
     * })
    **/
    count<T extends TripDutyCountArgs>(
      args?: Subset<T, TripDutyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TripDutyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TripDuty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripDutyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TripDutyAggregateArgs>(args: Subset<T, TripDutyAggregateArgs>): Prisma.PrismaPromise<GetTripDutyAggregateType<T>>

    /**
     * Group by TripDuty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripDutyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TripDutyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TripDutyGroupByArgs['orderBy'] }
        : { orderBy?: TripDutyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TripDutyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTripDutyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TripDuty model
   */
  readonly fields: TripDutyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TripDuty.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TripDutyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    duty<T extends DutyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DutyDefaultArgs<ExtArgs>>): Prisma__DutyClient<$Result.GetResult<Prisma.$DutyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    route<T extends RouteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RouteDefaultArgs<ExtArgs>>): Prisma__RouteClient<$Result.GetResult<Prisma.$RoutePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TripDuty model
   */ 
  interface TripDutyFieldRefs {
    readonly id: FieldRef<"TripDuty", 'BigInt'>
    readonly dutyId: FieldRef<"TripDuty", 'BigInt'>
    readonly routeId: FieldRef<"TripDuty", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * TripDuty findUnique
   */
  export type TripDutyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripDuty
     */
    select?: TripDutySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripDutyInclude<ExtArgs> | null
    /**
     * Filter, which TripDuty to fetch.
     */
    where: TripDutyWhereUniqueInput
  }

  /**
   * TripDuty findUniqueOrThrow
   */
  export type TripDutyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripDuty
     */
    select?: TripDutySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripDutyInclude<ExtArgs> | null
    /**
     * Filter, which TripDuty to fetch.
     */
    where: TripDutyWhereUniqueInput
  }

  /**
   * TripDuty findFirst
   */
  export type TripDutyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripDuty
     */
    select?: TripDutySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripDutyInclude<ExtArgs> | null
    /**
     * Filter, which TripDuty to fetch.
     */
    where?: TripDutyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TripDuties to fetch.
     */
    orderBy?: TripDutyOrderByWithRelationInput | TripDutyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TripDuties.
     */
    cursor?: TripDutyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TripDuties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TripDuties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TripDuties.
     */
    distinct?: TripDutyScalarFieldEnum | TripDutyScalarFieldEnum[]
  }

  /**
   * TripDuty findFirstOrThrow
   */
  export type TripDutyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripDuty
     */
    select?: TripDutySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripDutyInclude<ExtArgs> | null
    /**
     * Filter, which TripDuty to fetch.
     */
    where?: TripDutyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TripDuties to fetch.
     */
    orderBy?: TripDutyOrderByWithRelationInput | TripDutyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TripDuties.
     */
    cursor?: TripDutyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TripDuties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TripDuties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TripDuties.
     */
    distinct?: TripDutyScalarFieldEnum | TripDutyScalarFieldEnum[]
  }

  /**
   * TripDuty findMany
   */
  export type TripDutyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripDuty
     */
    select?: TripDutySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripDutyInclude<ExtArgs> | null
    /**
     * Filter, which TripDuties to fetch.
     */
    where?: TripDutyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TripDuties to fetch.
     */
    orderBy?: TripDutyOrderByWithRelationInput | TripDutyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TripDuties.
     */
    cursor?: TripDutyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TripDuties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TripDuties.
     */
    skip?: number
    distinct?: TripDutyScalarFieldEnum | TripDutyScalarFieldEnum[]
  }

  /**
   * TripDuty create
   */
  export type TripDutyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripDuty
     */
    select?: TripDutySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripDutyInclude<ExtArgs> | null
    /**
     * The data needed to create a TripDuty.
     */
    data: XOR<TripDutyCreateInput, TripDutyUncheckedCreateInput>
  }

  /**
   * TripDuty createMany
   */
  export type TripDutyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TripDuties.
     */
    data: TripDutyCreateManyInput | TripDutyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TripDuty createManyAndReturn
   */
  export type TripDutyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripDuty
     */
    select?: TripDutySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TripDuties.
     */
    data: TripDutyCreateManyInput | TripDutyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripDutyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TripDuty update
   */
  export type TripDutyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripDuty
     */
    select?: TripDutySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripDutyInclude<ExtArgs> | null
    /**
     * The data needed to update a TripDuty.
     */
    data: XOR<TripDutyUpdateInput, TripDutyUncheckedUpdateInput>
    /**
     * Choose, which TripDuty to update.
     */
    where: TripDutyWhereUniqueInput
  }

  /**
   * TripDuty updateMany
   */
  export type TripDutyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TripDuties.
     */
    data: XOR<TripDutyUpdateManyMutationInput, TripDutyUncheckedUpdateManyInput>
    /**
     * Filter which TripDuties to update
     */
    where?: TripDutyWhereInput
  }

  /**
   * TripDuty upsert
   */
  export type TripDutyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripDuty
     */
    select?: TripDutySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripDutyInclude<ExtArgs> | null
    /**
     * The filter to search for the TripDuty to update in case it exists.
     */
    where: TripDutyWhereUniqueInput
    /**
     * In case the TripDuty found by the `where` argument doesn't exist, create a new TripDuty with this data.
     */
    create: XOR<TripDutyCreateInput, TripDutyUncheckedCreateInput>
    /**
     * In case the TripDuty was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TripDutyUpdateInput, TripDutyUncheckedUpdateInput>
  }

  /**
   * TripDuty delete
   */
  export type TripDutyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripDuty
     */
    select?: TripDutySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripDutyInclude<ExtArgs> | null
    /**
     * Filter which TripDuty to delete.
     */
    where: TripDutyWhereUniqueInput
  }

  /**
   * TripDuty deleteMany
   */
  export type TripDutyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TripDuties to delete
     */
    where?: TripDutyWhereInput
  }

  /**
   * TripDuty without action
   */
  export type TripDutyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripDuty
     */
    select?: TripDutySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripDutyInclude<ExtArgs> | null
  }


  /**
   * Model WashingDuty
   */

  export type AggregateWashingDuty = {
    _count: WashingDutyCountAggregateOutputType | null
    _avg: WashingDutyAvgAggregateOutputType | null
    _sum: WashingDutySumAggregateOutputType | null
    _min: WashingDutyMinAggregateOutputType | null
    _max: WashingDutyMaxAggregateOutputType | null
  }

  export type WashingDutyAvgAggregateOutputType = {
    id: number | null
    dutyId: number | null
  }

  export type WashingDutySumAggregateOutputType = {
    id: bigint | null
    dutyId: bigint | null
  }

  export type WashingDutyMinAggregateOutputType = {
    id: bigint | null
    dutyId: bigint | null
  }

  export type WashingDutyMaxAggregateOutputType = {
    id: bigint | null
    dutyId: bigint | null
  }

  export type WashingDutyCountAggregateOutputType = {
    id: number
    dutyId: number
    _all: number
  }


  export type WashingDutyAvgAggregateInputType = {
    id?: true
    dutyId?: true
  }

  export type WashingDutySumAggregateInputType = {
    id?: true
    dutyId?: true
  }

  export type WashingDutyMinAggregateInputType = {
    id?: true
    dutyId?: true
  }

  export type WashingDutyMaxAggregateInputType = {
    id?: true
    dutyId?: true
  }

  export type WashingDutyCountAggregateInputType = {
    id?: true
    dutyId?: true
    _all?: true
  }

  export type WashingDutyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WashingDuty to aggregate.
     */
    where?: WashingDutyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WashingDuties to fetch.
     */
    orderBy?: WashingDutyOrderByWithRelationInput | WashingDutyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WashingDutyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WashingDuties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WashingDuties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WashingDuties
    **/
    _count?: true | WashingDutyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WashingDutyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WashingDutySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WashingDutyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WashingDutyMaxAggregateInputType
  }

  export type GetWashingDutyAggregateType<T extends WashingDutyAggregateArgs> = {
        [P in keyof T & keyof AggregateWashingDuty]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWashingDuty[P]>
      : GetScalarType<T[P], AggregateWashingDuty[P]>
  }




  export type WashingDutyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WashingDutyWhereInput
    orderBy?: WashingDutyOrderByWithAggregationInput | WashingDutyOrderByWithAggregationInput[]
    by: WashingDutyScalarFieldEnum[] | WashingDutyScalarFieldEnum
    having?: WashingDutyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WashingDutyCountAggregateInputType | true
    _avg?: WashingDutyAvgAggregateInputType
    _sum?: WashingDutySumAggregateInputType
    _min?: WashingDutyMinAggregateInputType
    _max?: WashingDutyMaxAggregateInputType
  }

  export type WashingDutyGroupByOutputType = {
    id: bigint
    dutyId: bigint
    _count: WashingDutyCountAggregateOutputType | null
    _avg: WashingDutyAvgAggregateOutputType | null
    _sum: WashingDutySumAggregateOutputType | null
    _min: WashingDutyMinAggregateOutputType | null
    _max: WashingDutyMaxAggregateOutputType | null
  }

  type GetWashingDutyGroupByPayload<T extends WashingDutyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WashingDutyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WashingDutyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WashingDutyGroupByOutputType[P]>
            : GetScalarType<T[P], WashingDutyGroupByOutputType[P]>
        }
      >
    >


  export type WashingDutySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dutyId?: boolean
    duty?: boolean | DutyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["washingDuty"]>

  export type WashingDutySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dutyId?: boolean
    duty?: boolean | DutyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["washingDuty"]>

  export type WashingDutySelectScalar = {
    id?: boolean
    dutyId?: boolean
  }

  export type WashingDutyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    duty?: boolean | DutyDefaultArgs<ExtArgs>
  }
  export type WashingDutyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    duty?: boolean | DutyDefaultArgs<ExtArgs>
  }

  export type $WashingDutyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WashingDuty"
    objects: {
      duty: Prisma.$DutyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      dutyId: bigint
    }, ExtArgs["result"]["washingDuty"]>
    composites: {}
  }

  type WashingDutyGetPayload<S extends boolean | null | undefined | WashingDutyDefaultArgs> = $Result.GetResult<Prisma.$WashingDutyPayload, S>

  type WashingDutyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WashingDutyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WashingDutyCountAggregateInputType | true
    }

  export interface WashingDutyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WashingDuty'], meta: { name: 'WashingDuty' } }
    /**
     * Find zero or one WashingDuty that matches the filter.
     * @param {WashingDutyFindUniqueArgs} args - Arguments to find a WashingDuty
     * @example
     * // Get one WashingDuty
     * const washingDuty = await prisma.washingDuty.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WashingDutyFindUniqueArgs>(args: SelectSubset<T, WashingDutyFindUniqueArgs<ExtArgs>>): Prisma__WashingDutyClient<$Result.GetResult<Prisma.$WashingDutyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WashingDuty that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WashingDutyFindUniqueOrThrowArgs} args - Arguments to find a WashingDuty
     * @example
     * // Get one WashingDuty
     * const washingDuty = await prisma.washingDuty.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WashingDutyFindUniqueOrThrowArgs>(args: SelectSubset<T, WashingDutyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WashingDutyClient<$Result.GetResult<Prisma.$WashingDutyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WashingDuty that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WashingDutyFindFirstArgs} args - Arguments to find a WashingDuty
     * @example
     * // Get one WashingDuty
     * const washingDuty = await prisma.washingDuty.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WashingDutyFindFirstArgs>(args?: SelectSubset<T, WashingDutyFindFirstArgs<ExtArgs>>): Prisma__WashingDutyClient<$Result.GetResult<Prisma.$WashingDutyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WashingDuty that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WashingDutyFindFirstOrThrowArgs} args - Arguments to find a WashingDuty
     * @example
     * // Get one WashingDuty
     * const washingDuty = await prisma.washingDuty.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WashingDutyFindFirstOrThrowArgs>(args?: SelectSubset<T, WashingDutyFindFirstOrThrowArgs<ExtArgs>>): Prisma__WashingDutyClient<$Result.GetResult<Prisma.$WashingDutyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WashingDuties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WashingDutyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WashingDuties
     * const washingDuties = await prisma.washingDuty.findMany()
     * 
     * // Get first 10 WashingDuties
     * const washingDuties = await prisma.washingDuty.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const washingDutyWithIdOnly = await prisma.washingDuty.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WashingDutyFindManyArgs>(args?: SelectSubset<T, WashingDutyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WashingDutyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WashingDuty.
     * @param {WashingDutyCreateArgs} args - Arguments to create a WashingDuty.
     * @example
     * // Create one WashingDuty
     * const WashingDuty = await prisma.washingDuty.create({
     *   data: {
     *     // ... data to create a WashingDuty
     *   }
     * })
     * 
     */
    create<T extends WashingDutyCreateArgs>(args: SelectSubset<T, WashingDutyCreateArgs<ExtArgs>>): Prisma__WashingDutyClient<$Result.GetResult<Prisma.$WashingDutyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WashingDuties.
     * @param {WashingDutyCreateManyArgs} args - Arguments to create many WashingDuties.
     * @example
     * // Create many WashingDuties
     * const washingDuty = await prisma.washingDuty.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WashingDutyCreateManyArgs>(args?: SelectSubset<T, WashingDutyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WashingDuties and returns the data saved in the database.
     * @param {WashingDutyCreateManyAndReturnArgs} args - Arguments to create many WashingDuties.
     * @example
     * // Create many WashingDuties
     * const washingDuty = await prisma.washingDuty.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WashingDuties and only return the `id`
     * const washingDutyWithIdOnly = await prisma.washingDuty.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WashingDutyCreateManyAndReturnArgs>(args?: SelectSubset<T, WashingDutyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WashingDutyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WashingDuty.
     * @param {WashingDutyDeleteArgs} args - Arguments to delete one WashingDuty.
     * @example
     * // Delete one WashingDuty
     * const WashingDuty = await prisma.washingDuty.delete({
     *   where: {
     *     // ... filter to delete one WashingDuty
     *   }
     * })
     * 
     */
    delete<T extends WashingDutyDeleteArgs>(args: SelectSubset<T, WashingDutyDeleteArgs<ExtArgs>>): Prisma__WashingDutyClient<$Result.GetResult<Prisma.$WashingDutyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WashingDuty.
     * @param {WashingDutyUpdateArgs} args - Arguments to update one WashingDuty.
     * @example
     * // Update one WashingDuty
     * const washingDuty = await prisma.washingDuty.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WashingDutyUpdateArgs>(args: SelectSubset<T, WashingDutyUpdateArgs<ExtArgs>>): Prisma__WashingDutyClient<$Result.GetResult<Prisma.$WashingDutyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WashingDuties.
     * @param {WashingDutyDeleteManyArgs} args - Arguments to filter WashingDuties to delete.
     * @example
     * // Delete a few WashingDuties
     * const { count } = await prisma.washingDuty.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WashingDutyDeleteManyArgs>(args?: SelectSubset<T, WashingDutyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WashingDuties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WashingDutyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WashingDuties
     * const washingDuty = await prisma.washingDuty.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WashingDutyUpdateManyArgs>(args: SelectSubset<T, WashingDutyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WashingDuty.
     * @param {WashingDutyUpsertArgs} args - Arguments to update or create a WashingDuty.
     * @example
     * // Update or create a WashingDuty
     * const washingDuty = await prisma.washingDuty.upsert({
     *   create: {
     *     // ... data to create a WashingDuty
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WashingDuty we want to update
     *   }
     * })
     */
    upsert<T extends WashingDutyUpsertArgs>(args: SelectSubset<T, WashingDutyUpsertArgs<ExtArgs>>): Prisma__WashingDutyClient<$Result.GetResult<Prisma.$WashingDutyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WashingDuties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WashingDutyCountArgs} args - Arguments to filter WashingDuties to count.
     * @example
     * // Count the number of WashingDuties
     * const count = await prisma.washingDuty.count({
     *   where: {
     *     // ... the filter for the WashingDuties we want to count
     *   }
     * })
    **/
    count<T extends WashingDutyCountArgs>(
      args?: Subset<T, WashingDutyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WashingDutyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WashingDuty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WashingDutyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WashingDutyAggregateArgs>(args: Subset<T, WashingDutyAggregateArgs>): Prisma.PrismaPromise<GetWashingDutyAggregateType<T>>

    /**
     * Group by WashingDuty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WashingDutyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WashingDutyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WashingDutyGroupByArgs['orderBy'] }
        : { orderBy?: WashingDutyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WashingDutyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWashingDutyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WashingDuty model
   */
  readonly fields: WashingDutyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WashingDuty.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WashingDutyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    duty<T extends DutyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DutyDefaultArgs<ExtArgs>>): Prisma__DutyClient<$Result.GetResult<Prisma.$DutyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WashingDuty model
   */ 
  interface WashingDutyFieldRefs {
    readonly id: FieldRef<"WashingDuty", 'BigInt'>
    readonly dutyId: FieldRef<"WashingDuty", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * WashingDuty findUnique
   */
  export type WashingDutyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WashingDuty
     */
    select?: WashingDutySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WashingDutyInclude<ExtArgs> | null
    /**
     * Filter, which WashingDuty to fetch.
     */
    where: WashingDutyWhereUniqueInput
  }

  /**
   * WashingDuty findUniqueOrThrow
   */
  export type WashingDutyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WashingDuty
     */
    select?: WashingDutySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WashingDutyInclude<ExtArgs> | null
    /**
     * Filter, which WashingDuty to fetch.
     */
    where: WashingDutyWhereUniqueInput
  }

  /**
   * WashingDuty findFirst
   */
  export type WashingDutyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WashingDuty
     */
    select?: WashingDutySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WashingDutyInclude<ExtArgs> | null
    /**
     * Filter, which WashingDuty to fetch.
     */
    where?: WashingDutyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WashingDuties to fetch.
     */
    orderBy?: WashingDutyOrderByWithRelationInput | WashingDutyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WashingDuties.
     */
    cursor?: WashingDutyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WashingDuties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WashingDuties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WashingDuties.
     */
    distinct?: WashingDutyScalarFieldEnum | WashingDutyScalarFieldEnum[]
  }

  /**
   * WashingDuty findFirstOrThrow
   */
  export type WashingDutyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WashingDuty
     */
    select?: WashingDutySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WashingDutyInclude<ExtArgs> | null
    /**
     * Filter, which WashingDuty to fetch.
     */
    where?: WashingDutyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WashingDuties to fetch.
     */
    orderBy?: WashingDutyOrderByWithRelationInput | WashingDutyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WashingDuties.
     */
    cursor?: WashingDutyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WashingDuties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WashingDuties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WashingDuties.
     */
    distinct?: WashingDutyScalarFieldEnum | WashingDutyScalarFieldEnum[]
  }

  /**
   * WashingDuty findMany
   */
  export type WashingDutyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WashingDuty
     */
    select?: WashingDutySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WashingDutyInclude<ExtArgs> | null
    /**
     * Filter, which WashingDuties to fetch.
     */
    where?: WashingDutyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WashingDuties to fetch.
     */
    orderBy?: WashingDutyOrderByWithRelationInput | WashingDutyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WashingDuties.
     */
    cursor?: WashingDutyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WashingDuties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WashingDuties.
     */
    skip?: number
    distinct?: WashingDutyScalarFieldEnum | WashingDutyScalarFieldEnum[]
  }

  /**
   * WashingDuty create
   */
  export type WashingDutyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WashingDuty
     */
    select?: WashingDutySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WashingDutyInclude<ExtArgs> | null
    /**
     * The data needed to create a WashingDuty.
     */
    data: XOR<WashingDutyCreateInput, WashingDutyUncheckedCreateInput>
  }

  /**
   * WashingDuty createMany
   */
  export type WashingDutyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WashingDuties.
     */
    data: WashingDutyCreateManyInput | WashingDutyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WashingDuty createManyAndReturn
   */
  export type WashingDutyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WashingDuty
     */
    select?: WashingDutySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WashingDuties.
     */
    data: WashingDutyCreateManyInput | WashingDutyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WashingDutyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WashingDuty update
   */
  export type WashingDutyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WashingDuty
     */
    select?: WashingDutySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WashingDutyInclude<ExtArgs> | null
    /**
     * The data needed to update a WashingDuty.
     */
    data: XOR<WashingDutyUpdateInput, WashingDutyUncheckedUpdateInput>
    /**
     * Choose, which WashingDuty to update.
     */
    where: WashingDutyWhereUniqueInput
  }

  /**
   * WashingDuty updateMany
   */
  export type WashingDutyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WashingDuties.
     */
    data: XOR<WashingDutyUpdateManyMutationInput, WashingDutyUncheckedUpdateManyInput>
    /**
     * Filter which WashingDuties to update
     */
    where?: WashingDutyWhereInput
  }

  /**
   * WashingDuty upsert
   */
  export type WashingDutyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WashingDuty
     */
    select?: WashingDutySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WashingDutyInclude<ExtArgs> | null
    /**
     * The filter to search for the WashingDuty to update in case it exists.
     */
    where: WashingDutyWhereUniqueInput
    /**
     * In case the WashingDuty found by the `where` argument doesn't exist, create a new WashingDuty with this data.
     */
    create: XOR<WashingDutyCreateInput, WashingDutyUncheckedCreateInput>
    /**
     * In case the WashingDuty was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WashingDutyUpdateInput, WashingDutyUncheckedUpdateInput>
  }

  /**
   * WashingDuty delete
   */
  export type WashingDutyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WashingDuty
     */
    select?: WashingDutySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WashingDutyInclude<ExtArgs> | null
    /**
     * Filter which WashingDuty to delete.
     */
    where: WashingDutyWhereUniqueInput
  }

  /**
   * WashingDuty deleteMany
   */
  export type WashingDutyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WashingDuties to delete
     */
    where?: WashingDutyWhereInput
  }

  /**
   * WashingDuty without action
   */
  export type WashingDutyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WashingDuty
     */
    select?: WashingDutySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WashingDutyInclude<ExtArgs> | null
  }


  /**
   * Model MaintenanceDuty
   */

  export type AggregateMaintenanceDuty = {
    _count: MaintenanceDutyCountAggregateOutputType | null
    _avg: MaintenanceDutyAvgAggregateOutputType | null
    _sum: MaintenanceDutySumAggregateOutputType | null
    _min: MaintenanceDutyMinAggregateOutputType | null
    _max: MaintenanceDutyMaxAggregateOutputType | null
  }

  export type MaintenanceDutyAvgAggregateOutputType = {
    id: number | null
    dutyId: number | null
  }

  export type MaintenanceDutySumAggregateOutputType = {
    id: bigint | null
    dutyId: bigint | null
  }

  export type MaintenanceDutyMinAggregateOutputType = {
    id: bigint | null
    dutyId: bigint | null
  }

  export type MaintenanceDutyMaxAggregateOutputType = {
    id: bigint | null
    dutyId: bigint | null
  }

  export type MaintenanceDutyCountAggregateOutputType = {
    id: number
    dutyId: number
    _all: number
  }


  export type MaintenanceDutyAvgAggregateInputType = {
    id?: true
    dutyId?: true
  }

  export type MaintenanceDutySumAggregateInputType = {
    id?: true
    dutyId?: true
  }

  export type MaintenanceDutyMinAggregateInputType = {
    id?: true
    dutyId?: true
  }

  export type MaintenanceDutyMaxAggregateInputType = {
    id?: true
    dutyId?: true
  }

  export type MaintenanceDutyCountAggregateInputType = {
    id?: true
    dutyId?: true
    _all?: true
  }

  export type MaintenanceDutyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaintenanceDuty to aggregate.
     */
    where?: MaintenanceDutyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenanceDuties to fetch.
     */
    orderBy?: MaintenanceDutyOrderByWithRelationInput | MaintenanceDutyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MaintenanceDutyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenanceDuties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenanceDuties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MaintenanceDuties
    **/
    _count?: true | MaintenanceDutyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MaintenanceDutyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MaintenanceDutySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaintenanceDutyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaintenanceDutyMaxAggregateInputType
  }

  export type GetMaintenanceDutyAggregateType<T extends MaintenanceDutyAggregateArgs> = {
        [P in keyof T & keyof AggregateMaintenanceDuty]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaintenanceDuty[P]>
      : GetScalarType<T[P], AggregateMaintenanceDuty[P]>
  }




  export type MaintenanceDutyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaintenanceDutyWhereInput
    orderBy?: MaintenanceDutyOrderByWithAggregationInput | MaintenanceDutyOrderByWithAggregationInput[]
    by: MaintenanceDutyScalarFieldEnum[] | MaintenanceDutyScalarFieldEnum
    having?: MaintenanceDutyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaintenanceDutyCountAggregateInputType | true
    _avg?: MaintenanceDutyAvgAggregateInputType
    _sum?: MaintenanceDutySumAggregateInputType
    _min?: MaintenanceDutyMinAggregateInputType
    _max?: MaintenanceDutyMaxAggregateInputType
  }

  export type MaintenanceDutyGroupByOutputType = {
    id: bigint
    dutyId: bigint
    _count: MaintenanceDutyCountAggregateOutputType | null
    _avg: MaintenanceDutyAvgAggregateOutputType | null
    _sum: MaintenanceDutySumAggregateOutputType | null
    _min: MaintenanceDutyMinAggregateOutputType | null
    _max: MaintenanceDutyMaxAggregateOutputType | null
  }

  type GetMaintenanceDutyGroupByPayload<T extends MaintenanceDutyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaintenanceDutyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaintenanceDutyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaintenanceDutyGroupByOutputType[P]>
            : GetScalarType<T[P], MaintenanceDutyGroupByOutputType[P]>
        }
      >
    >


  export type MaintenanceDutySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dutyId?: boolean
    duty?: boolean | DutyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["maintenanceDuty"]>

  export type MaintenanceDutySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dutyId?: boolean
    duty?: boolean | DutyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["maintenanceDuty"]>

  export type MaintenanceDutySelectScalar = {
    id?: boolean
    dutyId?: boolean
  }

  export type MaintenanceDutyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    duty?: boolean | DutyDefaultArgs<ExtArgs>
  }
  export type MaintenanceDutyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    duty?: boolean | DutyDefaultArgs<ExtArgs>
  }

  export type $MaintenanceDutyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MaintenanceDuty"
    objects: {
      duty: Prisma.$DutyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      dutyId: bigint
    }, ExtArgs["result"]["maintenanceDuty"]>
    composites: {}
  }

  type MaintenanceDutyGetPayload<S extends boolean | null | undefined | MaintenanceDutyDefaultArgs> = $Result.GetResult<Prisma.$MaintenanceDutyPayload, S>

  type MaintenanceDutyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MaintenanceDutyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MaintenanceDutyCountAggregateInputType | true
    }

  export interface MaintenanceDutyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MaintenanceDuty'], meta: { name: 'MaintenanceDuty' } }
    /**
     * Find zero or one MaintenanceDuty that matches the filter.
     * @param {MaintenanceDutyFindUniqueArgs} args - Arguments to find a MaintenanceDuty
     * @example
     * // Get one MaintenanceDuty
     * const maintenanceDuty = await prisma.maintenanceDuty.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MaintenanceDutyFindUniqueArgs>(args: SelectSubset<T, MaintenanceDutyFindUniqueArgs<ExtArgs>>): Prisma__MaintenanceDutyClient<$Result.GetResult<Prisma.$MaintenanceDutyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MaintenanceDuty that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MaintenanceDutyFindUniqueOrThrowArgs} args - Arguments to find a MaintenanceDuty
     * @example
     * // Get one MaintenanceDuty
     * const maintenanceDuty = await prisma.maintenanceDuty.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MaintenanceDutyFindUniqueOrThrowArgs>(args: SelectSubset<T, MaintenanceDutyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MaintenanceDutyClient<$Result.GetResult<Prisma.$MaintenanceDutyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MaintenanceDuty that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceDutyFindFirstArgs} args - Arguments to find a MaintenanceDuty
     * @example
     * // Get one MaintenanceDuty
     * const maintenanceDuty = await prisma.maintenanceDuty.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MaintenanceDutyFindFirstArgs>(args?: SelectSubset<T, MaintenanceDutyFindFirstArgs<ExtArgs>>): Prisma__MaintenanceDutyClient<$Result.GetResult<Prisma.$MaintenanceDutyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MaintenanceDuty that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceDutyFindFirstOrThrowArgs} args - Arguments to find a MaintenanceDuty
     * @example
     * // Get one MaintenanceDuty
     * const maintenanceDuty = await prisma.maintenanceDuty.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MaintenanceDutyFindFirstOrThrowArgs>(args?: SelectSubset<T, MaintenanceDutyFindFirstOrThrowArgs<ExtArgs>>): Prisma__MaintenanceDutyClient<$Result.GetResult<Prisma.$MaintenanceDutyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MaintenanceDuties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceDutyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MaintenanceDuties
     * const maintenanceDuties = await prisma.maintenanceDuty.findMany()
     * 
     * // Get first 10 MaintenanceDuties
     * const maintenanceDuties = await prisma.maintenanceDuty.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const maintenanceDutyWithIdOnly = await prisma.maintenanceDuty.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MaintenanceDutyFindManyArgs>(args?: SelectSubset<T, MaintenanceDutyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenanceDutyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MaintenanceDuty.
     * @param {MaintenanceDutyCreateArgs} args - Arguments to create a MaintenanceDuty.
     * @example
     * // Create one MaintenanceDuty
     * const MaintenanceDuty = await prisma.maintenanceDuty.create({
     *   data: {
     *     // ... data to create a MaintenanceDuty
     *   }
     * })
     * 
     */
    create<T extends MaintenanceDutyCreateArgs>(args: SelectSubset<T, MaintenanceDutyCreateArgs<ExtArgs>>): Prisma__MaintenanceDutyClient<$Result.GetResult<Prisma.$MaintenanceDutyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MaintenanceDuties.
     * @param {MaintenanceDutyCreateManyArgs} args - Arguments to create many MaintenanceDuties.
     * @example
     * // Create many MaintenanceDuties
     * const maintenanceDuty = await prisma.maintenanceDuty.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MaintenanceDutyCreateManyArgs>(args?: SelectSubset<T, MaintenanceDutyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MaintenanceDuties and returns the data saved in the database.
     * @param {MaintenanceDutyCreateManyAndReturnArgs} args - Arguments to create many MaintenanceDuties.
     * @example
     * // Create many MaintenanceDuties
     * const maintenanceDuty = await prisma.maintenanceDuty.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MaintenanceDuties and only return the `id`
     * const maintenanceDutyWithIdOnly = await prisma.maintenanceDuty.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MaintenanceDutyCreateManyAndReturnArgs>(args?: SelectSubset<T, MaintenanceDutyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenanceDutyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MaintenanceDuty.
     * @param {MaintenanceDutyDeleteArgs} args - Arguments to delete one MaintenanceDuty.
     * @example
     * // Delete one MaintenanceDuty
     * const MaintenanceDuty = await prisma.maintenanceDuty.delete({
     *   where: {
     *     // ... filter to delete one MaintenanceDuty
     *   }
     * })
     * 
     */
    delete<T extends MaintenanceDutyDeleteArgs>(args: SelectSubset<T, MaintenanceDutyDeleteArgs<ExtArgs>>): Prisma__MaintenanceDutyClient<$Result.GetResult<Prisma.$MaintenanceDutyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MaintenanceDuty.
     * @param {MaintenanceDutyUpdateArgs} args - Arguments to update one MaintenanceDuty.
     * @example
     * // Update one MaintenanceDuty
     * const maintenanceDuty = await prisma.maintenanceDuty.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MaintenanceDutyUpdateArgs>(args: SelectSubset<T, MaintenanceDutyUpdateArgs<ExtArgs>>): Prisma__MaintenanceDutyClient<$Result.GetResult<Prisma.$MaintenanceDutyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MaintenanceDuties.
     * @param {MaintenanceDutyDeleteManyArgs} args - Arguments to filter MaintenanceDuties to delete.
     * @example
     * // Delete a few MaintenanceDuties
     * const { count } = await prisma.maintenanceDuty.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MaintenanceDutyDeleteManyArgs>(args?: SelectSubset<T, MaintenanceDutyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MaintenanceDuties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceDutyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MaintenanceDuties
     * const maintenanceDuty = await prisma.maintenanceDuty.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MaintenanceDutyUpdateManyArgs>(args: SelectSubset<T, MaintenanceDutyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MaintenanceDuty.
     * @param {MaintenanceDutyUpsertArgs} args - Arguments to update or create a MaintenanceDuty.
     * @example
     * // Update or create a MaintenanceDuty
     * const maintenanceDuty = await prisma.maintenanceDuty.upsert({
     *   create: {
     *     // ... data to create a MaintenanceDuty
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MaintenanceDuty we want to update
     *   }
     * })
     */
    upsert<T extends MaintenanceDutyUpsertArgs>(args: SelectSubset<T, MaintenanceDutyUpsertArgs<ExtArgs>>): Prisma__MaintenanceDutyClient<$Result.GetResult<Prisma.$MaintenanceDutyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MaintenanceDuties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceDutyCountArgs} args - Arguments to filter MaintenanceDuties to count.
     * @example
     * // Count the number of MaintenanceDuties
     * const count = await prisma.maintenanceDuty.count({
     *   where: {
     *     // ... the filter for the MaintenanceDuties we want to count
     *   }
     * })
    **/
    count<T extends MaintenanceDutyCountArgs>(
      args?: Subset<T, MaintenanceDutyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaintenanceDutyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MaintenanceDuty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceDutyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaintenanceDutyAggregateArgs>(args: Subset<T, MaintenanceDutyAggregateArgs>): Prisma.PrismaPromise<GetMaintenanceDutyAggregateType<T>>

    /**
     * Group by MaintenanceDuty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceDutyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaintenanceDutyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaintenanceDutyGroupByArgs['orderBy'] }
        : { orderBy?: MaintenanceDutyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaintenanceDutyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaintenanceDutyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MaintenanceDuty model
   */
  readonly fields: MaintenanceDutyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MaintenanceDuty.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MaintenanceDutyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    duty<T extends DutyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DutyDefaultArgs<ExtArgs>>): Prisma__DutyClient<$Result.GetResult<Prisma.$DutyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MaintenanceDuty model
   */ 
  interface MaintenanceDutyFieldRefs {
    readonly id: FieldRef<"MaintenanceDuty", 'BigInt'>
    readonly dutyId: FieldRef<"MaintenanceDuty", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * MaintenanceDuty findUnique
   */
  export type MaintenanceDutyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceDuty
     */
    select?: MaintenanceDutySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceDutyInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceDuty to fetch.
     */
    where: MaintenanceDutyWhereUniqueInput
  }

  /**
   * MaintenanceDuty findUniqueOrThrow
   */
  export type MaintenanceDutyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceDuty
     */
    select?: MaintenanceDutySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceDutyInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceDuty to fetch.
     */
    where: MaintenanceDutyWhereUniqueInput
  }

  /**
   * MaintenanceDuty findFirst
   */
  export type MaintenanceDutyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceDuty
     */
    select?: MaintenanceDutySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceDutyInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceDuty to fetch.
     */
    where?: MaintenanceDutyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenanceDuties to fetch.
     */
    orderBy?: MaintenanceDutyOrderByWithRelationInput | MaintenanceDutyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaintenanceDuties.
     */
    cursor?: MaintenanceDutyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenanceDuties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenanceDuties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaintenanceDuties.
     */
    distinct?: MaintenanceDutyScalarFieldEnum | MaintenanceDutyScalarFieldEnum[]
  }

  /**
   * MaintenanceDuty findFirstOrThrow
   */
  export type MaintenanceDutyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceDuty
     */
    select?: MaintenanceDutySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceDutyInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceDuty to fetch.
     */
    where?: MaintenanceDutyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenanceDuties to fetch.
     */
    orderBy?: MaintenanceDutyOrderByWithRelationInput | MaintenanceDutyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaintenanceDuties.
     */
    cursor?: MaintenanceDutyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenanceDuties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenanceDuties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaintenanceDuties.
     */
    distinct?: MaintenanceDutyScalarFieldEnum | MaintenanceDutyScalarFieldEnum[]
  }

  /**
   * MaintenanceDuty findMany
   */
  export type MaintenanceDutyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceDuty
     */
    select?: MaintenanceDutySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceDutyInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceDuties to fetch.
     */
    where?: MaintenanceDutyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenanceDuties to fetch.
     */
    orderBy?: MaintenanceDutyOrderByWithRelationInput | MaintenanceDutyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MaintenanceDuties.
     */
    cursor?: MaintenanceDutyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenanceDuties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenanceDuties.
     */
    skip?: number
    distinct?: MaintenanceDutyScalarFieldEnum | MaintenanceDutyScalarFieldEnum[]
  }

  /**
   * MaintenanceDuty create
   */
  export type MaintenanceDutyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceDuty
     */
    select?: MaintenanceDutySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceDutyInclude<ExtArgs> | null
    /**
     * The data needed to create a MaintenanceDuty.
     */
    data: XOR<MaintenanceDutyCreateInput, MaintenanceDutyUncheckedCreateInput>
  }

  /**
   * MaintenanceDuty createMany
   */
  export type MaintenanceDutyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MaintenanceDuties.
     */
    data: MaintenanceDutyCreateManyInput | MaintenanceDutyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MaintenanceDuty createManyAndReturn
   */
  export type MaintenanceDutyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceDuty
     */
    select?: MaintenanceDutySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MaintenanceDuties.
     */
    data: MaintenanceDutyCreateManyInput | MaintenanceDutyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceDutyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MaintenanceDuty update
   */
  export type MaintenanceDutyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceDuty
     */
    select?: MaintenanceDutySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceDutyInclude<ExtArgs> | null
    /**
     * The data needed to update a MaintenanceDuty.
     */
    data: XOR<MaintenanceDutyUpdateInput, MaintenanceDutyUncheckedUpdateInput>
    /**
     * Choose, which MaintenanceDuty to update.
     */
    where: MaintenanceDutyWhereUniqueInput
  }

  /**
   * MaintenanceDuty updateMany
   */
  export type MaintenanceDutyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MaintenanceDuties.
     */
    data: XOR<MaintenanceDutyUpdateManyMutationInput, MaintenanceDutyUncheckedUpdateManyInput>
    /**
     * Filter which MaintenanceDuties to update
     */
    where?: MaintenanceDutyWhereInput
  }

  /**
   * MaintenanceDuty upsert
   */
  export type MaintenanceDutyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceDuty
     */
    select?: MaintenanceDutySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceDutyInclude<ExtArgs> | null
    /**
     * The filter to search for the MaintenanceDuty to update in case it exists.
     */
    where: MaintenanceDutyWhereUniqueInput
    /**
     * In case the MaintenanceDuty found by the `where` argument doesn't exist, create a new MaintenanceDuty with this data.
     */
    create: XOR<MaintenanceDutyCreateInput, MaintenanceDutyUncheckedCreateInput>
    /**
     * In case the MaintenanceDuty was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MaintenanceDutyUpdateInput, MaintenanceDutyUncheckedUpdateInput>
  }

  /**
   * MaintenanceDuty delete
   */
  export type MaintenanceDutyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceDuty
     */
    select?: MaintenanceDutySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceDutyInclude<ExtArgs> | null
    /**
     * Filter which MaintenanceDuty to delete.
     */
    where: MaintenanceDutyWhereUniqueInput
  }

  /**
   * MaintenanceDuty deleteMany
   */
  export type MaintenanceDutyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaintenanceDuties to delete
     */
    where?: MaintenanceDutyWhereInput
  }

  /**
   * MaintenanceDuty without action
   */
  export type MaintenanceDutyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceDuty
     */
    select?: MaintenanceDutySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceDutyInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserAuthScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    userType: 'userType',
    provider: 'provider',
    identifier: 'identifier',
    password: 'password',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserAuthScalarFieldEnum = (typeof UserAuthScalarFieldEnum)[keyof typeof UserAuthScalarFieldEnum]


  export const UserActivationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    activationCode: 'activationCode',
    expiresAt: 'expiresAt',
    isUsed: 'isUsed',
    createdAt: 'createdAt'
  };

  export type UserActivationScalarFieldEnum = (typeof UserActivationScalarFieldEnum)[keyof typeof UserActivationScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    phone: 'phone',
    qid: 'qid',
    userType: 'userType',
    isActive: 'isActive'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const UserRoleScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    roleId: 'roleId'
  };

  export type UserRoleScalarFieldEnum = (typeof UserRoleScalarFieldEnum)[keyof typeof UserRoleScalarFieldEnum]


  export const DriverScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    licenseExpiry: 'licenseExpiry'
  };

  export type DriverScalarFieldEnum = (typeof DriverScalarFieldEnum)[keyof typeof DriverScalarFieldEnum]


  export const VehicleModelScalarFieldEnum: {
    id: 'id',
    make: 'make',
    year: 'year',
    manufacturer: 'manufacturer',
    capacity: 'capacity'
  };

  export type VehicleModelScalarFieldEnum = (typeof VehicleModelScalarFieldEnum)[keyof typeof VehicleModelScalarFieldEnum]


  export const VehicleScalarFieldEnum: {
    id: 'id',
    plateNo: 'plateNo',
    fleetNo: 'fleetNo',
    modelId: 'modelId'
  };

  export type VehicleScalarFieldEnum = (typeof VehicleScalarFieldEnum)[keyof typeof VehicleScalarFieldEnum]


  export const LocationScalarFieldEnum: {
    id: 'id',
    lat: 'lat',
    lon: 'lon'
  };

  export type LocationScalarFieldEnum = (typeof LocationScalarFieldEnum)[keyof typeof LocationScalarFieldEnum]


  export const StopScalarFieldEnum: {
    id: 'id',
    locationId: 'locationId',
    name: 'name',
    code: 'code'
  };

  export type StopScalarFieldEnum = (typeof StopScalarFieldEnum)[keyof typeof StopScalarFieldEnum]


  export const RouteScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    isActive: 'isActive',
    totalEstimatedDuration: 'totalEstimatedDuration'
  };

  export type RouteScalarFieldEnum = (typeof RouteScalarFieldEnum)[keyof typeof RouteScalarFieldEnum]


  export const RouteStopScalarFieldEnum: {
    id: 'id',
    routeId: 'routeId',
    stopId: 'stopId',
    stopOrder: 'stopOrder',
    isActive: 'isActive',
    path: 'path',
    eta: 'eta',
    waitTime: 'waitTime'
  };

  export type RouteStopScalarFieldEnum = (typeof RouteStopScalarFieldEnum)[keyof typeof RouteStopScalarFieldEnum]


  export const TripScalarFieldEnum: {
    id: 'id',
    routeId: 'routeId',
    startTime: 'startTime',
    endTime: 'endTime',
    startLocation: 'startLocation',
    endLocation: 'endLocation',
    driverId: 'driverId',
    vehicleId: 'vehicleId',
    averageSpeed: 'averageSpeed',
    maxSpeed: 'maxSpeed',
    totalDistance: 'totalDistance',
    totalDuration: 'totalDuration',
    idleTime: 'idleTime',
    path: 'path'
  };

  export type TripScalarFieldEnum = (typeof TripScalarFieldEnum)[keyof typeof TripScalarFieldEnum]


  export const TripStopScalarFieldEnum: {
    id: 'id',
    tripId: 'tripId',
    stopId: 'stopId',
    stopOrder: 'stopOrder',
    arrivalTime: 'arrivalTime',
    departureTime: 'departureTime',
    eta: 'eta'
  };

  export type TripStopScalarFieldEnum = (typeof TripStopScalarFieldEnum)[keyof typeof TripStopScalarFieldEnum]


  export const VehicleTelemetryScalarFieldEnum: {
    id: 'id',
    lat: 'lat',
    lon: 'lon',
    speed: 'speed',
    ignition: 'ignition',
    trackedOn: 'trackedOn',
    vehicleId: 'vehicleId'
  };

  export type VehicleTelemetryScalarFieldEnum = (typeof VehicleTelemetryScalarFieldEnum)[keyof typeof VehicleTelemetryScalarFieldEnum]


  export const VehicleTelemetryHistoryScalarFieldEnum: {
    id: 'id',
    lat: 'lat',
    lon: 'lon',
    speed: 'speed',
    ignition: 'ignition',
    trackedOn: 'trackedOn',
    vehicleId: 'vehicleId'
  };

  export type VehicleTelemetryHistoryScalarFieldEnum = (typeof VehicleTelemetryHistoryScalarFieldEnum)[keyof typeof VehicleTelemetryHistoryScalarFieldEnum]


  export const ShiftScalarFieldEnum: {
    id: 'id',
    startTime: 'startTime',
    endTime: 'endTime',
    vehicleId: 'vehicleId',
    driverId: 'driverId'
  };

  export type ShiftScalarFieldEnum = (typeof ShiftScalarFieldEnum)[keyof typeof ShiftScalarFieldEnum]


  export const ServiceScheduleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ServiceScheduleScalarFieldEnum = (typeof ServiceScheduleScalarFieldEnum)[keyof typeof ServiceScheduleScalarFieldEnum]


  export const VehicleBlockTemplateScalarFieldEnum: {
    id: 'id',
    scheduleId: 'scheduleId',
    code: 'code',
    color: 'color'
  };

  export type VehicleBlockTemplateScalarFieldEnum = (typeof VehicleBlockTemplateScalarFieldEnum)[keyof typeof VehicleBlockTemplateScalarFieldEnum]


  export const DriverRunTemplateScalarFieldEnum: {
    id: 'id',
    scheduleId: 'scheduleId',
    code: 'code',
    color: 'color'
  };

  export type DriverRunTemplateScalarFieldEnum = (typeof DriverRunTemplateScalarFieldEnum)[keyof typeof DriverRunTemplateScalarFieldEnum]


  export const DutyTemplateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    startTime: 'startTime',
    endTime: 'endTime',
    dutyType: 'dutyType',
    vehicleBlockTemplateId: 'vehicleBlockTemplateId',
    driverRunTemplateId: 'driverRunTemplateId',
    scheduleId: 'scheduleId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DutyTemplateScalarFieldEnum = (typeof DutyTemplateScalarFieldEnum)[keyof typeof DutyTemplateScalarFieldEnum]


  export const VehicleBlockScalarFieldEnum: {
    id: 'id',
    vehicleBlockTemplateId: 'vehicleBlockTemplateId',
    code: 'code'
  };

  export type VehicleBlockScalarFieldEnum = (typeof VehicleBlockScalarFieldEnum)[keyof typeof VehicleBlockScalarFieldEnum]


  export const DriverRunScalarFieldEnum: {
    id: 'id',
    driverRunTemplateId: 'driverRunTemplateId',
    code: 'code'
  };

  export type DriverRunScalarFieldEnum = (typeof DriverRunScalarFieldEnum)[keyof typeof DriverRunScalarFieldEnum]


  export const DutyScalarFieldEnum: {
    id: 'id',
    date: 'date',
    startTime: 'startTime',
    endTime: 'endTime',
    driverId: 'driverId',
    vehicleId: 'vehicleId',
    dutyTemplateId: 'dutyTemplateId',
    blockId: 'blockId',
    runId: 'runId',
    dutyType: 'dutyType'
  };

  export type DutyScalarFieldEnum = (typeof DutyScalarFieldEnum)[keyof typeof DutyScalarFieldEnum]


  export const TripDutyScalarFieldEnum: {
    id: 'id',
    dutyId: 'dutyId',
    routeId: 'routeId'
  };

  export type TripDutyScalarFieldEnum = (typeof TripDutyScalarFieldEnum)[keyof typeof TripDutyScalarFieldEnum]


  export const WashingDutyScalarFieldEnum: {
    id: 'id',
    dutyId: 'dutyId'
  };

  export type WashingDutyScalarFieldEnum = (typeof WashingDutyScalarFieldEnum)[keyof typeof WashingDutyScalarFieldEnum]


  export const MaintenanceDutyScalarFieldEnum: {
    id: 'id',
    dutyId: 'dutyId'
  };

  export type MaintenanceDutyScalarFieldEnum = (typeof MaintenanceDutyScalarFieldEnum)[keyof typeof MaintenanceDutyScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'DutyType'
   */
  export type EnumDutyTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DutyType'>
    


  /**
   * Reference to a field of type 'DutyType[]'
   */
  export type ListEnumDutyTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DutyType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserAuthWhereInput = {
    AND?: UserAuthWhereInput | UserAuthWhereInput[]
    OR?: UserAuthWhereInput[]
    NOT?: UserAuthWhereInput | UserAuthWhereInput[]
    id?: BigIntFilter<"UserAuth"> | bigint | number
    userId?: BigIntFilter<"UserAuth"> | bigint | number
    userType?: StringFilter<"UserAuth"> | string
    provider?: StringFilter<"UserAuth"> | string
    identifier?: StringFilter<"UserAuth"> | string
    password?: StringFilter<"UserAuth"> | string
    createdAt?: DateTimeFilter<"UserAuth"> | Date | string
    updatedAt?: DateTimeFilter<"UserAuth"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserAuthOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    userType?: SortOrder
    provider?: SortOrder
    identifier?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserAuthWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    identifier?: string
    AND?: UserAuthWhereInput | UserAuthWhereInput[]
    OR?: UserAuthWhereInput[]
    NOT?: UserAuthWhereInput | UserAuthWhereInput[]
    userId?: BigIntFilter<"UserAuth"> | bigint | number
    userType?: StringFilter<"UserAuth"> | string
    provider?: StringFilter<"UserAuth"> | string
    password?: StringFilter<"UserAuth"> | string
    createdAt?: DateTimeFilter<"UserAuth"> | Date | string
    updatedAt?: DateTimeFilter<"UserAuth"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "identifier">

  export type UserAuthOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    userType?: SortOrder
    provider?: SortOrder
    identifier?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserAuthCountOrderByAggregateInput
    _avg?: UserAuthAvgOrderByAggregateInput
    _max?: UserAuthMaxOrderByAggregateInput
    _min?: UserAuthMinOrderByAggregateInput
    _sum?: UserAuthSumOrderByAggregateInput
  }

  export type UserAuthScalarWhereWithAggregatesInput = {
    AND?: UserAuthScalarWhereWithAggregatesInput | UserAuthScalarWhereWithAggregatesInput[]
    OR?: UserAuthScalarWhereWithAggregatesInput[]
    NOT?: UserAuthScalarWhereWithAggregatesInput | UserAuthScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"UserAuth"> | bigint | number
    userId?: BigIntWithAggregatesFilter<"UserAuth"> | bigint | number
    userType?: StringWithAggregatesFilter<"UserAuth"> | string
    provider?: StringWithAggregatesFilter<"UserAuth"> | string
    identifier?: StringWithAggregatesFilter<"UserAuth"> | string
    password?: StringWithAggregatesFilter<"UserAuth"> | string
    createdAt?: DateTimeWithAggregatesFilter<"UserAuth"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserAuth"> | Date | string
  }

  export type UserActivationWhereInput = {
    AND?: UserActivationWhereInput | UserActivationWhereInput[]
    OR?: UserActivationWhereInput[]
    NOT?: UserActivationWhereInput | UserActivationWhereInput[]
    id?: BigIntFilter<"UserActivation"> | bigint | number
    userId?: BigIntFilter<"UserActivation"> | bigint | number
    activationCode?: StringFilter<"UserActivation"> | string
    expiresAt?: DateTimeFilter<"UserActivation"> | Date | string
    isUsed?: BoolFilter<"UserActivation"> | boolean
    createdAt?: DateTimeFilter<"UserActivation"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserActivationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    activationCode?: SortOrder
    expiresAt?: SortOrder
    isUsed?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserActivationWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    activationCode?: string
    AND?: UserActivationWhereInput | UserActivationWhereInput[]
    OR?: UserActivationWhereInput[]
    NOT?: UserActivationWhereInput | UserActivationWhereInput[]
    userId?: BigIntFilter<"UserActivation"> | bigint | number
    expiresAt?: DateTimeFilter<"UserActivation"> | Date | string
    isUsed?: BoolFilter<"UserActivation"> | boolean
    createdAt?: DateTimeFilter<"UserActivation"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "activationCode">

  export type UserActivationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    activationCode?: SortOrder
    expiresAt?: SortOrder
    isUsed?: SortOrder
    createdAt?: SortOrder
    _count?: UserActivationCountOrderByAggregateInput
    _avg?: UserActivationAvgOrderByAggregateInput
    _max?: UserActivationMaxOrderByAggregateInput
    _min?: UserActivationMinOrderByAggregateInput
    _sum?: UserActivationSumOrderByAggregateInput
  }

  export type UserActivationScalarWhereWithAggregatesInput = {
    AND?: UserActivationScalarWhereWithAggregatesInput | UserActivationScalarWhereWithAggregatesInput[]
    OR?: UserActivationScalarWhereWithAggregatesInput[]
    NOT?: UserActivationScalarWhereWithAggregatesInput | UserActivationScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"UserActivation"> | bigint | number
    userId?: BigIntWithAggregatesFilter<"UserActivation"> | bigint | number
    activationCode?: StringWithAggregatesFilter<"UserActivation"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"UserActivation"> | Date | string
    isUsed?: BoolWithAggregatesFilter<"UserActivation"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"UserActivation"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: BigIntFilter<"User"> | bigint | number
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    phone?: StringFilter<"User"> | string
    qid?: StringNullableFilter<"User"> | string | null
    userType?: IntFilter<"User"> | number
    isActive?: BoolFilter<"User"> | boolean
    roles?: UserRoleListRelationFilter
    userActivations?: UserActivationListRelationFilter
    userAuths?: UserAuthListRelationFilter
    drivers?: DriverListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    qid?: SortOrderInput | SortOrder
    userType?: SortOrder
    isActive?: SortOrder
    roles?: UserRoleOrderByRelationAggregateInput
    userActivations?: UserActivationOrderByRelationAggregateInput
    userAuths?: UserAuthOrderByRelationAggregateInput
    drivers?: DriverOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    phone_userType?: UserPhoneUserTypeCompoundUniqueInput
    email_userType?: UserEmailUserTypeCompoundUniqueInput
    qid_userType?: UserQidUserTypeCompoundUniqueInput
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    phone?: StringFilter<"User"> | string
    qid?: StringNullableFilter<"User"> | string | null
    userType?: IntFilter<"User"> | number
    isActive?: BoolFilter<"User"> | boolean
    roles?: UserRoleListRelationFilter
    userActivations?: UserActivationListRelationFilter
    userAuths?: UserAuthListRelationFilter
    drivers?: DriverListRelationFilter
  }, "id" | "phone_userType" | "email_userType" | "qid_userType">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    qid?: SortOrderInput | SortOrder
    userType?: SortOrder
    isActive?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"User"> | bigint | number
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    phone?: StringWithAggregatesFilter<"User"> | string
    qid?: StringNullableWithAggregatesFilter<"User"> | string | null
    userType?: IntWithAggregatesFilter<"User"> | number
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
  }

  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    id?: BigIntFilter<"Role"> | bigint | number
    name?: StringFilter<"Role"> | string
    users?: UserRoleListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    users?: UserRoleOrderByRelationAggregateInput
  }

  export type RoleWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    name?: StringFilter<"Role"> | string
    users?: UserRoleListRelationFilter
  }, "id">

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: RoleCountOrderByAggregateInput
    _avg?: RoleAvgOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
    _sum?: RoleSumOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    OR?: RoleScalarWhereWithAggregatesInput[]
    NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"Role"> | bigint | number
    name?: StringWithAggregatesFilter<"Role"> | string
  }

  export type UserRoleWhereInput = {
    AND?: UserRoleWhereInput | UserRoleWhereInput[]
    OR?: UserRoleWhereInput[]
    NOT?: UserRoleWhereInput | UserRoleWhereInput[]
    id?: BigIntFilter<"UserRole"> | bigint | number
    userId?: BigIntFilter<"UserRole"> | bigint | number
    roleId?: BigIntFilter<"UserRole"> | bigint | number
    user?: XOR<UserRelationFilter, UserWhereInput>
    role?: XOR<RoleRelationFilter, RoleWhereInput>
  }

  export type UserRoleOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    user?: UserOrderByWithRelationInput
    role?: RoleOrderByWithRelationInput
  }

  export type UserRoleWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: UserRoleWhereInput | UserRoleWhereInput[]
    OR?: UserRoleWhereInput[]
    NOT?: UserRoleWhereInput | UserRoleWhereInput[]
    userId?: BigIntFilter<"UserRole"> | bigint | number
    roleId?: BigIntFilter<"UserRole"> | bigint | number
    user?: XOR<UserRelationFilter, UserWhereInput>
    role?: XOR<RoleRelationFilter, RoleWhereInput>
  }, "id">

  export type UserRoleOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    _count?: UserRoleCountOrderByAggregateInput
    _avg?: UserRoleAvgOrderByAggregateInput
    _max?: UserRoleMaxOrderByAggregateInput
    _min?: UserRoleMinOrderByAggregateInput
    _sum?: UserRoleSumOrderByAggregateInput
  }

  export type UserRoleScalarWhereWithAggregatesInput = {
    AND?: UserRoleScalarWhereWithAggregatesInput | UserRoleScalarWhereWithAggregatesInput[]
    OR?: UserRoleScalarWhereWithAggregatesInput[]
    NOT?: UserRoleScalarWhereWithAggregatesInput | UserRoleScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"UserRole"> | bigint | number
    userId?: BigIntWithAggregatesFilter<"UserRole"> | bigint | number
    roleId?: BigIntWithAggregatesFilter<"UserRole"> | bigint | number
  }

  export type DriverWhereInput = {
    AND?: DriverWhereInput | DriverWhereInput[]
    OR?: DriverWhereInput[]
    NOT?: DriverWhereInput | DriverWhereInput[]
    id?: BigIntFilter<"Driver"> | bigint | number
    userId?: BigIntFilter<"Driver"> | bigint | number
    licenseExpiry?: DateTimeNullableFilter<"Driver"> | Date | string | null
    trips?: TripListRelationFilter
    shifts?: ShiftListRelationFilter
    user?: XOR<UserRelationFilter, UserWhereInput>
    Duty?: DutyListRelationFilter
  }

  export type DriverOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    licenseExpiry?: SortOrderInput | SortOrder
    trips?: TripOrderByRelationAggregateInput
    shifts?: ShiftOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
    Duty?: DutyOrderByRelationAggregateInput
  }

  export type DriverWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    userId?: bigint | number
    AND?: DriverWhereInput | DriverWhereInput[]
    OR?: DriverWhereInput[]
    NOT?: DriverWhereInput | DriverWhereInput[]
    licenseExpiry?: DateTimeNullableFilter<"Driver"> | Date | string | null
    trips?: TripListRelationFilter
    shifts?: ShiftListRelationFilter
    user?: XOR<UserRelationFilter, UserWhereInput>
    Duty?: DutyListRelationFilter
  }, "id" | "userId">

  export type DriverOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    licenseExpiry?: SortOrderInput | SortOrder
    _count?: DriverCountOrderByAggregateInput
    _avg?: DriverAvgOrderByAggregateInput
    _max?: DriverMaxOrderByAggregateInput
    _min?: DriverMinOrderByAggregateInput
    _sum?: DriverSumOrderByAggregateInput
  }

  export type DriverScalarWhereWithAggregatesInput = {
    AND?: DriverScalarWhereWithAggregatesInput | DriverScalarWhereWithAggregatesInput[]
    OR?: DriverScalarWhereWithAggregatesInput[]
    NOT?: DriverScalarWhereWithAggregatesInput | DriverScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"Driver"> | bigint | number
    userId?: BigIntWithAggregatesFilter<"Driver"> | bigint | number
    licenseExpiry?: DateTimeNullableWithAggregatesFilter<"Driver"> | Date | string | null
  }

  export type VehicleModelWhereInput = {
    AND?: VehicleModelWhereInput | VehicleModelWhereInput[]
    OR?: VehicleModelWhereInput[]
    NOT?: VehicleModelWhereInput | VehicleModelWhereInput[]
    id?: BigIntFilter<"VehicleModel"> | bigint | number
    make?: StringFilter<"VehicleModel"> | string
    year?: IntFilter<"VehicleModel"> | number
    manufacturer?: StringFilter<"VehicleModel"> | string
    capacity?: IntFilter<"VehicleModel"> | number
    vehicles?: VehicleListRelationFilter
  }

  export type VehicleModelOrderByWithRelationInput = {
    id?: SortOrder
    make?: SortOrder
    year?: SortOrder
    manufacturer?: SortOrder
    capacity?: SortOrder
    vehicles?: VehicleOrderByRelationAggregateInput
  }

  export type VehicleModelWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: VehicleModelWhereInput | VehicleModelWhereInput[]
    OR?: VehicleModelWhereInput[]
    NOT?: VehicleModelWhereInput | VehicleModelWhereInput[]
    make?: StringFilter<"VehicleModel"> | string
    year?: IntFilter<"VehicleModel"> | number
    manufacturer?: StringFilter<"VehicleModel"> | string
    capacity?: IntFilter<"VehicleModel"> | number
    vehicles?: VehicleListRelationFilter
  }, "id">

  export type VehicleModelOrderByWithAggregationInput = {
    id?: SortOrder
    make?: SortOrder
    year?: SortOrder
    manufacturer?: SortOrder
    capacity?: SortOrder
    _count?: VehicleModelCountOrderByAggregateInput
    _avg?: VehicleModelAvgOrderByAggregateInput
    _max?: VehicleModelMaxOrderByAggregateInput
    _min?: VehicleModelMinOrderByAggregateInput
    _sum?: VehicleModelSumOrderByAggregateInput
  }

  export type VehicleModelScalarWhereWithAggregatesInput = {
    AND?: VehicleModelScalarWhereWithAggregatesInput | VehicleModelScalarWhereWithAggregatesInput[]
    OR?: VehicleModelScalarWhereWithAggregatesInput[]
    NOT?: VehicleModelScalarWhereWithAggregatesInput | VehicleModelScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"VehicleModel"> | bigint | number
    make?: StringWithAggregatesFilter<"VehicleModel"> | string
    year?: IntWithAggregatesFilter<"VehicleModel"> | number
    manufacturer?: StringWithAggregatesFilter<"VehicleModel"> | string
    capacity?: IntWithAggregatesFilter<"VehicleModel"> | number
  }

  export type VehicleWhereInput = {
    AND?: VehicleWhereInput | VehicleWhereInput[]
    OR?: VehicleWhereInput[]
    NOT?: VehicleWhereInput | VehicleWhereInput[]
    id?: BigIntFilter<"Vehicle"> | bigint | number
    plateNo?: StringFilter<"Vehicle"> | string
    fleetNo?: StringFilter<"Vehicle"> | string
    modelId?: BigIntFilter<"Vehicle"> | bigint | number
    model?: XOR<VehicleModelRelationFilter, VehicleModelWhereInput>
    trips?: TripListRelationFilter
    shifts?: ShiftListRelationFilter
    telemetry?: VehicleTelemetryListRelationFilter
    telemetryHistory?: VehicleTelemetryHistoryListRelationFilter
    Duty?: DutyListRelationFilter
  }

  export type VehicleOrderByWithRelationInput = {
    id?: SortOrder
    plateNo?: SortOrder
    fleetNo?: SortOrder
    modelId?: SortOrder
    model?: VehicleModelOrderByWithRelationInput
    trips?: TripOrderByRelationAggregateInput
    shifts?: ShiftOrderByRelationAggregateInput
    telemetry?: VehicleTelemetryOrderByRelationAggregateInput
    telemetryHistory?: VehicleTelemetryHistoryOrderByRelationAggregateInput
    Duty?: DutyOrderByRelationAggregateInput
  }

  export type VehicleWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    plateNo?: string
    AND?: VehicleWhereInput | VehicleWhereInput[]
    OR?: VehicleWhereInput[]
    NOT?: VehicleWhereInput | VehicleWhereInput[]
    fleetNo?: StringFilter<"Vehicle"> | string
    modelId?: BigIntFilter<"Vehicle"> | bigint | number
    model?: XOR<VehicleModelRelationFilter, VehicleModelWhereInput>
    trips?: TripListRelationFilter
    shifts?: ShiftListRelationFilter
    telemetry?: VehicleTelemetryListRelationFilter
    telemetryHistory?: VehicleTelemetryHistoryListRelationFilter
    Duty?: DutyListRelationFilter
  }, "id" | "plateNo">

  export type VehicleOrderByWithAggregationInput = {
    id?: SortOrder
    plateNo?: SortOrder
    fleetNo?: SortOrder
    modelId?: SortOrder
    _count?: VehicleCountOrderByAggregateInput
    _avg?: VehicleAvgOrderByAggregateInput
    _max?: VehicleMaxOrderByAggregateInput
    _min?: VehicleMinOrderByAggregateInput
    _sum?: VehicleSumOrderByAggregateInput
  }

  export type VehicleScalarWhereWithAggregatesInput = {
    AND?: VehicleScalarWhereWithAggregatesInput | VehicleScalarWhereWithAggregatesInput[]
    OR?: VehicleScalarWhereWithAggregatesInput[]
    NOT?: VehicleScalarWhereWithAggregatesInput | VehicleScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"Vehicle"> | bigint | number
    plateNo?: StringWithAggregatesFilter<"Vehicle"> | string
    fleetNo?: StringWithAggregatesFilter<"Vehicle"> | string
    modelId?: BigIntWithAggregatesFilter<"Vehicle"> | bigint | number
  }

  export type LocationWhereInput = {
    AND?: LocationWhereInput | LocationWhereInput[]
    OR?: LocationWhereInput[]
    NOT?: LocationWhereInput | LocationWhereInput[]
    id?: BigIntFilter<"Location"> | bigint | number
    lat?: DecimalFilter<"Location"> | Decimal | DecimalJsLike | number | string
    lon?: DecimalFilter<"Location"> | Decimal | DecimalJsLike | number | string
    stops?: StopListRelationFilter
  }

  export type LocationOrderByWithRelationInput = {
    id?: SortOrder
    lat?: SortOrder
    lon?: SortOrder
    stops?: StopOrderByRelationAggregateInput
  }

  export type LocationWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: LocationWhereInput | LocationWhereInput[]
    OR?: LocationWhereInput[]
    NOT?: LocationWhereInput | LocationWhereInput[]
    lat?: DecimalFilter<"Location"> | Decimal | DecimalJsLike | number | string
    lon?: DecimalFilter<"Location"> | Decimal | DecimalJsLike | number | string
    stops?: StopListRelationFilter
  }, "id">

  export type LocationOrderByWithAggregationInput = {
    id?: SortOrder
    lat?: SortOrder
    lon?: SortOrder
    _count?: LocationCountOrderByAggregateInput
    _avg?: LocationAvgOrderByAggregateInput
    _max?: LocationMaxOrderByAggregateInput
    _min?: LocationMinOrderByAggregateInput
    _sum?: LocationSumOrderByAggregateInput
  }

  export type LocationScalarWhereWithAggregatesInput = {
    AND?: LocationScalarWhereWithAggregatesInput | LocationScalarWhereWithAggregatesInput[]
    OR?: LocationScalarWhereWithAggregatesInput[]
    NOT?: LocationScalarWhereWithAggregatesInput | LocationScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"Location"> | bigint | number
    lat?: DecimalWithAggregatesFilter<"Location"> | Decimal | DecimalJsLike | number | string
    lon?: DecimalWithAggregatesFilter<"Location"> | Decimal | DecimalJsLike | number | string
  }

  export type StopWhereInput = {
    AND?: StopWhereInput | StopWhereInput[]
    OR?: StopWhereInput[]
    NOT?: StopWhereInput | StopWhereInput[]
    id?: BigIntFilter<"Stop"> | bigint | number
    locationId?: BigIntFilter<"Stop"> | bigint | number
    name?: StringFilter<"Stop"> | string
    code?: StringFilter<"Stop"> | string
    location?: XOR<LocationRelationFilter, LocationWhereInput>
    routeStops?: RouteStopListRelationFilter
    tripStops?: TripStopListRelationFilter
  }

  export type StopOrderByWithRelationInput = {
    id?: SortOrder
    locationId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    location?: LocationOrderByWithRelationInput
    routeStops?: RouteStopOrderByRelationAggregateInput
    tripStops?: TripStopOrderByRelationAggregateInput
  }

  export type StopWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: StopWhereInput | StopWhereInput[]
    OR?: StopWhereInput[]
    NOT?: StopWhereInput | StopWhereInput[]
    locationId?: BigIntFilter<"Stop"> | bigint | number
    name?: StringFilter<"Stop"> | string
    code?: StringFilter<"Stop"> | string
    location?: XOR<LocationRelationFilter, LocationWhereInput>
    routeStops?: RouteStopListRelationFilter
    tripStops?: TripStopListRelationFilter
  }, "id">

  export type StopOrderByWithAggregationInput = {
    id?: SortOrder
    locationId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    _count?: StopCountOrderByAggregateInput
    _avg?: StopAvgOrderByAggregateInput
    _max?: StopMaxOrderByAggregateInput
    _min?: StopMinOrderByAggregateInput
    _sum?: StopSumOrderByAggregateInput
  }

  export type StopScalarWhereWithAggregatesInput = {
    AND?: StopScalarWhereWithAggregatesInput | StopScalarWhereWithAggregatesInput[]
    OR?: StopScalarWhereWithAggregatesInput[]
    NOT?: StopScalarWhereWithAggregatesInput | StopScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"Stop"> | bigint | number
    locationId?: BigIntWithAggregatesFilter<"Stop"> | bigint | number
    name?: StringWithAggregatesFilter<"Stop"> | string
    code?: StringWithAggregatesFilter<"Stop"> | string
  }

  export type RouteWhereInput = {
    AND?: RouteWhereInput | RouteWhereInput[]
    OR?: RouteWhereInput[]
    NOT?: RouteWhereInput | RouteWhereInput[]
    id?: BigIntFilter<"Route"> | bigint | number
    name?: StringFilter<"Route"> | string
    code?: StringFilter<"Route"> | string
    isActive?: BoolFilter<"Route"> | boolean
    totalEstimatedDuration?: IntFilter<"Route"> | number
    routeStops?: RouteStopListRelationFilter
    trips?: TripListRelationFilter
    TripDuty?: TripDutyListRelationFilter
  }

  export type RouteOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    isActive?: SortOrder
    totalEstimatedDuration?: SortOrder
    routeStops?: RouteStopOrderByRelationAggregateInput
    trips?: TripOrderByRelationAggregateInput
    TripDuty?: TripDutyOrderByRelationAggregateInput
  }

  export type RouteWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: RouteWhereInput | RouteWhereInput[]
    OR?: RouteWhereInput[]
    NOT?: RouteWhereInput | RouteWhereInput[]
    name?: StringFilter<"Route"> | string
    code?: StringFilter<"Route"> | string
    isActive?: BoolFilter<"Route"> | boolean
    totalEstimatedDuration?: IntFilter<"Route"> | number
    routeStops?: RouteStopListRelationFilter
    trips?: TripListRelationFilter
    TripDuty?: TripDutyListRelationFilter
  }, "id">

  export type RouteOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    isActive?: SortOrder
    totalEstimatedDuration?: SortOrder
    _count?: RouteCountOrderByAggregateInput
    _avg?: RouteAvgOrderByAggregateInput
    _max?: RouteMaxOrderByAggregateInput
    _min?: RouteMinOrderByAggregateInput
    _sum?: RouteSumOrderByAggregateInput
  }

  export type RouteScalarWhereWithAggregatesInput = {
    AND?: RouteScalarWhereWithAggregatesInput | RouteScalarWhereWithAggregatesInput[]
    OR?: RouteScalarWhereWithAggregatesInput[]
    NOT?: RouteScalarWhereWithAggregatesInput | RouteScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"Route"> | bigint | number
    name?: StringWithAggregatesFilter<"Route"> | string
    code?: StringWithAggregatesFilter<"Route"> | string
    isActive?: BoolWithAggregatesFilter<"Route"> | boolean
    totalEstimatedDuration?: IntWithAggregatesFilter<"Route"> | number
  }

  export type RouteStopWhereInput = {
    AND?: RouteStopWhereInput | RouteStopWhereInput[]
    OR?: RouteStopWhereInput[]
    NOT?: RouteStopWhereInput | RouteStopWhereInput[]
    id?: BigIntFilter<"RouteStop"> | bigint | number
    routeId?: BigIntFilter<"RouteStop"> | bigint | number
    stopId?: BigIntFilter<"RouteStop"> | bigint | number
    stopOrder?: IntFilter<"RouteStop"> | number
    isActive?: BoolFilter<"RouteStop"> | boolean
    path?: StringNullableFilter<"RouteStop"> | string | null
    eta?: IntNullableFilter<"RouteStop"> | number | null
    waitTime?: IntNullableFilter<"RouteStop"> | number | null
    route?: XOR<RouteRelationFilter, RouteWhereInput>
    stop?: XOR<StopRelationFilter, StopWhereInput>
  }

  export type RouteStopOrderByWithRelationInput = {
    id?: SortOrder
    routeId?: SortOrder
    stopId?: SortOrder
    stopOrder?: SortOrder
    isActive?: SortOrder
    path?: SortOrderInput | SortOrder
    eta?: SortOrderInput | SortOrder
    waitTime?: SortOrderInput | SortOrder
    route?: RouteOrderByWithRelationInput
    stop?: StopOrderByWithRelationInput
  }

  export type RouteStopWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: RouteStopWhereInput | RouteStopWhereInput[]
    OR?: RouteStopWhereInput[]
    NOT?: RouteStopWhereInput | RouteStopWhereInput[]
    routeId?: BigIntFilter<"RouteStop"> | bigint | number
    stopId?: BigIntFilter<"RouteStop"> | bigint | number
    stopOrder?: IntFilter<"RouteStop"> | number
    isActive?: BoolFilter<"RouteStop"> | boolean
    path?: StringNullableFilter<"RouteStop"> | string | null
    eta?: IntNullableFilter<"RouteStop"> | number | null
    waitTime?: IntNullableFilter<"RouteStop"> | number | null
    route?: XOR<RouteRelationFilter, RouteWhereInput>
    stop?: XOR<StopRelationFilter, StopWhereInput>
  }, "id">

  export type RouteStopOrderByWithAggregationInput = {
    id?: SortOrder
    routeId?: SortOrder
    stopId?: SortOrder
    stopOrder?: SortOrder
    isActive?: SortOrder
    path?: SortOrderInput | SortOrder
    eta?: SortOrderInput | SortOrder
    waitTime?: SortOrderInput | SortOrder
    _count?: RouteStopCountOrderByAggregateInput
    _avg?: RouteStopAvgOrderByAggregateInput
    _max?: RouteStopMaxOrderByAggregateInput
    _min?: RouteStopMinOrderByAggregateInput
    _sum?: RouteStopSumOrderByAggregateInput
  }

  export type RouteStopScalarWhereWithAggregatesInput = {
    AND?: RouteStopScalarWhereWithAggregatesInput | RouteStopScalarWhereWithAggregatesInput[]
    OR?: RouteStopScalarWhereWithAggregatesInput[]
    NOT?: RouteStopScalarWhereWithAggregatesInput | RouteStopScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"RouteStop"> | bigint | number
    routeId?: BigIntWithAggregatesFilter<"RouteStop"> | bigint | number
    stopId?: BigIntWithAggregatesFilter<"RouteStop"> | bigint | number
    stopOrder?: IntWithAggregatesFilter<"RouteStop"> | number
    isActive?: BoolWithAggregatesFilter<"RouteStop"> | boolean
    path?: StringNullableWithAggregatesFilter<"RouteStop"> | string | null
    eta?: IntNullableWithAggregatesFilter<"RouteStop"> | number | null
    waitTime?: IntNullableWithAggregatesFilter<"RouteStop"> | number | null
  }

  export type TripWhereInput = {
    AND?: TripWhereInput | TripWhereInput[]
    OR?: TripWhereInput[]
    NOT?: TripWhereInput | TripWhereInput[]
    id?: BigIntFilter<"Trip"> | bigint | number
    routeId?: BigIntFilter<"Trip"> | bigint | number
    startTime?: DateTimeFilter<"Trip"> | Date | string
    endTime?: DateTimeNullableFilter<"Trip"> | Date | string | null
    startLocation?: BigIntFilter<"Trip"> | bigint | number
    endLocation?: BigIntNullableFilter<"Trip"> | bigint | number | null
    driverId?: BigIntFilter<"Trip"> | bigint | number
    vehicleId?: BigIntFilter<"Trip"> | bigint | number
    averageSpeed?: DecimalNullableFilter<"Trip"> | Decimal | DecimalJsLike | number | string | null
    maxSpeed?: DecimalNullableFilter<"Trip"> | Decimal | DecimalJsLike | number | string | null
    totalDistance?: DecimalNullableFilter<"Trip"> | Decimal | DecimalJsLike | number | string | null
    totalDuration?: IntNullableFilter<"Trip"> | number | null
    idleTime?: IntNullableFilter<"Trip"> | number | null
    path?: StringNullableFilter<"Trip"> | string | null
    route?: XOR<RouteRelationFilter, RouteWhereInput>
    driver?: XOR<DriverRelationFilter, DriverWhereInput>
    vehicle?: XOR<VehicleRelationFilter, VehicleWhereInput>
    tripStops?: TripStopListRelationFilter
  }

  export type TripOrderByWithRelationInput = {
    id?: SortOrder
    routeId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    startLocation?: SortOrder
    endLocation?: SortOrderInput | SortOrder
    driverId?: SortOrder
    vehicleId?: SortOrder
    averageSpeed?: SortOrderInput | SortOrder
    maxSpeed?: SortOrderInput | SortOrder
    totalDistance?: SortOrderInput | SortOrder
    totalDuration?: SortOrderInput | SortOrder
    idleTime?: SortOrderInput | SortOrder
    path?: SortOrderInput | SortOrder
    route?: RouteOrderByWithRelationInput
    driver?: DriverOrderByWithRelationInput
    vehicle?: VehicleOrderByWithRelationInput
    tripStops?: TripStopOrderByRelationAggregateInput
  }

  export type TripWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: TripWhereInput | TripWhereInput[]
    OR?: TripWhereInput[]
    NOT?: TripWhereInput | TripWhereInput[]
    routeId?: BigIntFilter<"Trip"> | bigint | number
    startTime?: DateTimeFilter<"Trip"> | Date | string
    endTime?: DateTimeNullableFilter<"Trip"> | Date | string | null
    startLocation?: BigIntFilter<"Trip"> | bigint | number
    endLocation?: BigIntNullableFilter<"Trip"> | bigint | number | null
    driverId?: BigIntFilter<"Trip"> | bigint | number
    vehicleId?: BigIntFilter<"Trip"> | bigint | number
    averageSpeed?: DecimalNullableFilter<"Trip"> | Decimal | DecimalJsLike | number | string | null
    maxSpeed?: DecimalNullableFilter<"Trip"> | Decimal | DecimalJsLike | number | string | null
    totalDistance?: DecimalNullableFilter<"Trip"> | Decimal | DecimalJsLike | number | string | null
    totalDuration?: IntNullableFilter<"Trip"> | number | null
    idleTime?: IntNullableFilter<"Trip"> | number | null
    path?: StringNullableFilter<"Trip"> | string | null
    route?: XOR<RouteRelationFilter, RouteWhereInput>
    driver?: XOR<DriverRelationFilter, DriverWhereInput>
    vehicle?: XOR<VehicleRelationFilter, VehicleWhereInput>
    tripStops?: TripStopListRelationFilter
  }, "id">

  export type TripOrderByWithAggregationInput = {
    id?: SortOrder
    routeId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    startLocation?: SortOrder
    endLocation?: SortOrderInput | SortOrder
    driverId?: SortOrder
    vehicleId?: SortOrder
    averageSpeed?: SortOrderInput | SortOrder
    maxSpeed?: SortOrderInput | SortOrder
    totalDistance?: SortOrderInput | SortOrder
    totalDuration?: SortOrderInput | SortOrder
    idleTime?: SortOrderInput | SortOrder
    path?: SortOrderInput | SortOrder
    _count?: TripCountOrderByAggregateInput
    _avg?: TripAvgOrderByAggregateInput
    _max?: TripMaxOrderByAggregateInput
    _min?: TripMinOrderByAggregateInput
    _sum?: TripSumOrderByAggregateInput
  }

  export type TripScalarWhereWithAggregatesInput = {
    AND?: TripScalarWhereWithAggregatesInput | TripScalarWhereWithAggregatesInput[]
    OR?: TripScalarWhereWithAggregatesInput[]
    NOT?: TripScalarWhereWithAggregatesInput | TripScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"Trip"> | bigint | number
    routeId?: BigIntWithAggregatesFilter<"Trip"> | bigint | number
    startTime?: DateTimeWithAggregatesFilter<"Trip"> | Date | string
    endTime?: DateTimeNullableWithAggregatesFilter<"Trip"> | Date | string | null
    startLocation?: BigIntWithAggregatesFilter<"Trip"> | bigint | number
    endLocation?: BigIntNullableWithAggregatesFilter<"Trip"> | bigint | number | null
    driverId?: BigIntWithAggregatesFilter<"Trip"> | bigint | number
    vehicleId?: BigIntWithAggregatesFilter<"Trip"> | bigint | number
    averageSpeed?: DecimalNullableWithAggregatesFilter<"Trip"> | Decimal | DecimalJsLike | number | string | null
    maxSpeed?: DecimalNullableWithAggregatesFilter<"Trip"> | Decimal | DecimalJsLike | number | string | null
    totalDistance?: DecimalNullableWithAggregatesFilter<"Trip"> | Decimal | DecimalJsLike | number | string | null
    totalDuration?: IntNullableWithAggregatesFilter<"Trip"> | number | null
    idleTime?: IntNullableWithAggregatesFilter<"Trip"> | number | null
    path?: StringNullableWithAggregatesFilter<"Trip"> | string | null
  }

  export type TripStopWhereInput = {
    AND?: TripStopWhereInput | TripStopWhereInput[]
    OR?: TripStopWhereInput[]
    NOT?: TripStopWhereInput | TripStopWhereInput[]
    id?: BigIntFilter<"TripStop"> | bigint | number
    tripId?: BigIntFilter<"TripStop"> | bigint | number
    stopId?: BigIntFilter<"TripStop"> | bigint | number
    stopOrder?: IntFilter<"TripStop"> | number
    arrivalTime?: DateTimeNullableFilter<"TripStop"> | Date | string | null
    departureTime?: DateTimeNullableFilter<"TripStop"> | Date | string | null
    eta?: IntNullableFilter<"TripStop"> | number | null
    trip?: XOR<TripRelationFilter, TripWhereInput>
    stop?: XOR<StopRelationFilter, StopWhereInput>
  }

  export type TripStopOrderByWithRelationInput = {
    id?: SortOrder
    tripId?: SortOrder
    stopId?: SortOrder
    stopOrder?: SortOrder
    arrivalTime?: SortOrderInput | SortOrder
    departureTime?: SortOrderInput | SortOrder
    eta?: SortOrderInput | SortOrder
    trip?: TripOrderByWithRelationInput
    stop?: StopOrderByWithRelationInput
  }

  export type TripStopWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: TripStopWhereInput | TripStopWhereInput[]
    OR?: TripStopWhereInput[]
    NOT?: TripStopWhereInput | TripStopWhereInput[]
    tripId?: BigIntFilter<"TripStop"> | bigint | number
    stopId?: BigIntFilter<"TripStop"> | bigint | number
    stopOrder?: IntFilter<"TripStop"> | number
    arrivalTime?: DateTimeNullableFilter<"TripStop"> | Date | string | null
    departureTime?: DateTimeNullableFilter<"TripStop"> | Date | string | null
    eta?: IntNullableFilter<"TripStop"> | number | null
    trip?: XOR<TripRelationFilter, TripWhereInput>
    stop?: XOR<StopRelationFilter, StopWhereInput>
  }, "id">

  export type TripStopOrderByWithAggregationInput = {
    id?: SortOrder
    tripId?: SortOrder
    stopId?: SortOrder
    stopOrder?: SortOrder
    arrivalTime?: SortOrderInput | SortOrder
    departureTime?: SortOrderInput | SortOrder
    eta?: SortOrderInput | SortOrder
    _count?: TripStopCountOrderByAggregateInput
    _avg?: TripStopAvgOrderByAggregateInput
    _max?: TripStopMaxOrderByAggregateInput
    _min?: TripStopMinOrderByAggregateInput
    _sum?: TripStopSumOrderByAggregateInput
  }

  export type TripStopScalarWhereWithAggregatesInput = {
    AND?: TripStopScalarWhereWithAggregatesInput | TripStopScalarWhereWithAggregatesInput[]
    OR?: TripStopScalarWhereWithAggregatesInput[]
    NOT?: TripStopScalarWhereWithAggregatesInput | TripStopScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"TripStop"> | bigint | number
    tripId?: BigIntWithAggregatesFilter<"TripStop"> | bigint | number
    stopId?: BigIntWithAggregatesFilter<"TripStop"> | bigint | number
    stopOrder?: IntWithAggregatesFilter<"TripStop"> | number
    arrivalTime?: DateTimeNullableWithAggregatesFilter<"TripStop"> | Date | string | null
    departureTime?: DateTimeNullableWithAggregatesFilter<"TripStop"> | Date | string | null
    eta?: IntNullableWithAggregatesFilter<"TripStop"> | number | null
  }

  export type VehicleTelemetryWhereInput = {
    AND?: VehicleTelemetryWhereInput | VehicleTelemetryWhereInput[]
    OR?: VehicleTelemetryWhereInput[]
    NOT?: VehicleTelemetryWhereInput | VehicleTelemetryWhereInput[]
    id?: BigIntFilter<"VehicleTelemetry"> | bigint | number
    lat?: DecimalFilter<"VehicleTelemetry"> | Decimal | DecimalJsLike | number | string
    lon?: DecimalFilter<"VehicleTelemetry"> | Decimal | DecimalJsLike | number | string
    speed?: DecimalNullableFilter<"VehicleTelemetry"> | Decimal | DecimalJsLike | number | string | null
    ignition?: BoolFilter<"VehicleTelemetry"> | boolean
    trackedOn?: DateTimeFilter<"VehicleTelemetry"> | Date | string
    vehicleId?: BigIntFilter<"VehicleTelemetry"> | bigint | number
    vehicle?: XOR<VehicleRelationFilter, VehicleWhereInput>
  }

  export type VehicleTelemetryOrderByWithRelationInput = {
    id?: SortOrder
    lat?: SortOrder
    lon?: SortOrder
    speed?: SortOrderInput | SortOrder
    ignition?: SortOrder
    trackedOn?: SortOrder
    vehicleId?: SortOrder
    vehicle?: VehicleOrderByWithRelationInput
  }

  export type VehicleTelemetryWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: VehicleTelemetryWhereInput | VehicleTelemetryWhereInput[]
    OR?: VehicleTelemetryWhereInput[]
    NOT?: VehicleTelemetryWhereInput | VehicleTelemetryWhereInput[]
    lat?: DecimalFilter<"VehicleTelemetry"> | Decimal | DecimalJsLike | number | string
    lon?: DecimalFilter<"VehicleTelemetry"> | Decimal | DecimalJsLike | number | string
    speed?: DecimalNullableFilter<"VehicleTelemetry"> | Decimal | DecimalJsLike | number | string | null
    ignition?: BoolFilter<"VehicleTelemetry"> | boolean
    trackedOn?: DateTimeFilter<"VehicleTelemetry"> | Date | string
    vehicleId?: BigIntFilter<"VehicleTelemetry"> | bigint | number
    vehicle?: XOR<VehicleRelationFilter, VehicleWhereInput>
  }, "id">

  export type VehicleTelemetryOrderByWithAggregationInput = {
    id?: SortOrder
    lat?: SortOrder
    lon?: SortOrder
    speed?: SortOrderInput | SortOrder
    ignition?: SortOrder
    trackedOn?: SortOrder
    vehicleId?: SortOrder
    _count?: VehicleTelemetryCountOrderByAggregateInput
    _avg?: VehicleTelemetryAvgOrderByAggregateInput
    _max?: VehicleTelemetryMaxOrderByAggregateInput
    _min?: VehicleTelemetryMinOrderByAggregateInput
    _sum?: VehicleTelemetrySumOrderByAggregateInput
  }

  export type VehicleTelemetryScalarWhereWithAggregatesInput = {
    AND?: VehicleTelemetryScalarWhereWithAggregatesInput | VehicleTelemetryScalarWhereWithAggregatesInput[]
    OR?: VehicleTelemetryScalarWhereWithAggregatesInput[]
    NOT?: VehicleTelemetryScalarWhereWithAggregatesInput | VehicleTelemetryScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"VehicleTelemetry"> | bigint | number
    lat?: DecimalWithAggregatesFilter<"VehicleTelemetry"> | Decimal | DecimalJsLike | number | string
    lon?: DecimalWithAggregatesFilter<"VehicleTelemetry"> | Decimal | DecimalJsLike | number | string
    speed?: DecimalNullableWithAggregatesFilter<"VehicleTelemetry"> | Decimal | DecimalJsLike | number | string | null
    ignition?: BoolWithAggregatesFilter<"VehicleTelemetry"> | boolean
    trackedOn?: DateTimeWithAggregatesFilter<"VehicleTelemetry"> | Date | string
    vehicleId?: BigIntWithAggregatesFilter<"VehicleTelemetry"> | bigint | number
  }

  export type VehicleTelemetryHistoryWhereInput = {
    AND?: VehicleTelemetryHistoryWhereInput | VehicleTelemetryHistoryWhereInput[]
    OR?: VehicleTelemetryHistoryWhereInput[]
    NOT?: VehicleTelemetryHistoryWhereInput | VehicleTelemetryHistoryWhereInput[]
    id?: BigIntFilter<"VehicleTelemetryHistory"> | bigint | number
    lat?: DecimalFilter<"VehicleTelemetryHistory"> | Decimal | DecimalJsLike | number | string
    lon?: DecimalFilter<"VehicleTelemetryHistory"> | Decimal | DecimalJsLike | number | string
    speed?: DecimalNullableFilter<"VehicleTelemetryHistory"> | Decimal | DecimalJsLike | number | string | null
    ignition?: BoolFilter<"VehicleTelemetryHistory"> | boolean
    trackedOn?: DateTimeFilter<"VehicleTelemetryHistory"> | Date | string
    vehicleId?: BigIntFilter<"VehicleTelemetryHistory"> | bigint | number
    vehicle?: XOR<VehicleRelationFilter, VehicleWhereInput>
  }

  export type VehicleTelemetryHistoryOrderByWithRelationInput = {
    id?: SortOrder
    lat?: SortOrder
    lon?: SortOrder
    speed?: SortOrderInput | SortOrder
    ignition?: SortOrder
    trackedOn?: SortOrder
    vehicleId?: SortOrder
    vehicle?: VehicleOrderByWithRelationInput
  }

  export type VehicleTelemetryHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: VehicleTelemetryHistoryWhereInput | VehicleTelemetryHistoryWhereInput[]
    OR?: VehicleTelemetryHistoryWhereInput[]
    NOT?: VehicleTelemetryHistoryWhereInput | VehicleTelemetryHistoryWhereInput[]
    lat?: DecimalFilter<"VehicleTelemetryHistory"> | Decimal | DecimalJsLike | number | string
    lon?: DecimalFilter<"VehicleTelemetryHistory"> | Decimal | DecimalJsLike | number | string
    speed?: DecimalNullableFilter<"VehicleTelemetryHistory"> | Decimal | DecimalJsLike | number | string | null
    ignition?: BoolFilter<"VehicleTelemetryHistory"> | boolean
    trackedOn?: DateTimeFilter<"VehicleTelemetryHistory"> | Date | string
    vehicleId?: BigIntFilter<"VehicleTelemetryHistory"> | bigint | number
    vehicle?: XOR<VehicleRelationFilter, VehicleWhereInput>
  }, "id">

  export type VehicleTelemetryHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    lat?: SortOrder
    lon?: SortOrder
    speed?: SortOrderInput | SortOrder
    ignition?: SortOrder
    trackedOn?: SortOrder
    vehicleId?: SortOrder
    _count?: VehicleTelemetryHistoryCountOrderByAggregateInput
    _avg?: VehicleTelemetryHistoryAvgOrderByAggregateInput
    _max?: VehicleTelemetryHistoryMaxOrderByAggregateInput
    _min?: VehicleTelemetryHistoryMinOrderByAggregateInput
    _sum?: VehicleTelemetryHistorySumOrderByAggregateInput
  }

  export type VehicleTelemetryHistoryScalarWhereWithAggregatesInput = {
    AND?: VehicleTelemetryHistoryScalarWhereWithAggregatesInput | VehicleTelemetryHistoryScalarWhereWithAggregatesInput[]
    OR?: VehicleTelemetryHistoryScalarWhereWithAggregatesInput[]
    NOT?: VehicleTelemetryHistoryScalarWhereWithAggregatesInput | VehicleTelemetryHistoryScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"VehicleTelemetryHistory"> | bigint | number
    lat?: DecimalWithAggregatesFilter<"VehicleTelemetryHistory"> | Decimal | DecimalJsLike | number | string
    lon?: DecimalWithAggregatesFilter<"VehicleTelemetryHistory"> | Decimal | DecimalJsLike | number | string
    speed?: DecimalNullableWithAggregatesFilter<"VehicleTelemetryHistory"> | Decimal | DecimalJsLike | number | string | null
    ignition?: BoolWithAggregatesFilter<"VehicleTelemetryHistory"> | boolean
    trackedOn?: DateTimeWithAggregatesFilter<"VehicleTelemetryHistory"> | Date | string
    vehicleId?: BigIntWithAggregatesFilter<"VehicleTelemetryHistory"> | bigint | number
  }

  export type ShiftWhereInput = {
    AND?: ShiftWhereInput | ShiftWhereInput[]
    OR?: ShiftWhereInput[]
    NOT?: ShiftWhereInput | ShiftWhereInput[]
    id?: BigIntFilter<"Shift"> | bigint | number
    startTime?: DateTimeFilter<"Shift"> | Date | string
    endTime?: DateTimeFilter<"Shift"> | Date | string
    vehicleId?: BigIntFilter<"Shift"> | bigint | number
    driverId?: BigIntFilter<"Shift"> | bigint | number
    vehicle?: XOR<VehicleRelationFilter, VehicleWhereInput>
    driver?: XOR<DriverRelationFilter, DriverWhereInput>
  }

  export type ShiftOrderByWithRelationInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    vehicleId?: SortOrder
    driverId?: SortOrder
    vehicle?: VehicleOrderByWithRelationInput
    driver?: DriverOrderByWithRelationInput
  }

  export type ShiftWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: ShiftWhereInput | ShiftWhereInput[]
    OR?: ShiftWhereInput[]
    NOT?: ShiftWhereInput | ShiftWhereInput[]
    startTime?: DateTimeFilter<"Shift"> | Date | string
    endTime?: DateTimeFilter<"Shift"> | Date | string
    vehicleId?: BigIntFilter<"Shift"> | bigint | number
    driverId?: BigIntFilter<"Shift"> | bigint | number
    vehicle?: XOR<VehicleRelationFilter, VehicleWhereInput>
    driver?: XOR<DriverRelationFilter, DriverWhereInput>
  }, "id">

  export type ShiftOrderByWithAggregationInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    vehicleId?: SortOrder
    driverId?: SortOrder
    _count?: ShiftCountOrderByAggregateInput
    _avg?: ShiftAvgOrderByAggregateInput
    _max?: ShiftMaxOrderByAggregateInput
    _min?: ShiftMinOrderByAggregateInput
    _sum?: ShiftSumOrderByAggregateInput
  }

  export type ShiftScalarWhereWithAggregatesInput = {
    AND?: ShiftScalarWhereWithAggregatesInput | ShiftScalarWhereWithAggregatesInput[]
    OR?: ShiftScalarWhereWithAggregatesInput[]
    NOT?: ShiftScalarWhereWithAggregatesInput | ShiftScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"Shift"> | bigint | number
    startTime?: DateTimeWithAggregatesFilter<"Shift"> | Date | string
    endTime?: DateTimeWithAggregatesFilter<"Shift"> | Date | string
    vehicleId?: BigIntWithAggregatesFilter<"Shift"> | bigint | number
    driverId?: BigIntWithAggregatesFilter<"Shift"> | bigint | number
  }

  export type ServiceScheduleWhereInput = {
    AND?: ServiceScheduleWhereInput | ServiceScheduleWhereInput[]
    OR?: ServiceScheduleWhereInput[]
    NOT?: ServiceScheduleWhereInput | ServiceScheduleWhereInput[]
    id?: BigIntFilter<"ServiceSchedule"> | bigint | number
    name?: StringFilter<"ServiceSchedule"> | string
    createdAt?: DateTimeFilter<"ServiceSchedule"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceSchedule"> | Date | string
    dutyTemplates?: DutyTemplateListRelationFilter
    vehicleBlockTemplates?: VehicleBlockTemplateListRelationFilter
    driverRunTemplates?: DriverRunTemplateListRelationFilter
  }

  export type ServiceScheduleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    dutyTemplates?: DutyTemplateOrderByRelationAggregateInput
    vehicleBlockTemplates?: VehicleBlockTemplateOrderByRelationAggregateInput
    driverRunTemplates?: DriverRunTemplateOrderByRelationAggregateInput
  }

  export type ServiceScheduleWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: ServiceScheduleWhereInput | ServiceScheduleWhereInput[]
    OR?: ServiceScheduleWhereInput[]
    NOT?: ServiceScheduleWhereInput | ServiceScheduleWhereInput[]
    name?: StringFilter<"ServiceSchedule"> | string
    createdAt?: DateTimeFilter<"ServiceSchedule"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceSchedule"> | Date | string
    dutyTemplates?: DutyTemplateListRelationFilter
    vehicleBlockTemplates?: VehicleBlockTemplateListRelationFilter
    driverRunTemplates?: DriverRunTemplateListRelationFilter
  }, "id">

  export type ServiceScheduleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ServiceScheduleCountOrderByAggregateInput
    _avg?: ServiceScheduleAvgOrderByAggregateInput
    _max?: ServiceScheduleMaxOrderByAggregateInput
    _min?: ServiceScheduleMinOrderByAggregateInput
    _sum?: ServiceScheduleSumOrderByAggregateInput
  }

  export type ServiceScheduleScalarWhereWithAggregatesInput = {
    AND?: ServiceScheduleScalarWhereWithAggregatesInput | ServiceScheduleScalarWhereWithAggregatesInput[]
    OR?: ServiceScheduleScalarWhereWithAggregatesInput[]
    NOT?: ServiceScheduleScalarWhereWithAggregatesInput | ServiceScheduleScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"ServiceSchedule"> | bigint | number
    name?: StringWithAggregatesFilter<"ServiceSchedule"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ServiceSchedule"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ServiceSchedule"> | Date | string
  }

  export type VehicleBlockTemplateWhereInput = {
    AND?: VehicleBlockTemplateWhereInput | VehicleBlockTemplateWhereInput[]
    OR?: VehicleBlockTemplateWhereInput[]
    NOT?: VehicleBlockTemplateWhereInput | VehicleBlockTemplateWhereInput[]
    id?: BigIntFilter<"VehicleBlockTemplate"> | bigint | number
    scheduleId?: BigIntFilter<"VehicleBlockTemplate"> | bigint | number
    code?: StringFilter<"VehicleBlockTemplate"> | string
    color?: StringFilter<"VehicleBlockTemplate"> | string
    schedule?: XOR<ServiceScheduleRelationFilter, ServiceScheduleWhereInput>
    DutyTemplate?: DutyTemplateListRelationFilter
    VehicleBlock?: VehicleBlockListRelationFilter
  }

  export type VehicleBlockTemplateOrderByWithRelationInput = {
    id?: SortOrder
    scheduleId?: SortOrder
    code?: SortOrder
    color?: SortOrder
    schedule?: ServiceScheduleOrderByWithRelationInput
    DutyTemplate?: DutyTemplateOrderByRelationAggregateInput
    VehicleBlock?: VehicleBlockOrderByRelationAggregateInput
  }

  export type VehicleBlockTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    scheduleId_code?: VehicleBlockTemplateScheduleIdCodeCompoundUniqueInput
    AND?: VehicleBlockTemplateWhereInput | VehicleBlockTemplateWhereInput[]
    OR?: VehicleBlockTemplateWhereInput[]
    NOT?: VehicleBlockTemplateWhereInput | VehicleBlockTemplateWhereInput[]
    scheduleId?: BigIntFilter<"VehicleBlockTemplate"> | bigint | number
    code?: StringFilter<"VehicleBlockTemplate"> | string
    color?: StringFilter<"VehicleBlockTemplate"> | string
    schedule?: XOR<ServiceScheduleRelationFilter, ServiceScheduleWhereInput>
    DutyTemplate?: DutyTemplateListRelationFilter
    VehicleBlock?: VehicleBlockListRelationFilter
  }, "id" | "scheduleId_code">

  export type VehicleBlockTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    scheduleId?: SortOrder
    code?: SortOrder
    color?: SortOrder
    _count?: VehicleBlockTemplateCountOrderByAggregateInput
    _avg?: VehicleBlockTemplateAvgOrderByAggregateInput
    _max?: VehicleBlockTemplateMaxOrderByAggregateInput
    _min?: VehicleBlockTemplateMinOrderByAggregateInput
    _sum?: VehicleBlockTemplateSumOrderByAggregateInput
  }

  export type VehicleBlockTemplateScalarWhereWithAggregatesInput = {
    AND?: VehicleBlockTemplateScalarWhereWithAggregatesInput | VehicleBlockTemplateScalarWhereWithAggregatesInput[]
    OR?: VehicleBlockTemplateScalarWhereWithAggregatesInput[]
    NOT?: VehicleBlockTemplateScalarWhereWithAggregatesInput | VehicleBlockTemplateScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"VehicleBlockTemplate"> | bigint | number
    scheduleId?: BigIntWithAggregatesFilter<"VehicleBlockTemplate"> | bigint | number
    code?: StringWithAggregatesFilter<"VehicleBlockTemplate"> | string
    color?: StringWithAggregatesFilter<"VehicleBlockTemplate"> | string
  }

  export type DriverRunTemplateWhereInput = {
    AND?: DriverRunTemplateWhereInput | DriverRunTemplateWhereInput[]
    OR?: DriverRunTemplateWhereInput[]
    NOT?: DriverRunTemplateWhereInput | DriverRunTemplateWhereInput[]
    id?: BigIntFilter<"DriverRunTemplate"> | bigint | number
    scheduleId?: BigIntFilter<"DriverRunTemplate"> | bigint | number
    code?: StringFilter<"DriverRunTemplate"> | string
    color?: StringFilter<"DriverRunTemplate"> | string
    schedule?: XOR<ServiceScheduleRelationFilter, ServiceScheduleWhereInput>
    DutyTemplate?: DutyTemplateListRelationFilter
    DriverRun?: DriverRunListRelationFilter
  }

  export type DriverRunTemplateOrderByWithRelationInput = {
    id?: SortOrder
    scheduleId?: SortOrder
    code?: SortOrder
    color?: SortOrder
    schedule?: ServiceScheduleOrderByWithRelationInput
    DutyTemplate?: DutyTemplateOrderByRelationAggregateInput
    DriverRun?: DriverRunOrderByRelationAggregateInput
  }

  export type DriverRunTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    scheduleId_code?: DriverRunTemplateScheduleIdCodeCompoundUniqueInput
    AND?: DriverRunTemplateWhereInput | DriverRunTemplateWhereInput[]
    OR?: DriverRunTemplateWhereInput[]
    NOT?: DriverRunTemplateWhereInput | DriverRunTemplateWhereInput[]
    scheduleId?: BigIntFilter<"DriverRunTemplate"> | bigint | number
    code?: StringFilter<"DriverRunTemplate"> | string
    color?: StringFilter<"DriverRunTemplate"> | string
    schedule?: XOR<ServiceScheduleRelationFilter, ServiceScheduleWhereInput>
    DutyTemplate?: DutyTemplateListRelationFilter
    DriverRun?: DriverRunListRelationFilter
  }, "id" | "scheduleId_code">

  export type DriverRunTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    scheduleId?: SortOrder
    code?: SortOrder
    color?: SortOrder
    _count?: DriverRunTemplateCountOrderByAggregateInput
    _avg?: DriverRunTemplateAvgOrderByAggregateInput
    _max?: DriverRunTemplateMaxOrderByAggregateInput
    _min?: DriverRunTemplateMinOrderByAggregateInput
    _sum?: DriverRunTemplateSumOrderByAggregateInput
  }

  export type DriverRunTemplateScalarWhereWithAggregatesInput = {
    AND?: DriverRunTemplateScalarWhereWithAggregatesInput | DriverRunTemplateScalarWhereWithAggregatesInput[]
    OR?: DriverRunTemplateScalarWhereWithAggregatesInput[]
    NOT?: DriverRunTemplateScalarWhereWithAggregatesInput | DriverRunTemplateScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"DriverRunTemplate"> | bigint | number
    scheduleId?: BigIntWithAggregatesFilter<"DriverRunTemplate"> | bigint | number
    code?: StringWithAggregatesFilter<"DriverRunTemplate"> | string
    color?: StringWithAggregatesFilter<"DriverRunTemplate"> | string
  }

  export type DutyTemplateWhereInput = {
    AND?: DutyTemplateWhereInput | DutyTemplateWhereInput[]
    OR?: DutyTemplateWhereInput[]
    NOT?: DutyTemplateWhereInput | DutyTemplateWhereInput[]
    id?: BigIntFilter<"DutyTemplate"> | bigint | number
    name?: StringNullableFilter<"DutyTemplate"> | string | null
    startTime?: DateTimeFilter<"DutyTemplate"> | Date | string
    endTime?: DateTimeFilter<"DutyTemplate"> | Date | string
    dutyType?: EnumDutyTypeFilter<"DutyTemplate"> | $Enums.DutyType
    vehicleBlockTemplateId?: BigIntNullableFilter<"DutyTemplate"> | bigint | number | null
    driverRunTemplateId?: BigIntNullableFilter<"DutyTemplate"> | bigint | number | null
    scheduleId?: BigIntFilter<"DutyTemplate"> | bigint | number
    createdAt?: DateTimeFilter<"DutyTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"DutyTemplate"> | Date | string
    vehicleBlockTemplate?: XOR<VehicleBlockTemplateNullableRelationFilter, VehicleBlockTemplateWhereInput> | null
    driverRunTemplate?: XOR<DriverRunTemplateNullableRelationFilter, DriverRunTemplateWhereInput> | null
    schedule?: XOR<ServiceScheduleRelationFilter, ServiceScheduleWhereInput>
  }

  export type DutyTemplateOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    dutyType?: SortOrder
    vehicleBlockTemplateId?: SortOrderInput | SortOrder
    driverRunTemplateId?: SortOrderInput | SortOrder
    scheduleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vehicleBlockTemplate?: VehicleBlockTemplateOrderByWithRelationInput
    driverRunTemplate?: DriverRunTemplateOrderByWithRelationInput
    schedule?: ServiceScheduleOrderByWithRelationInput
  }

  export type DutyTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: DutyTemplateWhereInput | DutyTemplateWhereInput[]
    OR?: DutyTemplateWhereInput[]
    NOT?: DutyTemplateWhereInput | DutyTemplateWhereInput[]
    name?: StringNullableFilter<"DutyTemplate"> | string | null
    startTime?: DateTimeFilter<"DutyTemplate"> | Date | string
    endTime?: DateTimeFilter<"DutyTemplate"> | Date | string
    dutyType?: EnumDutyTypeFilter<"DutyTemplate"> | $Enums.DutyType
    vehicleBlockTemplateId?: BigIntNullableFilter<"DutyTemplate"> | bigint | number | null
    driverRunTemplateId?: BigIntNullableFilter<"DutyTemplate"> | bigint | number | null
    scheduleId?: BigIntFilter<"DutyTemplate"> | bigint | number
    createdAt?: DateTimeFilter<"DutyTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"DutyTemplate"> | Date | string
    vehicleBlockTemplate?: XOR<VehicleBlockTemplateNullableRelationFilter, VehicleBlockTemplateWhereInput> | null
    driverRunTemplate?: XOR<DriverRunTemplateNullableRelationFilter, DriverRunTemplateWhereInput> | null
    schedule?: XOR<ServiceScheduleRelationFilter, ServiceScheduleWhereInput>
  }, "id">

  export type DutyTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    dutyType?: SortOrder
    vehicleBlockTemplateId?: SortOrderInput | SortOrder
    driverRunTemplateId?: SortOrderInput | SortOrder
    scheduleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DutyTemplateCountOrderByAggregateInput
    _avg?: DutyTemplateAvgOrderByAggregateInput
    _max?: DutyTemplateMaxOrderByAggregateInput
    _min?: DutyTemplateMinOrderByAggregateInput
    _sum?: DutyTemplateSumOrderByAggregateInput
  }

  export type DutyTemplateScalarWhereWithAggregatesInput = {
    AND?: DutyTemplateScalarWhereWithAggregatesInput | DutyTemplateScalarWhereWithAggregatesInput[]
    OR?: DutyTemplateScalarWhereWithAggregatesInput[]
    NOT?: DutyTemplateScalarWhereWithAggregatesInput | DutyTemplateScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"DutyTemplate"> | bigint | number
    name?: StringNullableWithAggregatesFilter<"DutyTemplate"> | string | null
    startTime?: DateTimeWithAggregatesFilter<"DutyTemplate"> | Date | string
    endTime?: DateTimeWithAggregatesFilter<"DutyTemplate"> | Date | string
    dutyType?: EnumDutyTypeWithAggregatesFilter<"DutyTemplate"> | $Enums.DutyType
    vehicleBlockTemplateId?: BigIntNullableWithAggregatesFilter<"DutyTemplate"> | bigint | number | null
    driverRunTemplateId?: BigIntNullableWithAggregatesFilter<"DutyTemplate"> | bigint | number | null
    scheduleId?: BigIntWithAggregatesFilter<"DutyTemplate"> | bigint | number
    createdAt?: DateTimeWithAggregatesFilter<"DutyTemplate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DutyTemplate"> | Date | string
  }

  export type VehicleBlockWhereInput = {
    AND?: VehicleBlockWhereInput | VehicleBlockWhereInput[]
    OR?: VehicleBlockWhereInput[]
    NOT?: VehicleBlockWhereInput | VehicleBlockWhereInput[]
    id?: BigIntFilter<"VehicleBlock"> | bigint | number
    vehicleBlockTemplateId?: BigIntFilter<"VehicleBlock"> | bigint | number
    code?: StringFilter<"VehicleBlock"> | string
    vehicleBlockTemplate?: XOR<VehicleBlockTemplateRelationFilter, VehicleBlockTemplateWhereInput>
    Duty?: DutyListRelationFilter
  }

  export type VehicleBlockOrderByWithRelationInput = {
    id?: SortOrder
    vehicleBlockTemplateId?: SortOrder
    code?: SortOrder
    vehicleBlockTemplate?: VehicleBlockTemplateOrderByWithRelationInput
    Duty?: DutyOrderByRelationAggregateInput
  }

  export type VehicleBlockWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    code?: string
    AND?: VehicleBlockWhereInput | VehicleBlockWhereInput[]
    OR?: VehicleBlockWhereInput[]
    NOT?: VehicleBlockWhereInput | VehicleBlockWhereInput[]
    vehicleBlockTemplateId?: BigIntFilter<"VehicleBlock"> | bigint | number
    vehicleBlockTemplate?: XOR<VehicleBlockTemplateRelationFilter, VehicleBlockTemplateWhereInput>
    Duty?: DutyListRelationFilter
  }, "id" | "code">

  export type VehicleBlockOrderByWithAggregationInput = {
    id?: SortOrder
    vehicleBlockTemplateId?: SortOrder
    code?: SortOrder
    _count?: VehicleBlockCountOrderByAggregateInput
    _avg?: VehicleBlockAvgOrderByAggregateInput
    _max?: VehicleBlockMaxOrderByAggregateInput
    _min?: VehicleBlockMinOrderByAggregateInput
    _sum?: VehicleBlockSumOrderByAggregateInput
  }

  export type VehicleBlockScalarWhereWithAggregatesInput = {
    AND?: VehicleBlockScalarWhereWithAggregatesInput | VehicleBlockScalarWhereWithAggregatesInput[]
    OR?: VehicleBlockScalarWhereWithAggregatesInput[]
    NOT?: VehicleBlockScalarWhereWithAggregatesInput | VehicleBlockScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"VehicleBlock"> | bigint | number
    vehicleBlockTemplateId?: BigIntWithAggregatesFilter<"VehicleBlock"> | bigint | number
    code?: StringWithAggregatesFilter<"VehicleBlock"> | string
  }

  export type DriverRunWhereInput = {
    AND?: DriverRunWhereInput | DriverRunWhereInput[]
    OR?: DriverRunWhereInput[]
    NOT?: DriverRunWhereInput | DriverRunWhereInput[]
    id?: BigIntFilter<"DriverRun"> | bigint | number
    driverRunTemplateId?: BigIntFilter<"DriverRun"> | bigint | number
    code?: StringFilter<"DriverRun"> | string
    driverRunTemplate?: XOR<DriverRunTemplateRelationFilter, DriverRunTemplateWhereInput>
    Duty?: DutyListRelationFilter
  }

  export type DriverRunOrderByWithRelationInput = {
    id?: SortOrder
    driverRunTemplateId?: SortOrder
    code?: SortOrder
    driverRunTemplate?: DriverRunTemplateOrderByWithRelationInput
    Duty?: DutyOrderByRelationAggregateInput
  }

  export type DriverRunWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    code?: string
    AND?: DriverRunWhereInput | DriverRunWhereInput[]
    OR?: DriverRunWhereInput[]
    NOT?: DriverRunWhereInput | DriverRunWhereInput[]
    driverRunTemplateId?: BigIntFilter<"DriverRun"> | bigint | number
    driverRunTemplate?: XOR<DriverRunTemplateRelationFilter, DriverRunTemplateWhereInput>
    Duty?: DutyListRelationFilter
  }, "id" | "code">

  export type DriverRunOrderByWithAggregationInput = {
    id?: SortOrder
    driverRunTemplateId?: SortOrder
    code?: SortOrder
    _count?: DriverRunCountOrderByAggregateInput
    _avg?: DriverRunAvgOrderByAggregateInput
    _max?: DriverRunMaxOrderByAggregateInput
    _min?: DriverRunMinOrderByAggregateInput
    _sum?: DriverRunSumOrderByAggregateInput
  }

  export type DriverRunScalarWhereWithAggregatesInput = {
    AND?: DriverRunScalarWhereWithAggregatesInput | DriverRunScalarWhereWithAggregatesInput[]
    OR?: DriverRunScalarWhereWithAggregatesInput[]
    NOT?: DriverRunScalarWhereWithAggregatesInput | DriverRunScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"DriverRun"> | bigint | number
    driverRunTemplateId?: BigIntWithAggregatesFilter<"DriverRun"> | bigint | number
    code?: StringWithAggregatesFilter<"DriverRun"> | string
  }

  export type DutyWhereInput = {
    AND?: DutyWhereInput | DutyWhereInput[]
    OR?: DutyWhereInput[]
    NOT?: DutyWhereInput | DutyWhereInput[]
    id?: BigIntFilter<"Duty"> | bigint | number
    date?: DateTimeFilter<"Duty"> | Date | string
    startTime?: DateTimeFilter<"Duty"> | Date | string
    endTime?: DateTimeFilter<"Duty"> | Date | string
    driverId?: BigIntNullableFilter<"Duty"> | bigint | number | null
    vehicleId?: BigIntNullableFilter<"Duty"> | bigint | number | null
    dutyTemplateId?: BigIntNullableFilter<"Duty"> | bigint | number | null
    blockId?: BigIntNullableFilter<"Duty"> | bigint | number | null
    runId?: BigIntNullableFilter<"Duty"> | bigint | number | null
    dutyType?: EnumDutyTypeFilter<"Duty"> | $Enums.DutyType
    block?: XOR<VehicleBlockNullableRelationFilter, VehicleBlockWhereInput> | null
    run?: XOR<DriverRunNullableRelationFilter, DriverRunWhereInput> | null
    driver?: XOR<DriverNullableRelationFilter, DriverWhereInput> | null
    vehicle?: XOR<VehicleNullableRelationFilter, VehicleWhereInput> | null
    tripDuties?: TripDutyListRelationFilter
    washingDuties?: WashingDutyListRelationFilter
    maintenanceDuties?: MaintenanceDutyListRelationFilter
  }

  export type DutyOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    driverId?: SortOrderInput | SortOrder
    vehicleId?: SortOrderInput | SortOrder
    dutyTemplateId?: SortOrderInput | SortOrder
    blockId?: SortOrderInput | SortOrder
    runId?: SortOrderInput | SortOrder
    dutyType?: SortOrder
    block?: VehicleBlockOrderByWithRelationInput
    run?: DriverRunOrderByWithRelationInput
    driver?: DriverOrderByWithRelationInput
    vehicle?: VehicleOrderByWithRelationInput
    tripDuties?: TripDutyOrderByRelationAggregateInput
    washingDuties?: WashingDutyOrderByRelationAggregateInput
    maintenanceDuties?: MaintenanceDutyOrderByRelationAggregateInput
  }

  export type DutyWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: DutyWhereInput | DutyWhereInput[]
    OR?: DutyWhereInput[]
    NOT?: DutyWhereInput | DutyWhereInput[]
    date?: DateTimeFilter<"Duty"> | Date | string
    startTime?: DateTimeFilter<"Duty"> | Date | string
    endTime?: DateTimeFilter<"Duty"> | Date | string
    driverId?: BigIntNullableFilter<"Duty"> | bigint | number | null
    vehicleId?: BigIntNullableFilter<"Duty"> | bigint | number | null
    dutyTemplateId?: BigIntNullableFilter<"Duty"> | bigint | number | null
    blockId?: BigIntNullableFilter<"Duty"> | bigint | number | null
    runId?: BigIntNullableFilter<"Duty"> | bigint | number | null
    dutyType?: EnumDutyTypeFilter<"Duty"> | $Enums.DutyType
    block?: XOR<VehicleBlockNullableRelationFilter, VehicleBlockWhereInput> | null
    run?: XOR<DriverRunNullableRelationFilter, DriverRunWhereInput> | null
    driver?: XOR<DriverNullableRelationFilter, DriverWhereInput> | null
    vehicle?: XOR<VehicleNullableRelationFilter, VehicleWhereInput> | null
    tripDuties?: TripDutyListRelationFilter
    washingDuties?: WashingDutyListRelationFilter
    maintenanceDuties?: MaintenanceDutyListRelationFilter
  }, "id">

  export type DutyOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    driverId?: SortOrderInput | SortOrder
    vehicleId?: SortOrderInput | SortOrder
    dutyTemplateId?: SortOrderInput | SortOrder
    blockId?: SortOrderInput | SortOrder
    runId?: SortOrderInput | SortOrder
    dutyType?: SortOrder
    _count?: DutyCountOrderByAggregateInput
    _avg?: DutyAvgOrderByAggregateInput
    _max?: DutyMaxOrderByAggregateInput
    _min?: DutyMinOrderByAggregateInput
    _sum?: DutySumOrderByAggregateInput
  }

  export type DutyScalarWhereWithAggregatesInput = {
    AND?: DutyScalarWhereWithAggregatesInput | DutyScalarWhereWithAggregatesInput[]
    OR?: DutyScalarWhereWithAggregatesInput[]
    NOT?: DutyScalarWhereWithAggregatesInput | DutyScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"Duty"> | bigint | number
    date?: DateTimeWithAggregatesFilter<"Duty"> | Date | string
    startTime?: DateTimeWithAggregatesFilter<"Duty"> | Date | string
    endTime?: DateTimeWithAggregatesFilter<"Duty"> | Date | string
    driverId?: BigIntNullableWithAggregatesFilter<"Duty"> | bigint | number | null
    vehicleId?: BigIntNullableWithAggregatesFilter<"Duty"> | bigint | number | null
    dutyTemplateId?: BigIntNullableWithAggregatesFilter<"Duty"> | bigint | number | null
    blockId?: BigIntNullableWithAggregatesFilter<"Duty"> | bigint | number | null
    runId?: BigIntNullableWithAggregatesFilter<"Duty"> | bigint | number | null
    dutyType?: EnumDutyTypeWithAggregatesFilter<"Duty"> | $Enums.DutyType
  }

  export type TripDutyWhereInput = {
    AND?: TripDutyWhereInput | TripDutyWhereInput[]
    OR?: TripDutyWhereInput[]
    NOT?: TripDutyWhereInput | TripDutyWhereInput[]
    id?: BigIntFilter<"TripDuty"> | bigint | number
    dutyId?: BigIntFilter<"TripDuty"> | bigint | number
    routeId?: BigIntFilter<"TripDuty"> | bigint | number
    duty?: XOR<DutyRelationFilter, DutyWhereInput>
    route?: XOR<RouteRelationFilter, RouteWhereInput>
  }

  export type TripDutyOrderByWithRelationInput = {
    id?: SortOrder
    dutyId?: SortOrder
    routeId?: SortOrder
    duty?: DutyOrderByWithRelationInput
    route?: RouteOrderByWithRelationInput
  }

  export type TripDutyWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: TripDutyWhereInput | TripDutyWhereInput[]
    OR?: TripDutyWhereInput[]
    NOT?: TripDutyWhereInput | TripDutyWhereInput[]
    dutyId?: BigIntFilter<"TripDuty"> | bigint | number
    routeId?: BigIntFilter<"TripDuty"> | bigint | number
    duty?: XOR<DutyRelationFilter, DutyWhereInput>
    route?: XOR<RouteRelationFilter, RouteWhereInput>
  }, "id">

  export type TripDutyOrderByWithAggregationInput = {
    id?: SortOrder
    dutyId?: SortOrder
    routeId?: SortOrder
    _count?: TripDutyCountOrderByAggregateInput
    _avg?: TripDutyAvgOrderByAggregateInput
    _max?: TripDutyMaxOrderByAggregateInput
    _min?: TripDutyMinOrderByAggregateInput
    _sum?: TripDutySumOrderByAggregateInput
  }

  export type TripDutyScalarWhereWithAggregatesInput = {
    AND?: TripDutyScalarWhereWithAggregatesInput | TripDutyScalarWhereWithAggregatesInput[]
    OR?: TripDutyScalarWhereWithAggregatesInput[]
    NOT?: TripDutyScalarWhereWithAggregatesInput | TripDutyScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"TripDuty"> | bigint | number
    dutyId?: BigIntWithAggregatesFilter<"TripDuty"> | bigint | number
    routeId?: BigIntWithAggregatesFilter<"TripDuty"> | bigint | number
  }

  export type WashingDutyWhereInput = {
    AND?: WashingDutyWhereInput | WashingDutyWhereInput[]
    OR?: WashingDutyWhereInput[]
    NOT?: WashingDutyWhereInput | WashingDutyWhereInput[]
    id?: BigIntFilter<"WashingDuty"> | bigint | number
    dutyId?: BigIntFilter<"WashingDuty"> | bigint | number
    duty?: XOR<DutyRelationFilter, DutyWhereInput>
  }

  export type WashingDutyOrderByWithRelationInput = {
    id?: SortOrder
    dutyId?: SortOrder
    duty?: DutyOrderByWithRelationInput
  }

  export type WashingDutyWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: WashingDutyWhereInput | WashingDutyWhereInput[]
    OR?: WashingDutyWhereInput[]
    NOT?: WashingDutyWhereInput | WashingDutyWhereInput[]
    dutyId?: BigIntFilter<"WashingDuty"> | bigint | number
    duty?: XOR<DutyRelationFilter, DutyWhereInput>
  }, "id">

  export type WashingDutyOrderByWithAggregationInput = {
    id?: SortOrder
    dutyId?: SortOrder
    _count?: WashingDutyCountOrderByAggregateInput
    _avg?: WashingDutyAvgOrderByAggregateInput
    _max?: WashingDutyMaxOrderByAggregateInput
    _min?: WashingDutyMinOrderByAggregateInput
    _sum?: WashingDutySumOrderByAggregateInput
  }

  export type WashingDutyScalarWhereWithAggregatesInput = {
    AND?: WashingDutyScalarWhereWithAggregatesInput | WashingDutyScalarWhereWithAggregatesInput[]
    OR?: WashingDutyScalarWhereWithAggregatesInput[]
    NOT?: WashingDutyScalarWhereWithAggregatesInput | WashingDutyScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"WashingDuty"> | bigint | number
    dutyId?: BigIntWithAggregatesFilter<"WashingDuty"> | bigint | number
  }

  export type MaintenanceDutyWhereInput = {
    AND?: MaintenanceDutyWhereInput | MaintenanceDutyWhereInput[]
    OR?: MaintenanceDutyWhereInput[]
    NOT?: MaintenanceDutyWhereInput | MaintenanceDutyWhereInput[]
    id?: BigIntFilter<"MaintenanceDuty"> | bigint | number
    dutyId?: BigIntFilter<"MaintenanceDuty"> | bigint | number
    duty?: XOR<DutyRelationFilter, DutyWhereInput>
  }

  export type MaintenanceDutyOrderByWithRelationInput = {
    id?: SortOrder
    dutyId?: SortOrder
    duty?: DutyOrderByWithRelationInput
  }

  export type MaintenanceDutyWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: MaintenanceDutyWhereInput | MaintenanceDutyWhereInput[]
    OR?: MaintenanceDutyWhereInput[]
    NOT?: MaintenanceDutyWhereInput | MaintenanceDutyWhereInput[]
    dutyId?: BigIntFilter<"MaintenanceDuty"> | bigint | number
    duty?: XOR<DutyRelationFilter, DutyWhereInput>
  }, "id">

  export type MaintenanceDutyOrderByWithAggregationInput = {
    id?: SortOrder
    dutyId?: SortOrder
    _count?: MaintenanceDutyCountOrderByAggregateInput
    _avg?: MaintenanceDutyAvgOrderByAggregateInput
    _max?: MaintenanceDutyMaxOrderByAggregateInput
    _min?: MaintenanceDutyMinOrderByAggregateInput
    _sum?: MaintenanceDutySumOrderByAggregateInput
  }

  export type MaintenanceDutyScalarWhereWithAggregatesInput = {
    AND?: MaintenanceDutyScalarWhereWithAggregatesInput | MaintenanceDutyScalarWhereWithAggregatesInput[]
    OR?: MaintenanceDutyScalarWhereWithAggregatesInput[]
    NOT?: MaintenanceDutyScalarWhereWithAggregatesInput | MaintenanceDutyScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"MaintenanceDuty"> | bigint | number
    dutyId?: BigIntWithAggregatesFilter<"MaintenanceDuty"> | bigint | number
  }

  export type UserAuthCreateInput = {
    id?: bigint | number
    userType: string
    provider: string
    identifier: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutUserAuthsInput
  }

  export type UserAuthUncheckedCreateInput = {
    id?: bigint | number
    userId: bigint | number
    userType: string
    provider: string
    identifier: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserAuthUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    userType?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserAuthsNestedInput
  }

  export type UserAuthUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: BigIntFieldUpdateOperationsInput | bigint | number
    userType?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAuthCreateManyInput = {
    id?: bigint | number
    userId: bigint | number
    userType: string
    provider: string
    identifier: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserAuthUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    userType?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAuthUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: BigIntFieldUpdateOperationsInput | bigint | number
    userType?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserActivationCreateInput = {
    id?: bigint | number
    activationCode: string
    expiresAt: Date | string
    isUsed?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutUserActivationsInput
  }

  export type UserActivationUncheckedCreateInput = {
    id?: bigint | number
    userId: bigint | number
    activationCode: string
    expiresAt: Date | string
    isUsed?: boolean
    createdAt?: Date | string
  }

  export type UserActivationUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    activationCode?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserActivationsNestedInput
  }

  export type UserActivationUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: BigIntFieldUpdateOperationsInput | bigint | number
    activationCode?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserActivationCreateManyInput = {
    id?: bigint | number
    userId: bigint | number
    activationCode: string
    expiresAt: Date | string
    isUsed?: boolean
    createdAt?: Date | string
  }

  export type UserActivationUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    activationCode?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserActivationUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: BigIntFieldUpdateOperationsInput | bigint | number
    activationCode?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: bigint | number
    name: string
    email: string
    phone: string
    qid?: string | null
    userType?: number
    isActive?: boolean
    roles?: UserRoleCreateNestedManyWithoutUserInput
    userActivations?: UserActivationCreateNestedManyWithoutUserInput
    userAuths?: UserAuthCreateNestedManyWithoutUserInput
    drivers?: DriverCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: bigint | number
    name: string
    email: string
    phone: string
    qid?: string | null
    userType?: number
    isActive?: boolean
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    userActivations?: UserActivationUncheckedCreateNestedManyWithoutUserInput
    userAuths?: UserAuthUncheckedCreateNestedManyWithoutUserInput
    drivers?: DriverUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    qid?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    userActivations?: UserActivationUpdateManyWithoutUserNestedInput
    userAuths?: UserAuthUpdateManyWithoutUserNestedInput
    drivers?: DriverUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    qid?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    userActivations?: UserActivationUncheckedUpdateManyWithoutUserNestedInput
    userAuths?: UserAuthUncheckedUpdateManyWithoutUserNestedInput
    drivers?: DriverUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: bigint | number
    name: string
    email: string
    phone: string
    qid?: string | null
    userType?: number
    isActive?: boolean
  }

  export type UserUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    qid?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    qid?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RoleCreateInput = {
    id?: bigint | number
    name: string
    users?: UserRoleCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateInput = {
    id?: bigint | number
    name: string
    users?: UserRoleUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    users?: UserRoleUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    users?: UserRoleUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleCreateManyInput = {
    id?: bigint | number
    name: string
  }

  export type RoleUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type RoleUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type UserRoleCreateInput = {
    id?: bigint | number
    user: UserCreateNestedOneWithoutRolesInput
    role: RoleCreateNestedOneWithoutUsersInput
  }

  export type UserRoleUncheckedCreateInput = {
    id?: bigint | number
    userId: bigint | number
    roleId: bigint | number
  }

  export type UserRoleUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user?: UserUpdateOneRequiredWithoutRolesNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserRoleUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: BigIntFieldUpdateOperationsInput | bigint | number
    roleId?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type UserRoleCreateManyInput = {
    id?: bigint | number
    userId: bigint | number
    roleId: bigint | number
  }

  export type UserRoleUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type UserRoleUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: BigIntFieldUpdateOperationsInput | bigint | number
    roleId?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type DriverCreateInput = {
    id?: bigint | number
    licenseExpiry?: Date | string | null
    trips?: TripCreateNestedManyWithoutDriverInput
    shifts?: ShiftCreateNestedManyWithoutDriverInput
    user: UserCreateNestedOneWithoutDriversInput
    Duty?: DutyCreateNestedManyWithoutDriverInput
  }

  export type DriverUncheckedCreateInput = {
    id?: bigint | number
    userId: bigint | number
    licenseExpiry?: Date | string | null
    trips?: TripUncheckedCreateNestedManyWithoutDriverInput
    shifts?: ShiftUncheckedCreateNestedManyWithoutDriverInput
    Duty?: DutyUncheckedCreateNestedManyWithoutDriverInput
  }

  export type DriverUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    licenseExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trips?: TripUpdateManyWithoutDriverNestedInput
    shifts?: ShiftUpdateManyWithoutDriverNestedInput
    user?: UserUpdateOneRequiredWithoutDriversNestedInput
    Duty?: DutyUpdateManyWithoutDriverNestedInput
  }

  export type DriverUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: BigIntFieldUpdateOperationsInput | bigint | number
    licenseExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trips?: TripUncheckedUpdateManyWithoutDriverNestedInput
    shifts?: ShiftUncheckedUpdateManyWithoutDriverNestedInput
    Duty?: DutyUncheckedUpdateManyWithoutDriverNestedInput
  }

  export type DriverCreateManyInput = {
    id?: bigint | number
    userId: bigint | number
    licenseExpiry?: Date | string | null
  }

  export type DriverUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    licenseExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DriverUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: BigIntFieldUpdateOperationsInput | bigint | number
    licenseExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VehicleModelCreateInput = {
    id?: bigint | number
    make: string
    year: number
    manufacturer: string
    capacity: number
    vehicles?: VehicleCreateNestedManyWithoutModelInput
  }

  export type VehicleModelUncheckedCreateInput = {
    id?: bigint | number
    make: string
    year: number
    manufacturer: string
    capacity: number
    vehicles?: VehicleUncheckedCreateNestedManyWithoutModelInput
  }

  export type VehicleModelUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    make?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    manufacturer?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    vehicles?: VehicleUpdateManyWithoutModelNestedInput
  }

  export type VehicleModelUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    make?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    manufacturer?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    vehicles?: VehicleUncheckedUpdateManyWithoutModelNestedInput
  }

  export type VehicleModelCreateManyInput = {
    id?: bigint | number
    make: string
    year: number
    manufacturer: string
    capacity: number
  }

  export type VehicleModelUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    make?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    manufacturer?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
  }

  export type VehicleModelUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    make?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    manufacturer?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
  }

  export type VehicleCreateInput = {
    id?: bigint | number
    plateNo: string
    fleetNo: string
    model: VehicleModelCreateNestedOneWithoutVehiclesInput
    trips?: TripCreateNestedManyWithoutVehicleInput
    shifts?: ShiftCreateNestedManyWithoutVehicleInput
    telemetry?: VehicleTelemetryCreateNestedManyWithoutVehicleInput
    telemetryHistory?: VehicleTelemetryHistoryCreateNestedManyWithoutVehicleInput
    Duty?: DutyCreateNestedManyWithoutVehicleInput
  }

  export type VehicleUncheckedCreateInput = {
    id?: bigint | number
    plateNo: string
    fleetNo: string
    modelId: bigint | number
    trips?: TripUncheckedCreateNestedManyWithoutVehicleInput
    shifts?: ShiftUncheckedCreateNestedManyWithoutVehicleInput
    telemetry?: VehicleTelemetryUncheckedCreateNestedManyWithoutVehicleInput
    telemetryHistory?: VehicleTelemetryHistoryUncheckedCreateNestedManyWithoutVehicleInput
    Duty?: DutyUncheckedCreateNestedManyWithoutVehicleInput
  }

  export type VehicleUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    plateNo?: StringFieldUpdateOperationsInput | string
    fleetNo?: StringFieldUpdateOperationsInput | string
    model?: VehicleModelUpdateOneRequiredWithoutVehiclesNestedInput
    trips?: TripUpdateManyWithoutVehicleNestedInput
    shifts?: ShiftUpdateManyWithoutVehicleNestedInput
    telemetry?: VehicleTelemetryUpdateManyWithoutVehicleNestedInput
    telemetryHistory?: VehicleTelemetryHistoryUpdateManyWithoutVehicleNestedInput
    Duty?: DutyUpdateManyWithoutVehicleNestedInput
  }

  export type VehicleUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    plateNo?: StringFieldUpdateOperationsInput | string
    fleetNo?: StringFieldUpdateOperationsInput | string
    modelId?: BigIntFieldUpdateOperationsInput | bigint | number
    trips?: TripUncheckedUpdateManyWithoutVehicleNestedInput
    shifts?: ShiftUncheckedUpdateManyWithoutVehicleNestedInput
    telemetry?: VehicleTelemetryUncheckedUpdateManyWithoutVehicleNestedInput
    telemetryHistory?: VehicleTelemetryHistoryUncheckedUpdateManyWithoutVehicleNestedInput
    Duty?: DutyUncheckedUpdateManyWithoutVehicleNestedInput
  }

  export type VehicleCreateManyInput = {
    id?: bigint | number
    plateNo: string
    fleetNo: string
    modelId: bigint | number
  }

  export type VehicleUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    plateNo?: StringFieldUpdateOperationsInput | string
    fleetNo?: StringFieldUpdateOperationsInput | string
  }

  export type VehicleUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    plateNo?: StringFieldUpdateOperationsInput | string
    fleetNo?: StringFieldUpdateOperationsInput | string
    modelId?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type LocationCreateInput = {
    id?: bigint | number
    lat: Decimal | DecimalJsLike | number | string
    lon: Decimal | DecimalJsLike | number | string
    stops?: StopCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateInput = {
    id?: bigint | number
    lat: Decimal | DecimalJsLike | number | string
    lon: Decimal | DecimalJsLike | number | string
    stops?: StopUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    lat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lon?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stops?: StopUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    lat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lon?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stops?: StopUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type LocationCreateManyInput = {
    id?: bigint | number
    lat: Decimal | DecimalJsLike | number | string
    lon: Decimal | DecimalJsLike | number | string
  }

  export type LocationUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    lat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lon?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type LocationUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    lat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lon?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type StopCreateInput = {
    id?: bigint | number
    name: string
    code: string
    location: LocationCreateNestedOneWithoutStopsInput
    routeStops?: RouteStopCreateNestedManyWithoutStopInput
    tripStops?: TripStopCreateNestedManyWithoutStopInput
  }

  export type StopUncheckedCreateInput = {
    id?: bigint | number
    locationId: bigint | number
    name: string
    code: string
    routeStops?: RouteStopUncheckedCreateNestedManyWithoutStopInput
    tripStops?: TripStopUncheckedCreateNestedManyWithoutStopInput
  }

  export type StopUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    location?: LocationUpdateOneRequiredWithoutStopsNestedInput
    routeStops?: RouteStopUpdateManyWithoutStopNestedInput
    tripStops?: TripStopUpdateManyWithoutStopNestedInput
  }

  export type StopUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    locationId?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    routeStops?: RouteStopUncheckedUpdateManyWithoutStopNestedInput
    tripStops?: TripStopUncheckedUpdateManyWithoutStopNestedInput
  }

  export type StopCreateManyInput = {
    id?: bigint | number
    locationId: bigint | number
    name: string
    code: string
  }

  export type StopUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
  }

  export type StopUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    locationId?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
  }

  export type RouteCreateInput = {
    id?: bigint | number
    name: string
    code: string
    isActive?: boolean
    totalEstimatedDuration: number
    routeStops?: RouteStopCreateNestedManyWithoutRouteInput
    trips?: TripCreateNestedManyWithoutRouteInput
    TripDuty?: TripDutyCreateNestedManyWithoutRouteInput
  }

  export type RouteUncheckedCreateInput = {
    id?: bigint | number
    name: string
    code: string
    isActive?: boolean
    totalEstimatedDuration: number
    routeStops?: RouteStopUncheckedCreateNestedManyWithoutRouteInput
    trips?: TripUncheckedCreateNestedManyWithoutRouteInput
    TripDuty?: TripDutyUncheckedCreateNestedManyWithoutRouteInput
  }

  export type RouteUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    totalEstimatedDuration?: IntFieldUpdateOperationsInput | number
    routeStops?: RouteStopUpdateManyWithoutRouteNestedInput
    trips?: TripUpdateManyWithoutRouteNestedInput
    TripDuty?: TripDutyUpdateManyWithoutRouteNestedInput
  }

  export type RouteUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    totalEstimatedDuration?: IntFieldUpdateOperationsInput | number
    routeStops?: RouteStopUncheckedUpdateManyWithoutRouteNestedInput
    trips?: TripUncheckedUpdateManyWithoutRouteNestedInput
    TripDuty?: TripDutyUncheckedUpdateManyWithoutRouteNestedInput
  }

  export type RouteCreateManyInput = {
    id?: bigint | number
    name: string
    code: string
    isActive?: boolean
    totalEstimatedDuration: number
  }

  export type RouteUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    totalEstimatedDuration?: IntFieldUpdateOperationsInput | number
  }

  export type RouteUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    totalEstimatedDuration?: IntFieldUpdateOperationsInput | number
  }

  export type RouteStopCreateInput = {
    id?: bigint | number
    stopOrder: number
    isActive?: boolean
    path?: string | null
    eta?: number | null
    waitTime?: number | null
    route: RouteCreateNestedOneWithoutRouteStopsInput
    stop: StopCreateNestedOneWithoutRouteStopsInput
  }

  export type RouteStopUncheckedCreateInput = {
    id?: bigint | number
    routeId: bigint | number
    stopId: bigint | number
    stopOrder: number
    isActive?: boolean
    path?: string | null
    eta?: number | null
    waitTime?: number | null
  }

  export type RouteStopUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    stopOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    path?: NullableStringFieldUpdateOperationsInput | string | null
    eta?: NullableIntFieldUpdateOperationsInput | number | null
    waitTime?: NullableIntFieldUpdateOperationsInput | number | null
    route?: RouteUpdateOneRequiredWithoutRouteStopsNestedInput
    stop?: StopUpdateOneRequiredWithoutRouteStopsNestedInput
  }

  export type RouteStopUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    routeId?: BigIntFieldUpdateOperationsInput | bigint | number
    stopId?: BigIntFieldUpdateOperationsInput | bigint | number
    stopOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    path?: NullableStringFieldUpdateOperationsInput | string | null
    eta?: NullableIntFieldUpdateOperationsInput | number | null
    waitTime?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RouteStopCreateManyInput = {
    id?: bigint | number
    routeId: bigint | number
    stopId: bigint | number
    stopOrder: number
    isActive?: boolean
    path?: string | null
    eta?: number | null
    waitTime?: number | null
  }

  export type RouteStopUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    stopOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    path?: NullableStringFieldUpdateOperationsInput | string | null
    eta?: NullableIntFieldUpdateOperationsInput | number | null
    waitTime?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RouteStopUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    routeId?: BigIntFieldUpdateOperationsInput | bigint | number
    stopId?: BigIntFieldUpdateOperationsInput | bigint | number
    stopOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    path?: NullableStringFieldUpdateOperationsInput | string | null
    eta?: NullableIntFieldUpdateOperationsInput | number | null
    waitTime?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TripCreateInput = {
    id?: bigint | number
    startTime: Date | string
    endTime?: Date | string | null
    startLocation: bigint | number
    endLocation?: bigint | number | null
    averageSpeed?: Decimal | DecimalJsLike | number | string | null
    maxSpeed?: Decimal | DecimalJsLike | number | string | null
    totalDistance?: Decimal | DecimalJsLike | number | string | null
    totalDuration?: number | null
    idleTime?: number | null
    path?: string | null
    route: RouteCreateNestedOneWithoutTripsInput
    driver: DriverCreateNestedOneWithoutTripsInput
    vehicle: VehicleCreateNestedOneWithoutTripsInput
    tripStops?: TripStopCreateNestedManyWithoutTripInput
  }

  export type TripUncheckedCreateInput = {
    id?: bigint | number
    routeId: bigint | number
    startTime: Date | string
    endTime?: Date | string | null
    startLocation: bigint | number
    endLocation?: bigint | number | null
    driverId: bigint | number
    vehicleId: bigint | number
    averageSpeed?: Decimal | DecimalJsLike | number | string | null
    maxSpeed?: Decimal | DecimalJsLike | number | string | null
    totalDistance?: Decimal | DecimalJsLike | number | string | null
    totalDuration?: number | null
    idleTime?: number | null
    path?: string | null
    tripStops?: TripStopUncheckedCreateNestedManyWithoutTripInput
  }

  export type TripUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startLocation?: BigIntFieldUpdateOperationsInput | bigint | number
    endLocation?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    averageSpeed?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxSpeed?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalDistance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalDuration?: NullableIntFieldUpdateOperationsInput | number | null
    idleTime?: NullableIntFieldUpdateOperationsInput | number | null
    path?: NullableStringFieldUpdateOperationsInput | string | null
    route?: RouteUpdateOneRequiredWithoutTripsNestedInput
    driver?: DriverUpdateOneRequiredWithoutTripsNestedInput
    vehicle?: VehicleUpdateOneRequiredWithoutTripsNestedInput
    tripStops?: TripStopUpdateManyWithoutTripNestedInput
  }

  export type TripUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    routeId?: BigIntFieldUpdateOperationsInput | bigint | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startLocation?: BigIntFieldUpdateOperationsInput | bigint | number
    endLocation?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    driverId?: BigIntFieldUpdateOperationsInput | bigint | number
    vehicleId?: BigIntFieldUpdateOperationsInput | bigint | number
    averageSpeed?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxSpeed?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalDistance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalDuration?: NullableIntFieldUpdateOperationsInput | number | null
    idleTime?: NullableIntFieldUpdateOperationsInput | number | null
    path?: NullableStringFieldUpdateOperationsInput | string | null
    tripStops?: TripStopUncheckedUpdateManyWithoutTripNestedInput
  }

  export type TripCreateManyInput = {
    id?: bigint | number
    routeId: bigint | number
    startTime: Date | string
    endTime?: Date | string | null
    startLocation: bigint | number
    endLocation?: bigint | number | null
    driverId: bigint | number
    vehicleId: bigint | number
    averageSpeed?: Decimal | DecimalJsLike | number | string | null
    maxSpeed?: Decimal | DecimalJsLike | number | string | null
    totalDistance?: Decimal | DecimalJsLike | number | string | null
    totalDuration?: number | null
    idleTime?: number | null
    path?: string | null
  }

  export type TripUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startLocation?: BigIntFieldUpdateOperationsInput | bigint | number
    endLocation?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    averageSpeed?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxSpeed?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalDistance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalDuration?: NullableIntFieldUpdateOperationsInput | number | null
    idleTime?: NullableIntFieldUpdateOperationsInput | number | null
    path?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TripUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    routeId?: BigIntFieldUpdateOperationsInput | bigint | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startLocation?: BigIntFieldUpdateOperationsInput | bigint | number
    endLocation?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    driverId?: BigIntFieldUpdateOperationsInput | bigint | number
    vehicleId?: BigIntFieldUpdateOperationsInput | bigint | number
    averageSpeed?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxSpeed?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalDistance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalDuration?: NullableIntFieldUpdateOperationsInput | number | null
    idleTime?: NullableIntFieldUpdateOperationsInput | number | null
    path?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TripStopCreateInput = {
    id?: bigint | number
    stopOrder: number
    arrivalTime?: Date | string | null
    departureTime?: Date | string | null
    eta?: number | null
    trip: TripCreateNestedOneWithoutTripStopsInput
    stop: StopCreateNestedOneWithoutTripStopsInput
  }

  export type TripStopUncheckedCreateInput = {
    id?: bigint | number
    tripId: bigint | number
    stopId: bigint | number
    stopOrder: number
    arrivalTime?: Date | string | null
    departureTime?: Date | string | null
    eta?: number | null
  }

  export type TripStopUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    stopOrder?: IntFieldUpdateOperationsInput | number
    arrivalTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departureTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eta?: NullableIntFieldUpdateOperationsInput | number | null
    trip?: TripUpdateOneRequiredWithoutTripStopsNestedInput
    stop?: StopUpdateOneRequiredWithoutTripStopsNestedInput
  }

  export type TripStopUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tripId?: BigIntFieldUpdateOperationsInput | bigint | number
    stopId?: BigIntFieldUpdateOperationsInput | bigint | number
    stopOrder?: IntFieldUpdateOperationsInput | number
    arrivalTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departureTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eta?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TripStopCreateManyInput = {
    id?: bigint | number
    tripId: bigint | number
    stopId: bigint | number
    stopOrder: number
    arrivalTime?: Date | string | null
    departureTime?: Date | string | null
    eta?: number | null
  }

  export type TripStopUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    stopOrder?: IntFieldUpdateOperationsInput | number
    arrivalTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departureTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eta?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TripStopUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tripId?: BigIntFieldUpdateOperationsInput | bigint | number
    stopId?: BigIntFieldUpdateOperationsInput | bigint | number
    stopOrder?: IntFieldUpdateOperationsInput | number
    arrivalTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departureTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eta?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type VehicleTelemetryCreateInput = {
    id?: bigint | number
    lat: Decimal | DecimalJsLike | number | string
    lon: Decimal | DecimalJsLike | number | string
    speed?: Decimal | DecimalJsLike | number | string | null
    ignition: boolean
    trackedOn?: Date | string
    vehicle: VehicleCreateNestedOneWithoutTelemetryInput
  }

  export type VehicleTelemetryUncheckedCreateInput = {
    id?: bigint | number
    lat: Decimal | DecimalJsLike | number | string
    lon: Decimal | DecimalJsLike | number | string
    speed?: Decimal | DecimalJsLike | number | string | null
    ignition: boolean
    trackedOn?: Date | string
    vehicleId: bigint | number
  }

  export type VehicleTelemetryUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    lat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lon?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    speed?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ignition?: BoolFieldUpdateOperationsInput | boolean
    trackedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicle?: VehicleUpdateOneRequiredWithoutTelemetryNestedInput
  }

  export type VehicleTelemetryUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    lat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lon?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    speed?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ignition?: BoolFieldUpdateOperationsInput | boolean
    trackedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicleId?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type VehicleTelemetryCreateManyInput = {
    id?: bigint | number
    lat: Decimal | DecimalJsLike | number | string
    lon: Decimal | DecimalJsLike | number | string
    speed?: Decimal | DecimalJsLike | number | string | null
    ignition: boolean
    trackedOn?: Date | string
    vehicleId: bigint | number
  }

  export type VehicleTelemetryUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    lat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lon?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    speed?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ignition?: BoolFieldUpdateOperationsInput | boolean
    trackedOn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VehicleTelemetryUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    lat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lon?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    speed?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ignition?: BoolFieldUpdateOperationsInput | boolean
    trackedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicleId?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type VehicleTelemetryHistoryCreateInput = {
    id?: bigint | number
    lat: Decimal | DecimalJsLike | number | string
    lon: Decimal | DecimalJsLike | number | string
    speed?: Decimal | DecimalJsLike | number | string | null
    ignition: boolean
    trackedOn: Date | string
    vehicle: VehicleCreateNestedOneWithoutTelemetryHistoryInput
  }

  export type VehicleTelemetryHistoryUncheckedCreateInput = {
    id?: bigint | number
    lat: Decimal | DecimalJsLike | number | string
    lon: Decimal | DecimalJsLike | number | string
    speed?: Decimal | DecimalJsLike | number | string | null
    ignition: boolean
    trackedOn: Date | string
    vehicleId: bigint | number
  }

  export type VehicleTelemetryHistoryUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    lat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lon?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    speed?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ignition?: BoolFieldUpdateOperationsInput | boolean
    trackedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicle?: VehicleUpdateOneRequiredWithoutTelemetryHistoryNestedInput
  }

  export type VehicleTelemetryHistoryUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    lat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lon?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    speed?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ignition?: BoolFieldUpdateOperationsInput | boolean
    trackedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicleId?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type VehicleTelemetryHistoryCreateManyInput = {
    id?: bigint | number
    lat: Decimal | DecimalJsLike | number | string
    lon: Decimal | DecimalJsLike | number | string
    speed?: Decimal | DecimalJsLike | number | string | null
    ignition: boolean
    trackedOn: Date | string
    vehicleId: bigint | number
  }

  export type VehicleTelemetryHistoryUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    lat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lon?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    speed?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ignition?: BoolFieldUpdateOperationsInput | boolean
    trackedOn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VehicleTelemetryHistoryUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    lat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lon?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    speed?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ignition?: BoolFieldUpdateOperationsInput | boolean
    trackedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicleId?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type ShiftCreateInput = {
    id?: bigint | number
    startTime: Date | string
    endTime: Date | string
    vehicle: VehicleCreateNestedOneWithoutShiftsInput
    driver: DriverCreateNestedOneWithoutShiftsInput
  }

  export type ShiftUncheckedCreateInput = {
    id?: bigint | number
    startTime: Date | string
    endTime: Date | string
    vehicleId: bigint | number
    driverId: bigint | number
  }

  export type ShiftUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicle?: VehicleUpdateOneRequiredWithoutShiftsNestedInput
    driver?: DriverUpdateOneRequiredWithoutShiftsNestedInput
  }

  export type ShiftUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicleId?: BigIntFieldUpdateOperationsInput | bigint | number
    driverId?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type ShiftCreateManyInput = {
    id?: bigint | number
    startTime: Date | string
    endTime: Date | string
    vehicleId: bigint | number
    driverId: bigint | number
  }

  export type ShiftUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicleId?: BigIntFieldUpdateOperationsInput | bigint | number
    driverId?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type ServiceScheduleCreateInput = {
    id?: bigint | number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    dutyTemplates?: DutyTemplateCreateNestedManyWithoutScheduleInput
    vehicleBlockTemplates?: VehicleBlockTemplateCreateNestedManyWithoutScheduleInput
    driverRunTemplates?: DriverRunTemplateCreateNestedManyWithoutScheduleInput
  }

  export type ServiceScheduleUncheckedCreateInput = {
    id?: bigint | number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    dutyTemplates?: DutyTemplateUncheckedCreateNestedManyWithoutScheduleInput
    vehicleBlockTemplates?: VehicleBlockTemplateUncheckedCreateNestedManyWithoutScheduleInput
    driverRunTemplates?: DriverRunTemplateUncheckedCreateNestedManyWithoutScheduleInput
  }

  export type ServiceScheduleUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dutyTemplates?: DutyTemplateUpdateManyWithoutScheduleNestedInput
    vehicleBlockTemplates?: VehicleBlockTemplateUpdateManyWithoutScheduleNestedInput
    driverRunTemplates?: DriverRunTemplateUpdateManyWithoutScheduleNestedInput
  }

  export type ServiceScheduleUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dutyTemplates?: DutyTemplateUncheckedUpdateManyWithoutScheduleNestedInput
    vehicleBlockTemplates?: VehicleBlockTemplateUncheckedUpdateManyWithoutScheduleNestedInput
    driverRunTemplates?: DriverRunTemplateUncheckedUpdateManyWithoutScheduleNestedInput
  }

  export type ServiceScheduleCreateManyInput = {
    id?: bigint | number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceScheduleUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceScheduleUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VehicleBlockTemplateCreateInput = {
    id?: bigint | number
    code: string
    color: string
    schedule: ServiceScheduleCreateNestedOneWithoutVehicleBlockTemplatesInput
    DutyTemplate?: DutyTemplateCreateNestedManyWithoutVehicleBlockTemplateInput
    VehicleBlock?: VehicleBlockCreateNestedManyWithoutVehicleBlockTemplateInput
  }

  export type VehicleBlockTemplateUncheckedCreateInput = {
    id?: bigint | number
    scheduleId: bigint | number
    code: string
    color: string
    DutyTemplate?: DutyTemplateUncheckedCreateNestedManyWithoutVehicleBlockTemplateInput
    VehicleBlock?: VehicleBlockUncheckedCreateNestedManyWithoutVehicleBlockTemplateInput
  }

  export type VehicleBlockTemplateUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    schedule?: ServiceScheduleUpdateOneRequiredWithoutVehicleBlockTemplatesNestedInput
    DutyTemplate?: DutyTemplateUpdateManyWithoutVehicleBlockTemplateNestedInput
    VehicleBlock?: VehicleBlockUpdateManyWithoutVehicleBlockTemplateNestedInput
  }

  export type VehicleBlockTemplateUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    scheduleId?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    DutyTemplate?: DutyTemplateUncheckedUpdateManyWithoutVehicleBlockTemplateNestedInput
    VehicleBlock?: VehicleBlockUncheckedUpdateManyWithoutVehicleBlockTemplateNestedInput
  }

  export type VehicleBlockTemplateCreateManyInput = {
    id?: bigint | number
    scheduleId: bigint | number
    code: string
    color: string
  }

  export type VehicleBlockTemplateUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
  }

  export type VehicleBlockTemplateUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    scheduleId?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
  }

  export type DriverRunTemplateCreateInput = {
    id?: bigint | number
    code: string
    color: string
    schedule: ServiceScheduleCreateNestedOneWithoutDriverRunTemplatesInput
    DutyTemplate?: DutyTemplateCreateNestedManyWithoutDriverRunTemplateInput
    DriverRun?: DriverRunCreateNestedManyWithoutDriverRunTemplateInput
  }

  export type DriverRunTemplateUncheckedCreateInput = {
    id?: bigint | number
    scheduleId: bigint | number
    code: string
    color: string
    DutyTemplate?: DutyTemplateUncheckedCreateNestedManyWithoutDriverRunTemplateInput
    DriverRun?: DriverRunUncheckedCreateNestedManyWithoutDriverRunTemplateInput
  }

  export type DriverRunTemplateUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    schedule?: ServiceScheduleUpdateOneRequiredWithoutDriverRunTemplatesNestedInput
    DutyTemplate?: DutyTemplateUpdateManyWithoutDriverRunTemplateNestedInput
    DriverRun?: DriverRunUpdateManyWithoutDriverRunTemplateNestedInput
  }

  export type DriverRunTemplateUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    scheduleId?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    DutyTemplate?: DutyTemplateUncheckedUpdateManyWithoutDriverRunTemplateNestedInput
    DriverRun?: DriverRunUncheckedUpdateManyWithoutDriverRunTemplateNestedInput
  }

  export type DriverRunTemplateCreateManyInput = {
    id?: bigint | number
    scheduleId: bigint | number
    code: string
    color: string
  }

  export type DriverRunTemplateUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
  }

  export type DriverRunTemplateUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    scheduleId?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
  }

  export type DutyTemplateCreateInput = {
    id?: bigint | number
    name?: string | null
    startTime: Date | string
    endTime: Date | string
    dutyType: $Enums.DutyType
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicleBlockTemplate?: VehicleBlockTemplateCreateNestedOneWithoutDutyTemplateInput
    driverRunTemplate?: DriverRunTemplateCreateNestedOneWithoutDutyTemplateInput
    schedule: ServiceScheduleCreateNestedOneWithoutDutyTemplatesInput
  }

  export type DutyTemplateUncheckedCreateInput = {
    id?: bigint | number
    name?: string | null
    startTime: Date | string
    endTime: Date | string
    dutyType: $Enums.DutyType
    vehicleBlockTemplateId?: bigint | number | null
    driverRunTemplateId?: bigint | number | null
    scheduleId: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DutyTemplateUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    dutyType?: EnumDutyTypeFieldUpdateOperationsInput | $Enums.DutyType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicleBlockTemplate?: VehicleBlockTemplateUpdateOneWithoutDutyTemplateNestedInput
    driverRunTemplate?: DriverRunTemplateUpdateOneWithoutDutyTemplateNestedInput
    schedule?: ServiceScheduleUpdateOneRequiredWithoutDutyTemplatesNestedInput
  }

  export type DutyTemplateUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    dutyType?: EnumDutyTypeFieldUpdateOperationsInput | $Enums.DutyType
    vehicleBlockTemplateId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    driverRunTemplateId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    scheduleId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DutyTemplateCreateManyInput = {
    id?: bigint | number
    name?: string | null
    startTime: Date | string
    endTime: Date | string
    dutyType: $Enums.DutyType
    vehicleBlockTemplateId?: bigint | number | null
    driverRunTemplateId?: bigint | number | null
    scheduleId: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DutyTemplateUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    dutyType?: EnumDutyTypeFieldUpdateOperationsInput | $Enums.DutyType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DutyTemplateUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    dutyType?: EnumDutyTypeFieldUpdateOperationsInput | $Enums.DutyType
    vehicleBlockTemplateId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    driverRunTemplateId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    scheduleId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VehicleBlockCreateInput = {
    id?: bigint | number
    code: string
    vehicleBlockTemplate: VehicleBlockTemplateCreateNestedOneWithoutVehicleBlockInput
    Duty?: DutyCreateNestedManyWithoutBlockInput
  }

  export type VehicleBlockUncheckedCreateInput = {
    id?: bigint | number
    vehicleBlockTemplateId: bigint | number
    code: string
    Duty?: DutyUncheckedCreateNestedManyWithoutBlockInput
  }

  export type VehicleBlockUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    vehicleBlockTemplate?: VehicleBlockTemplateUpdateOneRequiredWithoutVehicleBlockNestedInput
    Duty?: DutyUpdateManyWithoutBlockNestedInput
  }

  export type VehicleBlockUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    vehicleBlockTemplateId?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    Duty?: DutyUncheckedUpdateManyWithoutBlockNestedInput
  }

  export type VehicleBlockCreateManyInput = {
    id?: bigint | number
    vehicleBlockTemplateId: bigint | number
    code: string
  }

  export type VehicleBlockUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
  }

  export type VehicleBlockUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    vehicleBlockTemplateId?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
  }

  export type DriverRunCreateInput = {
    id?: bigint | number
    code: string
    driverRunTemplate: DriverRunTemplateCreateNestedOneWithoutDriverRunInput
    Duty?: DutyCreateNestedManyWithoutRunInput
  }

  export type DriverRunUncheckedCreateInput = {
    id?: bigint | number
    driverRunTemplateId: bigint | number
    code: string
    Duty?: DutyUncheckedCreateNestedManyWithoutRunInput
  }

  export type DriverRunUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    driverRunTemplate?: DriverRunTemplateUpdateOneRequiredWithoutDriverRunNestedInput
    Duty?: DutyUpdateManyWithoutRunNestedInput
  }

  export type DriverRunUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    driverRunTemplateId?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    Duty?: DutyUncheckedUpdateManyWithoutRunNestedInput
  }

  export type DriverRunCreateManyInput = {
    id?: bigint | number
    driverRunTemplateId: bigint | number
    code: string
  }

  export type DriverRunUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
  }

  export type DriverRunUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    driverRunTemplateId?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
  }

  export type DutyCreateInput = {
    id?: bigint | number
    date: Date | string
    startTime: Date | string
    endTime: Date | string
    dutyTemplateId?: bigint | number | null
    dutyType: $Enums.DutyType
    block?: VehicleBlockCreateNestedOneWithoutDutyInput
    run?: DriverRunCreateNestedOneWithoutDutyInput
    driver?: DriverCreateNestedOneWithoutDutyInput
    vehicle?: VehicleCreateNestedOneWithoutDutyInput
    tripDuties?: TripDutyCreateNestedManyWithoutDutyInput
    washingDuties?: WashingDutyCreateNestedManyWithoutDutyInput
    maintenanceDuties?: MaintenanceDutyCreateNestedManyWithoutDutyInput
  }

  export type DutyUncheckedCreateInput = {
    id?: bigint | number
    date: Date | string
    startTime: Date | string
    endTime: Date | string
    driverId?: bigint | number | null
    vehicleId?: bigint | number | null
    dutyTemplateId?: bigint | number | null
    blockId?: bigint | number | null
    runId?: bigint | number | null
    dutyType: $Enums.DutyType
    tripDuties?: TripDutyUncheckedCreateNestedManyWithoutDutyInput
    washingDuties?: WashingDutyUncheckedCreateNestedManyWithoutDutyInput
    maintenanceDuties?: MaintenanceDutyUncheckedCreateNestedManyWithoutDutyInput
  }

  export type DutyUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    dutyTemplateId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    dutyType?: EnumDutyTypeFieldUpdateOperationsInput | $Enums.DutyType
    block?: VehicleBlockUpdateOneWithoutDutyNestedInput
    run?: DriverRunUpdateOneWithoutDutyNestedInput
    driver?: DriverUpdateOneWithoutDutyNestedInput
    vehicle?: VehicleUpdateOneWithoutDutyNestedInput
    tripDuties?: TripDutyUpdateManyWithoutDutyNestedInput
    washingDuties?: WashingDutyUpdateManyWithoutDutyNestedInput
    maintenanceDuties?: MaintenanceDutyUpdateManyWithoutDutyNestedInput
  }

  export type DutyUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    driverId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    vehicleId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    dutyTemplateId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    blockId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    runId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    dutyType?: EnumDutyTypeFieldUpdateOperationsInput | $Enums.DutyType
    tripDuties?: TripDutyUncheckedUpdateManyWithoutDutyNestedInput
    washingDuties?: WashingDutyUncheckedUpdateManyWithoutDutyNestedInput
    maintenanceDuties?: MaintenanceDutyUncheckedUpdateManyWithoutDutyNestedInput
  }

  export type DutyCreateManyInput = {
    id?: bigint | number
    date: Date | string
    startTime: Date | string
    endTime: Date | string
    driverId?: bigint | number | null
    vehicleId?: bigint | number | null
    dutyTemplateId?: bigint | number | null
    blockId?: bigint | number | null
    runId?: bigint | number | null
    dutyType: $Enums.DutyType
  }

  export type DutyUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    dutyTemplateId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    dutyType?: EnumDutyTypeFieldUpdateOperationsInput | $Enums.DutyType
  }

  export type DutyUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    driverId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    vehicleId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    dutyTemplateId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    blockId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    runId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    dutyType?: EnumDutyTypeFieldUpdateOperationsInput | $Enums.DutyType
  }

  export type TripDutyCreateInput = {
    id?: bigint | number
    duty: DutyCreateNestedOneWithoutTripDutiesInput
    route: RouteCreateNestedOneWithoutTripDutyInput
  }

  export type TripDutyUncheckedCreateInput = {
    id?: bigint | number
    dutyId: bigint | number
    routeId: bigint | number
  }

  export type TripDutyUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    duty?: DutyUpdateOneRequiredWithoutTripDutiesNestedInput
    route?: RouteUpdateOneRequiredWithoutTripDutyNestedInput
  }

  export type TripDutyUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    dutyId?: BigIntFieldUpdateOperationsInput | bigint | number
    routeId?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type TripDutyCreateManyInput = {
    id?: bigint | number
    dutyId: bigint | number
    routeId: bigint | number
  }

  export type TripDutyUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type TripDutyUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    dutyId?: BigIntFieldUpdateOperationsInput | bigint | number
    routeId?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type WashingDutyCreateInput = {
    id?: bigint | number
    duty: DutyCreateNestedOneWithoutWashingDutiesInput
  }

  export type WashingDutyUncheckedCreateInput = {
    id?: bigint | number
    dutyId: bigint | number
  }

  export type WashingDutyUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    duty?: DutyUpdateOneRequiredWithoutWashingDutiesNestedInput
  }

  export type WashingDutyUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    dutyId?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type WashingDutyCreateManyInput = {
    id?: bigint | number
    dutyId: bigint | number
  }

  export type WashingDutyUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type WashingDutyUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    dutyId?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type MaintenanceDutyCreateInput = {
    id?: bigint | number
    duty: DutyCreateNestedOneWithoutMaintenanceDutiesInput
  }

  export type MaintenanceDutyUncheckedCreateInput = {
    id?: bigint | number
    dutyId: bigint | number
  }

  export type MaintenanceDutyUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    duty?: DutyUpdateOneRequiredWithoutMaintenanceDutiesNestedInput
  }

  export type MaintenanceDutyUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    dutyId?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type MaintenanceDutyCreateManyInput = {
    id?: bigint | number
    dutyId: bigint | number
  }

  export type MaintenanceDutyUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type MaintenanceDutyUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    dutyId?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type UserAuthCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userType?: SortOrder
    provider?: SortOrder
    identifier?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAuthAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type UserAuthMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userType?: SortOrder
    provider?: SortOrder
    identifier?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAuthMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userType?: SortOrder
    provider?: SortOrder
    identifier?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAuthSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type UserActivationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    activationCode?: SortOrder
    expiresAt?: SortOrder
    isUsed?: SortOrder
    createdAt?: SortOrder
  }

  export type UserActivationAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type UserActivationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    activationCode?: SortOrder
    expiresAt?: SortOrder
    isUsed?: SortOrder
    createdAt?: SortOrder
  }

  export type UserActivationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    activationCode?: SortOrder
    expiresAt?: SortOrder
    isUsed?: SortOrder
    createdAt?: SortOrder
  }

  export type UserActivationSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type UserRoleListRelationFilter = {
    every?: UserRoleWhereInput
    some?: UserRoleWhereInput
    none?: UserRoleWhereInput
  }

  export type UserActivationListRelationFilter = {
    every?: UserActivationWhereInput
    some?: UserActivationWhereInput
    none?: UserActivationWhereInput
  }

  export type UserAuthListRelationFilter = {
    every?: UserAuthWhereInput
    some?: UserAuthWhereInput
    none?: UserAuthWhereInput
  }

  export type DriverListRelationFilter = {
    every?: DriverWhereInput
    some?: DriverWhereInput
    none?: DriverWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserRoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserActivationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserAuthOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DriverOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserPhoneUserTypeCompoundUniqueInput = {
    phone: string
    userType: number
  }

  export type UserEmailUserTypeCompoundUniqueInput = {
    email: string
    userType: number
  }

  export type UserQidUserTypeCompoundUniqueInput = {
    qid: string
    userType: number
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    qid?: SortOrder
    userType?: SortOrder
    isActive?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    userType?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    qid?: SortOrder
    userType?: SortOrder
    isActive?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    qid?: SortOrder
    userType?: SortOrder
    isActive?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    userType?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type RoleAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type RoleSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RoleRelationFilter = {
    is?: RoleWhereInput
    isNot?: RoleWhereInput
  }

  export type UserRoleCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
  }

  export type UserRoleAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
  }

  export type UserRoleMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
  }

  export type UserRoleMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
  }

  export type UserRoleSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type TripListRelationFilter = {
    every?: TripWhereInput
    some?: TripWhereInput
    none?: TripWhereInput
  }

  export type ShiftListRelationFilter = {
    every?: ShiftWhereInput
    some?: ShiftWhereInput
    none?: ShiftWhereInput
  }

  export type DutyListRelationFilter = {
    every?: DutyWhereInput
    some?: DutyWhereInput
    none?: DutyWhereInput
  }

  export type TripOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShiftOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DutyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DriverCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    licenseExpiry?: SortOrder
  }

  export type DriverAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type DriverMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    licenseExpiry?: SortOrder
  }

  export type DriverMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    licenseExpiry?: SortOrder
  }

  export type DriverSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type VehicleListRelationFilter = {
    every?: VehicleWhereInput
    some?: VehicleWhereInput
    none?: VehicleWhereInput
  }

  export type VehicleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VehicleModelCountOrderByAggregateInput = {
    id?: SortOrder
    make?: SortOrder
    year?: SortOrder
    manufacturer?: SortOrder
    capacity?: SortOrder
  }

  export type VehicleModelAvgOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    capacity?: SortOrder
  }

  export type VehicleModelMaxOrderByAggregateInput = {
    id?: SortOrder
    make?: SortOrder
    year?: SortOrder
    manufacturer?: SortOrder
    capacity?: SortOrder
  }

  export type VehicleModelMinOrderByAggregateInput = {
    id?: SortOrder
    make?: SortOrder
    year?: SortOrder
    manufacturer?: SortOrder
    capacity?: SortOrder
  }

  export type VehicleModelSumOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    capacity?: SortOrder
  }

  export type VehicleModelRelationFilter = {
    is?: VehicleModelWhereInput
    isNot?: VehicleModelWhereInput
  }

  export type VehicleTelemetryListRelationFilter = {
    every?: VehicleTelemetryWhereInput
    some?: VehicleTelemetryWhereInput
    none?: VehicleTelemetryWhereInput
  }

  export type VehicleTelemetryHistoryListRelationFilter = {
    every?: VehicleTelemetryHistoryWhereInput
    some?: VehicleTelemetryHistoryWhereInput
    none?: VehicleTelemetryHistoryWhereInput
  }

  export type VehicleTelemetryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VehicleTelemetryHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VehicleCountOrderByAggregateInput = {
    id?: SortOrder
    plateNo?: SortOrder
    fleetNo?: SortOrder
    modelId?: SortOrder
  }

  export type VehicleAvgOrderByAggregateInput = {
    id?: SortOrder
    modelId?: SortOrder
  }

  export type VehicleMaxOrderByAggregateInput = {
    id?: SortOrder
    plateNo?: SortOrder
    fleetNo?: SortOrder
    modelId?: SortOrder
  }

  export type VehicleMinOrderByAggregateInput = {
    id?: SortOrder
    plateNo?: SortOrder
    fleetNo?: SortOrder
    modelId?: SortOrder
  }

  export type VehicleSumOrderByAggregateInput = {
    id?: SortOrder
    modelId?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type StopListRelationFilter = {
    every?: StopWhereInput
    some?: StopWhereInput
    none?: StopWhereInput
  }

  export type StopOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LocationCountOrderByAggregateInput = {
    id?: SortOrder
    lat?: SortOrder
    lon?: SortOrder
  }

  export type LocationAvgOrderByAggregateInput = {
    id?: SortOrder
    lat?: SortOrder
    lon?: SortOrder
  }

  export type LocationMaxOrderByAggregateInput = {
    id?: SortOrder
    lat?: SortOrder
    lon?: SortOrder
  }

  export type LocationMinOrderByAggregateInput = {
    id?: SortOrder
    lat?: SortOrder
    lon?: SortOrder
  }

  export type LocationSumOrderByAggregateInput = {
    id?: SortOrder
    lat?: SortOrder
    lon?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type LocationRelationFilter = {
    is?: LocationWhereInput
    isNot?: LocationWhereInput
  }

  export type RouteStopListRelationFilter = {
    every?: RouteStopWhereInput
    some?: RouteStopWhereInput
    none?: RouteStopWhereInput
  }

  export type TripStopListRelationFilter = {
    every?: TripStopWhereInput
    some?: TripStopWhereInput
    none?: TripStopWhereInput
  }

  export type RouteStopOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TripStopOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StopCountOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    name?: SortOrder
    code?: SortOrder
  }

  export type StopAvgOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
  }

  export type StopMaxOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    name?: SortOrder
    code?: SortOrder
  }

  export type StopMinOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    name?: SortOrder
    code?: SortOrder
  }

  export type StopSumOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
  }

  export type TripDutyListRelationFilter = {
    every?: TripDutyWhereInput
    some?: TripDutyWhereInput
    none?: TripDutyWhereInput
  }

  export type TripDutyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RouteCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    isActive?: SortOrder
    totalEstimatedDuration?: SortOrder
  }

  export type RouteAvgOrderByAggregateInput = {
    id?: SortOrder
    totalEstimatedDuration?: SortOrder
  }

  export type RouteMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    isActive?: SortOrder
    totalEstimatedDuration?: SortOrder
  }

  export type RouteMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    isActive?: SortOrder
    totalEstimatedDuration?: SortOrder
  }

  export type RouteSumOrderByAggregateInput = {
    id?: SortOrder
    totalEstimatedDuration?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type RouteRelationFilter = {
    is?: RouteWhereInput
    isNot?: RouteWhereInput
  }

  export type StopRelationFilter = {
    is?: StopWhereInput
    isNot?: StopWhereInput
  }

  export type RouteStopCountOrderByAggregateInput = {
    id?: SortOrder
    routeId?: SortOrder
    stopId?: SortOrder
    stopOrder?: SortOrder
    isActive?: SortOrder
    path?: SortOrder
    eta?: SortOrder
    waitTime?: SortOrder
  }

  export type RouteStopAvgOrderByAggregateInput = {
    id?: SortOrder
    routeId?: SortOrder
    stopId?: SortOrder
    stopOrder?: SortOrder
    eta?: SortOrder
    waitTime?: SortOrder
  }

  export type RouteStopMaxOrderByAggregateInput = {
    id?: SortOrder
    routeId?: SortOrder
    stopId?: SortOrder
    stopOrder?: SortOrder
    isActive?: SortOrder
    path?: SortOrder
    eta?: SortOrder
    waitTime?: SortOrder
  }

  export type RouteStopMinOrderByAggregateInput = {
    id?: SortOrder
    routeId?: SortOrder
    stopId?: SortOrder
    stopOrder?: SortOrder
    isActive?: SortOrder
    path?: SortOrder
    eta?: SortOrder
    waitTime?: SortOrder
  }

  export type RouteStopSumOrderByAggregateInput = {
    id?: SortOrder
    routeId?: SortOrder
    stopId?: SortOrder
    stopOrder?: SortOrder
    eta?: SortOrder
    waitTime?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type DriverRelationFilter = {
    is?: DriverWhereInput
    isNot?: DriverWhereInput
  }

  export type VehicleRelationFilter = {
    is?: VehicleWhereInput
    isNot?: VehicleWhereInput
  }

  export type TripCountOrderByAggregateInput = {
    id?: SortOrder
    routeId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    startLocation?: SortOrder
    endLocation?: SortOrder
    driverId?: SortOrder
    vehicleId?: SortOrder
    averageSpeed?: SortOrder
    maxSpeed?: SortOrder
    totalDistance?: SortOrder
    totalDuration?: SortOrder
    idleTime?: SortOrder
    path?: SortOrder
  }

  export type TripAvgOrderByAggregateInput = {
    id?: SortOrder
    routeId?: SortOrder
    startLocation?: SortOrder
    endLocation?: SortOrder
    driverId?: SortOrder
    vehicleId?: SortOrder
    averageSpeed?: SortOrder
    maxSpeed?: SortOrder
    totalDistance?: SortOrder
    totalDuration?: SortOrder
    idleTime?: SortOrder
  }

  export type TripMaxOrderByAggregateInput = {
    id?: SortOrder
    routeId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    startLocation?: SortOrder
    endLocation?: SortOrder
    driverId?: SortOrder
    vehicleId?: SortOrder
    averageSpeed?: SortOrder
    maxSpeed?: SortOrder
    totalDistance?: SortOrder
    totalDuration?: SortOrder
    idleTime?: SortOrder
    path?: SortOrder
  }

  export type TripMinOrderByAggregateInput = {
    id?: SortOrder
    routeId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    startLocation?: SortOrder
    endLocation?: SortOrder
    driverId?: SortOrder
    vehicleId?: SortOrder
    averageSpeed?: SortOrder
    maxSpeed?: SortOrder
    totalDistance?: SortOrder
    totalDuration?: SortOrder
    idleTime?: SortOrder
    path?: SortOrder
  }

  export type TripSumOrderByAggregateInput = {
    id?: SortOrder
    routeId?: SortOrder
    startLocation?: SortOrder
    endLocation?: SortOrder
    driverId?: SortOrder
    vehicleId?: SortOrder
    averageSpeed?: SortOrder
    maxSpeed?: SortOrder
    totalDistance?: SortOrder
    totalDuration?: SortOrder
    idleTime?: SortOrder
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type TripRelationFilter = {
    is?: TripWhereInput
    isNot?: TripWhereInput
  }

  export type TripStopCountOrderByAggregateInput = {
    id?: SortOrder
    tripId?: SortOrder
    stopId?: SortOrder
    stopOrder?: SortOrder
    arrivalTime?: SortOrder
    departureTime?: SortOrder
    eta?: SortOrder
  }

  export type TripStopAvgOrderByAggregateInput = {
    id?: SortOrder
    tripId?: SortOrder
    stopId?: SortOrder
    stopOrder?: SortOrder
    eta?: SortOrder
  }

  export type TripStopMaxOrderByAggregateInput = {
    id?: SortOrder
    tripId?: SortOrder
    stopId?: SortOrder
    stopOrder?: SortOrder
    arrivalTime?: SortOrder
    departureTime?: SortOrder
    eta?: SortOrder
  }

  export type TripStopMinOrderByAggregateInput = {
    id?: SortOrder
    tripId?: SortOrder
    stopId?: SortOrder
    stopOrder?: SortOrder
    arrivalTime?: SortOrder
    departureTime?: SortOrder
    eta?: SortOrder
  }

  export type TripStopSumOrderByAggregateInput = {
    id?: SortOrder
    tripId?: SortOrder
    stopId?: SortOrder
    stopOrder?: SortOrder
    eta?: SortOrder
  }

  export type VehicleTelemetryCountOrderByAggregateInput = {
    id?: SortOrder
    lat?: SortOrder
    lon?: SortOrder
    speed?: SortOrder
    ignition?: SortOrder
    trackedOn?: SortOrder
    vehicleId?: SortOrder
  }

  export type VehicleTelemetryAvgOrderByAggregateInput = {
    id?: SortOrder
    lat?: SortOrder
    lon?: SortOrder
    speed?: SortOrder
    vehicleId?: SortOrder
  }

  export type VehicleTelemetryMaxOrderByAggregateInput = {
    id?: SortOrder
    lat?: SortOrder
    lon?: SortOrder
    speed?: SortOrder
    ignition?: SortOrder
    trackedOn?: SortOrder
    vehicleId?: SortOrder
  }

  export type VehicleTelemetryMinOrderByAggregateInput = {
    id?: SortOrder
    lat?: SortOrder
    lon?: SortOrder
    speed?: SortOrder
    ignition?: SortOrder
    trackedOn?: SortOrder
    vehicleId?: SortOrder
  }

  export type VehicleTelemetrySumOrderByAggregateInput = {
    id?: SortOrder
    lat?: SortOrder
    lon?: SortOrder
    speed?: SortOrder
    vehicleId?: SortOrder
  }

  export type VehicleTelemetryHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    lat?: SortOrder
    lon?: SortOrder
    speed?: SortOrder
    ignition?: SortOrder
    trackedOn?: SortOrder
    vehicleId?: SortOrder
  }

  export type VehicleTelemetryHistoryAvgOrderByAggregateInput = {
    id?: SortOrder
    lat?: SortOrder
    lon?: SortOrder
    speed?: SortOrder
    vehicleId?: SortOrder
  }

  export type VehicleTelemetryHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    lat?: SortOrder
    lon?: SortOrder
    speed?: SortOrder
    ignition?: SortOrder
    trackedOn?: SortOrder
    vehicleId?: SortOrder
  }

  export type VehicleTelemetryHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    lat?: SortOrder
    lon?: SortOrder
    speed?: SortOrder
    ignition?: SortOrder
    trackedOn?: SortOrder
    vehicleId?: SortOrder
  }

  export type VehicleTelemetryHistorySumOrderByAggregateInput = {
    id?: SortOrder
    lat?: SortOrder
    lon?: SortOrder
    speed?: SortOrder
    vehicleId?: SortOrder
  }

  export type ShiftCountOrderByAggregateInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    vehicleId?: SortOrder
    driverId?: SortOrder
  }

  export type ShiftAvgOrderByAggregateInput = {
    id?: SortOrder
    vehicleId?: SortOrder
    driverId?: SortOrder
  }

  export type ShiftMaxOrderByAggregateInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    vehicleId?: SortOrder
    driverId?: SortOrder
  }

  export type ShiftMinOrderByAggregateInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    vehicleId?: SortOrder
    driverId?: SortOrder
  }

  export type ShiftSumOrderByAggregateInput = {
    id?: SortOrder
    vehicleId?: SortOrder
    driverId?: SortOrder
  }

  export type DutyTemplateListRelationFilter = {
    every?: DutyTemplateWhereInput
    some?: DutyTemplateWhereInput
    none?: DutyTemplateWhereInput
  }

  export type VehicleBlockTemplateListRelationFilter = {
    every?: VehicleBlockTemplateWhereInput
    some?: VehicleBlockTemplateWhereInput
    none?: VehicleBlockTemplateWhereInput
  }

  export type DriverRunTemplateListRelationFilter = {
    every?: DriverRunTemplateWhereInput
    some?: DriverRunTemplateWhereInput
    none?: DriverRunTemplateWhereInput
  }

  export type DutyTemplateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VehicleBlockTemplateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DriverRunTemplateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceScheduleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceScheduleAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ServiceScheduleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceScheduleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceScheduleSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ServiceScheduleRelationFilter = {
    is?: ServiceScheduleWhereInput
    isNot?: ServiceScheduleWhereInput
  }

  export type VehicleBlockListRelationFilter = {
    every?: VehicleBlockWhereInput
    some?: VehicleBlockWhereInput
    none?: VehicleBlockWhereInput
  }

  export type VehicleBlockOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VehicleBlockTemplateScheduleIdCodeCompoundUniqueInput = {
    scheduleId: bigint | number
    code: string
  }

  export type VehicleBlockTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    scheduleId?: SortOrder
    code?: SortOrder
    color?: SortOrder
  }

  export type VehicleBlockTemplateAvgOrderByAggregateInput = {
    id?: SortOrder
    scheduleId?: SortOrder
  }

  export type VehicleBlockTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    scheduleId?: SortOrder
    code?: SortOrder
    color?: SortOrder
  }

  export type VehicleBlockTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    scheduleId?: SortOrder
    code?: SortOrder
    color?: SortOrder
  }

  export type VehicleBlockTemplateSumOrderByAggregateInput = {
    id?: SortOrder
    scheduleId?: SortOrder
  }

  export type DriverRunListRelationFilter = {
    every?: DriverRunWhereInput
    some?: DriverRunWhereInput
    none?: DriverRunWhereInput
  }

  export type DriverRunOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DriverRunTemplateScheduleIdCodeCompoundUniqueInput = {
    scheduleId: bigint | number
    code: string
  }

  export type DriverRunTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    scheduleId?: SortOrder
    code?: SortOrder
    color?: SortOrder
  }

  export type DriverRunTemplateAvgOrderByAggregateInput = {
    id?: SortOrder
    scheduleId?: SortOrder
  }

  export type DriverRunTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    scheduleId?: SortOrder
    code?: SortOrder
    color?: SortOrder
  }

  export type DriverRunTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    scheduleId?: SortOrder
    code?: SortOrder
    color?: SortOrder
  }

  export type DriverRunTemplateSumOrderByAggregateInput = {
    id?: SortOrder
    scheduleId?: SortOrder
  }

  export type EnumDutyTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DutyType | EnumDutyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DutyType[] | ListEnumDutyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DutyType[] | ListEnumDutyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDutyTypeFilter<$PrismaModel> | $Enums.DutyType
  }

  export type VehicleBlockTemplateNullableRelationFilter = {
    is?: VehicleBlockTemplateWhereInput | null
    isNot?: VehicleBlockTemplateWhereInput | null
  }

  export type DriverRunTemplateNullableRelationFilter = {
    is?: DriverRunTemplateWhereInput | null
    isNot?: DriverRunTemplateWhereInput | null
  }

  export type DutyTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    dutyType?: SortOrder
    vehicleBlockTemplateId?: SortOrder
    driverRunTemplateId?: SortOrder
    scheduleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DutyTemplateAvgOrderByAggregateInput = {
    id?: SortOrder
    vehicleBlockTemplateId?: SortOrder
    driverRunTemplateId?: SortOrder
    scheduleId?: SortOrder
  }

  export type DutyTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    dutyType?: SortOrder
    vehicleBlockTemplateId?: SortOrder
    driverRunTemplateId?: SortOrder
    scheduleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DutyTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    dutyType?: SortOrder
    vehicleBlockTemplateId?: SortOrder
    driverRunTemplateId?: SortOrder
    scheduleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DutyTemplateSumOrderByAggregateInput = {
    id?: SortOrder
    vehicleBlockTemplateId?: SortOrder
    driverRunTemplateId?: SortOrder
    scheduleId?: SortOrder
  }

  export type EnumDutyTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DutyType | EnumDutyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DutyType[] | ListEnumDutyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DutyType[] | ListEnumDutyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDutyTypeWithAggregatesFilter<$PrismaModel> | $Enums.DutyType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDutyTypeFilter<$PrismaModel>
    _max?: NestedEnumDutyTypeFilter<$PrismaModel>
  }

  export type VehicleBlockTemplateRelationFilter = {
    is?: VehicleBlockTemplateWhereInput
    isNot?: VehicleBlockTemplateWhereInput
  }

  export type VehicleBlockCountOrderByAggregateInput = {
    id?: SortOrder
    vehicleBlockTemplateId?: SortOrder
    code?: SortOrder
  }

  export type VehicleBlockAvgOrderByAggregateInput = {
    id?: SortOrder
    vehicleBlockTemplateId?: SortOrder
  }

  export type VehicleBlockMaxOrderByAggregateInput = {
    id?: SortOrder
    vehicleBlockTemplateId?: SortOrder
    code?: SortOrder
  }

  export type VehicleBlockMinOrderByAggregateInput = {
    id?: SortOrder
    vehicleBlockTemplateId?: SortOrder
    code?: SortOrder
  }

  export type VehicleBlockSumOrderByAggregateInput = {
    id?: SortOrder
    vehicleBlockTemplateId?: SortOrder
  }

  export type DriverRunTemplateRelationFilter = {
    is?: DriverRunTemplateWhereInput
    isNot?: DriverRunTemplateWhereInput
  }

  export type DriverRunCountOrderByAggregateInput = {
    id?: SortOrder
    driverRunTemplateId?: SortOrder
    code?: SortOrder
  }

  export type DriverRunAvgOrderByAggregateInput = {
    id?: SortOrder
    driverRunTemplateId?: SortOrder
  }

  export type DriverRunMaxOrderByAggregateInput = {
    id?: SortOrder
    driverRunTemplateId?: SortOrder
    code?: SortOrder
  }

  export type DriverRunMinOrderByAggregateInput = {
    id?: SortOrder
    driverRunTemplateId?: SortOrder
    code?: SortOrder
  }

  export type DriverRunSumOrderByAggregateInput = {
    id?: SortOrder
    driverRunTemplateId?: SortOrder
  }

  export type VehicleBlockNullableRelationFilter = {
    is?: VehicleBlockWhereInput | null
    isNot?: VehicleBlockWhereInput | null
  }

  export type DriverRunNullableRelationFilter = {
    is?: DriverRunWhereInput | null
    isNot?: DriverRunWhereInput | null
  }

  export type DriverNullableRelationFilter = {
    is?: DriverWhereInput | null
    isNot?: DriverWhereInput | null
  }

  export type VehicleNullableRelationFilter = {
    is?: VehicleWhereInput | null
    isNot?: VehicleWhereInput | null
  }

  export type WashingDutyListRelationFilter = {
    every?: WashingDutyWhereInput
    some?: WashingDutyWhereInput
    none?: WashingDutyWhereInput
  }

  export type MaintenanceDutyListRelationFilter = {
    every?: MaintenanceDutyWhereInput
    some?: MaintenanceDutyWhereInput
    none?: MaintenanceDutyWhereInput
  }

  export type WashingDutyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MaintenanceDutyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DutyCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    driverId?: SortOrder
    vehicleId?: SortOrder
    dutyTemplateId?: SortOrder
    blockId?: SortOrder
    runId?: SortOrder
    dutyType?: SortOrder
  }

  export type DutyAvgOrderByAggregateInput = {
    id?: SortOrder
    driverId?: SortOrder
    vehicleId?: SortOrder
    dutyTemplateId?: SortOrder
    blockId?: SortOrder
    runId?: SortOrder
  }

  export type DutyMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    driverId?: SortOrder
    vehicleId?: SortOrder
    dutyTemplateId?: SortOrder
    blockId?: SortOrder
    runId?: SortOrder
    dutyType?: SortOrder
  }

  export type DutyMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    driverId?: SortOrder
    vehicleId?: SortOrder
    dutyTemplateId?: SortOrder
    blockId?: SortOrder
    runId?: SortOrder
    dutyType?: SortOrder
  }

  export type DutySumOrderByAggregateInput = {
    id?: SortOrder
    driverId?: SortOrder
    vehicleId?: SortOrder
    dutyTemplateId?: SortOrder
    blockId?: SortOrder
    runId?: SortOrder
  }

  export type DutyRelationFilter = {
    is?: DutyWhereInput
    isNot?: DutyWhereInput
  }

  export type TripDutyCountOrderByAggregateInput = {
    id?: SortOrder
    dutyId?: SortOrder
    routeId?: SortOrder
  }

  export type TripDutyAvgOrderByAggregateInput = {
    id?: SortOrder
    dutyId?: SortOrder
    routeId?: SortOrder
  }

  export type TripDutyMaxOrderByAggregateInput = {
    id?: SortOrder
    dutyId?: SortOrder
    routeId?: SortOrder
  }

  export type TripDutyMinOrderByAggregateInput = {
    id?: SortOrder
    dutyId?: SortOrder
    routeId?: SortOrder
  }

  export type TripDutySumOrderByAggregateInput = {
    id?: SortOrder
    dutyId?: SortOrder
    routeId?: SortOrder
  }

  export type WashingDutyCountOrderByAggregateInput = {
    id?: SortOrder
    dutyId?: SortOrder
  }

  export type WashingDutyAvgOrderByAggregateInput = {
    id?: SortOrder
    dutyId?: SortOrder
  }

  export type WashingDutyMaxOrderByAggregateInput = {
    id?: SortOrder
    dutyId?: SortOrder
  }

  export type WashingDutyMinOrderByAggregateInput = {
    id?: SortOrder
    dutyId?: SortOrder
  }

  export type WashingDutySumOrderByAggregateInput = {
    id?: SortOrder
    dutyId?: SortOrder
  }

  export type MaintenanceDutyCountOrderByAggregateInput = {
    id?: SortOrder
    dutyId?: SortOrder
  }

  export type MaintenanceDutyAvgOrderByAggregateInput = {
    id?: SortOrder
    dutyId?: SortOrder
  }

  export type MaintenanceDutyMaxOrderByAggregateInput = {
    id?: SortOrder
    dutyId?: SortOrder
  }

  export type MaintenanceDutyMinOrderByAggregateInput = {
    id?: SortOrder
    dutyId?: SortOrder
  }

  export type MaintenanceDutySumOrderByAggregateInput = {
    id?: SortOrder
    dutyId?: SortOrder
  }

  export type UserCreateNestedOneWithoutUserAuthsInput = {
    create?: XOR<UserCreateWithoutUserAuthsInput, UserUncheckedCreateWithoutUserAuthsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserAuthsInput
    connect?: UserWhereUniqueInput
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateOneRequiredWithoutUserAuthsNestedInput = {
    create?: XOR<UserCreateWithoutUserAuthsInput, UserUncheckedCreateWithoutUserAuthsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserAuthsInput
    upsert?: UserUpsertWithoutUserAuthsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserAuthsInput, UserUpdateWithoutUserAuthsInput>, UserUncheckedUpdateWithoutUserAuthsInput>
  }

  export type UserCreateNestedOneWithoutUserActivationsInput = {
    create?: XOR<UserCreateWithoutUserActivationsInput, UserUncheckedCreateWithoutUserActivationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserActivationsInput
    connect?: UserWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateOneRequiredWithoutUserActivationsNestedInput = {
    create?: XOR<UserCreateWithoutUserActivationsInput, UserUncheckedCreateWithoutUserActivationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserActivationsInput
    upsert?: UserUpsertWithoutUserActivationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserActivationsInput, UserUpdateWithoutUserActivationsInput>, UserUncheckedUpdateWithoutUserActivationsInput>
  }

  export type UserRoleCreateNestedManyWithoutUserInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type UserActivationCreateNestedManyWithoutUserInput = {
    create?: XOR<UserActivationCreateWithoutUserInput, UserActivationUncheckedCreateWithoutUserInput> | UserActivationCreateWithoutUserInput[] | UserActivationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserActivationCreateOrConnectWithoutUserInput | UserActivationCreateOrConnectWithoutUserInput[]
    createMany?: UserActivationCreateManyUserInputEnvelope
    connect?: UserActivationWhereUniqueInput | UserActivationWhereUniqueInput[]
  }

  export type UserAuthCreateNestedManyWithoutUserInput = {
    create?: XOR<UserAuthCreateWithoutUserInput, UserAuthUncheckedCreateWithoutUserInput> | UserAuthCreateWithoutUserInput[] | UserAuthUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAuthCreateOrConnectWithoutUserInput | UserAuthCreateOrConnectWithoutUserInput[]
    createMany?: UserAuthCreateManyUserInputEnvelope
    connect?: UserAuthWhereUniqueInput | UserAuthWhereUniqueInput[]
  }

  export type DriverCreateNestedManyWithoutUserInput = {
    create?: XOR<DriverCreateWithoutUserInput, DriverUncheckedCreateWithoutUserInput> | DriverCreateWithoutUserInput[] | DriverUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DriverCreateOrConnectWithoutUserInput | DriverCreateOrConnectWithoutUserInput[]
    createMany?: DriverCreateManyUserInputEnvelope
    connect?: DriverWhereUniqueInput | DriverWhereUniqueInput[]
  }

  export type UserRoleUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type UserActivationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserActivationCreateWithoutUserInput, UserActivationUncheckedCreateWithoutUserInput> | UserActivationCreateWithoutUserInput[] | UserActivationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserActivationCreateOrConnectWithoutUserInput | UserActivationCreateOrConnectWithoutUserInput[]
    createMany?: UserActivationCreateManyUserInputEnvelope
    connect?: UserActivationWhereUniqueInput | UserActivationWhereUniqueInput[]
  }

  export type UserAuthUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserAuthCreateWithoutUserInput, UserAuthUncheckedCreateWithoutUserInput> | UserAuthCreateWithoutUserInput[] | UserAuthUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAuthCreateOrConnectWithoutUserInput | UserAuthCreateOrConnectWithoutUserInput[]
    createMany?: UserAuthCreateManyUserInputEnvelope
    connect?: UserAuthWhereUniqueInput | UserAuthWhereUniqueInput[]
  }

  export type DriverUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DriverCreateWithoutUserInput, DriverUncheckedCreateWithoutUserInput> | DriverCreateWithoutUserInput[] | DriverUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DriverCreateOrConnectWithoutUserInput | DriverCreateOrConnectWithoutUserInput[]
    createMany?: DriverCreateManyUserInputEnvelope
    connect?: DriverWhereUniqueInput | DriverWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserRoleUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutUserInput | UserRoleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutUserInput | UserRoleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutUserInput | UserRoleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type UserActivationUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserActivationCreateWithoutUserInput, UserActivationUncheckedCreateWithoutUserInput> | UserActivationCreateWithoutUserInput[] | UserActivationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserActivationCreateOrConnectWithoutUserInput | UserActivationCreateOrConnectWithoutUserInput[]
    upsert?: UserActivationUpsertWithWhereUniqueWithoutUserInput | UserActivationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserActivationCreateManyUserInputEnvelope
    set?: UserActivationWhereUniqueInput | UserActivationWhereUniqueInput[]
    disconnect?: UserActivationWhereUniqueInput | UserActivationWhereUniqueInput[]
    delete?: UserActivationWhereUniqueInput | UserActivationWhereUniqueInput[]
    connect?: UserActivationWhereUniqueInput | UserActivationWhereUniqueInput[]
    update?: UserActivationUpdateWithWhereUniqueWithoutUserInput | UserActivationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserActivationUpdateManyWithWhereWithoutUserInput | UserActivationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserActivationScalarWhereInput | UserActivationScalarWhereInput[]
  }

  export type UserAuthUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserAuthCreateWithoutUserInput, UserAuthUncheckedCreateWithoutUserInput> | UserAuthCreateWithoutUserInput[] | UserAuthUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAuthCreateOrConnectWithoutUserInput | UserAuthCreateOrConnectWithoutUserInput[]
    upsert?: UserAuthUpsertWithWhereUniqueWithoutUserInput | UserAuthUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserAuthCreateManyUserInputEnvelope
    set?: UserAuthWhereUniqueInput | UserAuthWhereUniqueInput[]
    disconnect?: UserAuthWhereUniqueInput | UserAuthWhereUniqueInput[]
    delete?: UserAuthWhereUniqueInput | UserAuthWhereUniqueInput[]
    connect?: UserAuthWhereUniqueInput | UserAuthWhereUniqueInput[]
    update?: UserAuthUpdateWithWhereUniqueWithoutUserInput | UserAuthUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserAuthUpdateManyWithWhereWithoutUserInput | UserAuthUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserAuthScalarWhereInput | UserAuthScalarWhereInput[]
  }

  export type DriverUpdateManyWithoutUserNestedInput = {
    create?: XOR<DriverCreateWithoutUserInput, DriverUncheckedCreateWithoutUserInput> | DriverCreateWithoutUserInput[] | DriverUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DriverCreateOrConnectWithoutUserInput | DriverCreateOrConnectWithoutUserInput[]
    upsert?: DriverUpsertWithWhereUniqueWithoutUserInput | DriverUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DriverCreateManyUserInputEnvelope
    set?: DriverWhereUniqueInput | DriverWhereUniqueInput[]
    disconnect?: DriverWhereUniqueInput | DriverWhereUniqueInput[]
    delete?: DriverWhereUniqueInput | DriverWhereUniqueInput[]
    connect?: DriverWhereUniqueInput | DriverWhereUniqueInput[]
    update?: DriverUpdateWithWhereUniqueWithoutUserInput | DriverUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DriverUpdateManyWithWhereWithoutUserInput | DriverUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DriverScalarWhereInput | DriverScalarWhereInput[]
  }

  export type UserRoleUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutUserInput | UserRoleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutUserInput | UserRoleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutUserInput | UserRoleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type UserActivationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserActivationCreateWithoutUserInput, UserActivationUncheckedCreateWithoutUserInput> | UserActivationCreateWithoutUserInput[] | UserActivationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserActivationCreateOrConnectWithoutUserInput | UserActivationCreateOrConnectWithoutUserInput[]
    upsert?: UserActivationUpsertWithWhereUniqueWithoutUserInput | UserActivationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserActivationCreateManyUserInputEnvelope
    set?: UserActivationWhereUniqueInput | UserActivationWhereUniqueInput[]
    disconnect?: UserActivationWhereUniqueInput | UserActivationWhereUniqueInput[]
    delete?: UserActivationWhereUniqueInput | UserActivationWhereUniqueInput[]
    connect?: UserActivationWhereUniqueInput | UserActivationWhereUniqueInput[]
    update?: UserActivationUpdateWithWhereUniqueWithoutUserInput | UserActivationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserActivationUpdateManyWithWhereWithoutUserInput | UserActivationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserActivationScalarWhereInput | UserActivationScalarWhereInput[]
  }

  export type UserAuthUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserAuthCreateWithoutUserInput, UserAuthUncheckedCreateWithoutUserInput> | UserAuthCreateWithoutUserInput[] | UserAuthUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAuthCreateOrConnectWithoutUserInput | UserAuthCreateOrConnectWithoutUserInput[]
    upsert?: UserAuthUpsertWithWhereUniqueWithoutUserInput | UserAuthUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserAuthCreateManyUserInputEnvelope
    set?: UserAuthWhereUniqueInput | UserAuthWhereUniqueInput[]
    disconnect?: UserAuthWhereUniqueInput | UserAuthWhereUniqueInput[]
    delete?: UserAuthWhereUniqueInput | UserAuthWhereUniqueInput[]
    connect?: UserAuthWhereUniqueInput | UserAuthWhereUniqueInput[]
    update?: UserAuthUpdateWithWhereUniqueWithoutUserInput | UserAuthUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserAuthUpdateManyWithWhereWithoutUserInput | UserAuthUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserAuthScalarWhereInput | UserAuthScalarWhereInput[]
  }

  export type DriverUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DriverCreateWithoutUserInput, DriverUncheckedCreateWithoutUserInput> | DriverCreateWithoutUserInput[] | DriverUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DriverCreateOrConnectWithoutUserInput | DriverCreateOrConnectWithoutUserInput[]
    upsert?: DriverUpsertWithWhereUniqueWithoutUserInput | DriverUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DriverCreateManyUserInputEnvelope
    set?: DriverWhereUniqueInput | DriverWhereUniqueInput[]
    disconnect?: DriverWhereUniqueInput | DriverWhereUniqueInput[]
    delete?: DriverWhereUniqueInput | DriverWhereUniqueInput[]
    connect?: DriverWhereUniqueInput | DriverWhereUniqueInput[]
    update?: DriverUpdateWithWhereUniqueWithoutUserInput | DriverUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DriverUpdateManyWithWhereWithoutUserInput | DriverUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DriverScalarWhereInput | DriverScalarWhereInput[]
  }

  export type UserRoleCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type UserRoleUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type UserRoleUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutRoleInput | UserRoleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutRoleInput | UserRoleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutRoleInput | UserRoleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type UserRoleUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutRoleInput | UserRoleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutRoleInput | UserRoleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutRoleInput | UserRoleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutRolesInput = {
    create?: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRolesInput
    connect?: UserWhereUniqueInput
  }

  export type RoleCreateNestedOneWithoutUsersInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    connect?: RoleWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRolesNestedInput = {
    create?: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRolesInput
    upsert?: UserUpsertWithoutRolesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRolesInput, UserUpdateWithoutRolesInput>, UserUncheckedUpdateWithoutRolesInput>
  }

  export type RoleUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    upsert?: RoleUpsertWithoutUsersInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutUsersInput, RoleUpdateWithoutUsersInput>, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type TripCreateNestedManyWithoutDriverInput = {
    create?: XOR<TripCreateWithoutDriverInput, TripUncheckedCreateWithoutDriverInput> | TripCreateWithoutDriverInput[] | TripUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: TripCreateOrConnectWithoutDriverInput | TripCreateOrConnectWithoutDriverInput[]
    createMany?: TripCreateManyDriverInputEnvelope
    connect?: TripWhereUniqueInput | TripWhereUniqueInput[]
  }

  export type ShiftCreateNestedManyWithoutDriverInput = {
    create?: XOR<ShiftCreateWithoutDriverInput, ShiftUncheckedCreateWithoutDriverInput> | ShiftCreateWithoutDriverInput[] | ShiftUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: ShiftCreateOrConnectWithoutDriverInput | ShiftCreateOrConnectWithoutDriverInput[]
    createMany?: ShiftCreateManyDriverInputEnvelope
    connect?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutDriversInput = {
    create?: XOR<UserCreateWithoutDriversInput, UserUncheckedCreateWithoutDriversInput>
    connectOrCreate?: UserCreateOrConnectWithoutDriversInput
    connect?: UserWhereUniqueInput
  }

  export type DutyCreateNestedManyWithoutDriverInput = {
    create?: XOR<DutyCreateWithoutDriverInput, DutyUncheckedCreateWithoutDriverInput> | DutyCreateWithoutDriverInput[] | DutyUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: DutyCreateOrConnectWithoutDriverInput | DutyCreateOrConnectWithoutDriverInput[]
    createMany?: DutyCreateManyDriverInputEnvelope
    connect?: DutyWhereUniqueInput | DutyWhereUniqueInput[]
  }

  export type TripUncheckedCreateNestedManyWithoutDriverInput = {
    create?: XOR<TripCreateWithoutDriverInput, TripUncheckedCreateWithoutDriverInput> | TripCreateWithoutDriverInput[] | TripUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: TripCreateOrConnectWithoutDriverInput | TripCreateOrConnectWithoutDriverInput[]
    createMany?: TripCreateManyDriverInputEnvelope
    connect?: TripWhereUniqueInput | TripWhereUniqueInput[]
  }

  export type ShiftUncheckedCreateNestedManyWithoutDriverInput = {
    create?: XOR<ShiftCreateWithoutDriverInput, ShiftUncheckedCreateWithoutDriverInput> | ShiftCreateWithoutDriverInput[] | ShiftUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: ShiftCreateOrConnectWithoutDriverInput | ShiftCreateOrConnectWithoutDriverInput[]
    createMany?: ShiftCreateManyDriverInputEnvelope
    connect?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
  }

  export type DutyUncheckedCreateNestedManyWithoutDriverInput = {
    create?: XOR<DutyCreateWithoutDriverInput, DutyUncheckedCreateWithoutDriverInput> | DutyCreateWithoutDriverInput[] | DutyUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: DutyCreateOrConnectWithoutDriverInput | DutyCreateOrConnectWithoutDriverInput[]
    createMany?: DutyCreateManyDriverInputEnvelope
    connect?: DutyWhereUniqueInput | DutyWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type TripUpdateManyWithoutDriverNestedInput = {
    create?: XOR<TripCreateWithoutDriverInput, TripUncheckedCreateWithoutDriverInput> | TripCreateWithoutDriverInput[] | TripUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: TripCreateOrConnectWithoutDriverInput | TripCreateOrConnectWithoutDriverInput[]
    upsert?: TripUpsertWithWhereUniqueWithoutDriverInput | TripUpsertWithWhereUniqueWithoutDriverInput[]
    createMany?: TripCreateManyDriverInputEnvelope
    set?: TripWhereUniqueInput | TripWhereUniqueInput[]
    disconnect?: TripWhereUniqueInput | TripWhereUniqueInput[]
    delete?: TripWhereUniqueInput | TripWhereUniqueInput[]
    connect?: TripWhereUniqueInput | TripWhereUniqueInput[]
    update?: TripUpdateWithWhereUniqueWithoutDriverInput | TripUpdateWithWhereUniqueWithoutDriverInput[]
    updateMany?: TripUpdateManyWithWhereWithoutDriverInput | TripUpdateManyWithWhereWithoutDriverInput[]
    deleteMany?: TripScalarWhereInput | TripScalarWhereInput[]
  }

  export type ShiftUpdateManyWithoutDriverNestedInput = {
    create?: XOR<ShiftCreateWithoutDriverInput, ShiftUncheckedCreateWithoutDriverInput> | ShiftCreateWithoutDriverInput[] | ShiftUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: ShiftCreateOrConnectWithoutDriverInput | ShiftCreateOrConnectWithoutDriverInput[]
    upsert?: ShiftUpsertWithWhereUniqueWithoutDriverInput | ShiftUpsertWithWhereUniqueWithoutDriverInput[]
    createMany?: ShiftCreateManyDriverInputEnvelope
    set?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    disconnect?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    delete?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    connect?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    update?: ShiftUpdateWithWhereUniqueWithoutDriverInput | ShiftUpdateWithWhereUniqueWithoutDriverInput[]
    updateMany?: ShiftUpdateManyWithWhereWithoutDriverInput | ShiftUpdateManyWithWhereWithoutDriverInput[]
    deleteMany?: ShiftScalarWhereInput | ShiftScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutDriversNestedInput = {
    create?: XOR<UserCreateWithoutDriversInput, UserUncheckedCreateWithoutDriversInput>
    connectOrCreate?: UserCreateOrConnectWithoutDriversInput
    upsert?: UserUpsertWithoutDriversInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDriversInput, UserUpdateWithoutDriversInput>, UserUncheckedUpdateWithoutDriversInput>
  }

  export type DutyUpdateManyWithoutDriverNestedInput = {
    create?: XOR<DutyCreateWithoutDriverInput, DutyUncheckedCreateWithoutDriverInput> | DutyCreateWithoutDriverInput[] | DutyUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: DutyCreateOrConnectWithoutDriverInput | DutyCreateOrConnectWithoutDriverInput[]
    upsert?: DutyUpsertWithWhereUniqueWithoutDriverInput | DutyUpsertWithWhereUniqueWithoutDriverInput[]
    createMany?: DutyCreateManyDriverInputEnvelope
    set?: DutyWhereUniqueInput | DutyWhereUniqueInput[]
    disconnect?: DutyWhereUniqueInput | DutyWhereUniqueInput[]
    delete?: DutyWhereUniqueInput | DutyWhereUniqueInput[]
    connect?: DutyWhereUniqueInput | DutyWhereUniqueInput[]
    update?: DutyUpdateWithWhereUniqueWithoutDriverInput | DutyUpdateWithWhereUniqueWithoutDriverInput[]
    updateMany?: DutyUpdateManyWithWhereWithoutDriverInput | DutyUpdateManyWithWhereWithoutDriverInput[]
    deleteMany?: DutyScalarWhereInput | DutyScalarWhereInput[]
  }

  export type TripUncheckedUpdateManyWithoutDriverNestedInput = {
    create?: XOR<TripCreateWithoutDriverInput, TripUncheckedCreateWithoutDriverInput> | TripCreateWithoutDriverInput[] | TripUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: TripCreateOrConnectWithoutDriverInput | TripCreateOrConnectWithoutDriverInput[]
    upsert?: TripUpsertWithWhereUniqueWithoutDriverInput | TripUpsertWithWhereUniqueWithoutDriverInput[]
    createMany?: TripCreateManyDriverInputEnvelope
    set?: TripWhereUniqueInput | TripWhereUniqueInput[]
    disconnect?: TripWhereUniqueInput | TripWhereUniqueInput[]
    delete?: TripWhereUniqueInput | TripWhereUniqueInput[]
    connect?: TripWhereUniqueInput | TripWhereUniqueInput[]
    update?: TripUpdateWithWhereUniqueWithoutDriverInput | TripUpdateWithWhereUniqueWithoutDriverInput[]
    updateMany?: TripUpdateManyWithWhereWithoutDriverInput | TripUpdateManyWithWhereWithoutDriverInput[]
    deleteMany?: TripScalarWhereInput | TripScalarWhereInput[]
  }

  export type ShiftUncheckedUpdateManyWithoutDriverNestedInput = {
    create?: XOR<ShiftCreateWithoutDriverInput, ShiftUncheckedCreateWithoutDriverInput> | ShiftCreateWithoutDriverInput[] | ShiftUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: ShiftCreateOrConnectWithoutDriverInput | ShiftCreateOrConnectWithoutDriverInput[]
    upsert?: ShiftUpsertWithWhereUniqueWithoutDriverInput | ShiftUpsertWithWhereUniqueWithoutDriverInput[]
    createMany?: ShiftCreateManyDriverInputEnvelope
    set?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    disconnect?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    delete?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    connect?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    update?: ShiftUpdateWithWhereUniqueWithoutDriverInput | ShiftUpdateWithWhereUniqueWithoutDriverInput[]
    updateMany?: ShiftUpdateManyWithWhereWithoutDriverInput | ShiftUpdateManyWithWhereWithoutDriverInput[]
    deleteMany?: ShiftScalarWhereInput | ShiftScalarWhereInput[]
  }

  export type DutyUncheckedUpdateManyWithoutDriverNestedInput = {
    create?: XOR<DutyCreateWithoutDriverInput, DutyUncheckedCreateWithoutDriverInput> | DutyCreateWithoutDriverInput[] | DutyUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: DutyCreateOrConnectWithoutDriverInput | DutyCreateOrConnectWithoutDriverInput[]
    upsert?: DutyUpsertWithWhereUniqueWithoutDriverInput | DutyUpsertWithWhereUniqueWithoutDriverInput[]
    createMany?: DutyCreateManyDriverInputEnvelope
    set?: DutyWhereUniqueInput | DutyWhereUniqueInput[]
    disconnect?: DutyWhereUniqueInput | DutyWhereUniqueInput[]
    delete?: DutyWhereUniqueInput | DutyWhereUniqueInput[]
    connect?: DutyWhereUniqueInput | DutyWhereUniqueInput[]
    update?: DutyUpdateWithWhereUniqueWithoutDriverInput | DutyUpdateWithWhereUniqueWithoutDriverInput[]
    updateMany?: DutyUpdateManyWithWhereWithoutDriverInput | DutyUpdateManyWithWhereWithoutDriverInput[]
    deleteMany?: DutyScalarWhereInput | DutyScalarWhereInput[]
  }

  export type VehicleCreateNestedManyWithoutModelInput = {
    create?: XOR<VehicleCreateWithoutModelInput, VehicleUncheckedCreateWithoutModelInput> | VehicleCreateWithoutModelInput[] | VehicleUncheckedCreateWithoutModelInput[]
    connectOrCreate?: VehicleCreateOrConnectWithoutModelInput | VehicleCreateOrConnectWithoutModelInput[]
    createMany?: VehicleCreateManyModelInputEnvelope
    connect?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
  }

  export type VehicleUncheckedCreateNestedManyWithoutModelInput = {
    create?: XOR<VehicleCreateWithoutModelInput, VehicleUncheckedCreateWithoutModelInput> | VehicleCreateWithoutModelInput[] | VehicleUncheckedCreateWithoutModelInput[]
    connectOrCreate?: VehicleCreateOrConnectWithoutModelInput | VehicleCreateOrConnectWithoutModelInput[]
    createMany?: VehicleCreateManyModelInputEnvelope
    connect?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
  }

  export type VehicleUpdateManyWithoutModelNestedInput = {
    create?: XOR<VehicleCreateWithoutModelInput, VehicleUncheckedCreateWithoutModelInput> | VehicleCreateWithoutModelInput[] | VehicleUncheckedCreateWithoutModelInput[]
    connectOrCreate?: VehicleCreateOrConnectWithoutModelInput | VehicleCreateOrConnectWithoutModelInput[]
    upsert?: VehicleUpsertWithWhereUniqueWithoutModelInput | VehicleUpsertWithWhereUniqueWithoutModelInput[]
    createMany?: VehicleCreateManyModelInputEnvelope
    set?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    disconnect?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    delete?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    connect?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    update?: VehicleUpdateWithWhereUniqueWithoutModelInput | VehicleUpdateWithWhereUniqueWithoutModelInput[]
    updateMany?: VehicleUpdateManyWithWhereWithoutModelInput | VehicleUpdateManyWithWhereWithoutModelInput[]
    deleteMany?: VehicleScalarWhereInput | VehicleScalarWhereInput[]
  }

  export type VehicleUncheckedUpdateManyWithoutModelNestedInput = {
    create?: XOR<VehicleCreateWithoutModelInput, VehicleUncheckedCreateWithoutModelInput> | VehicleCreateWithoutModelInput[] | VehicleUncheckedCreateWithoutModelInput[]
    connectOrCreate?: VehicleCreateOrConnectWithoutModelInput | VehicleCreateOrConnectWithoutModelInput[]
    upsert?: VehicleUpsertWithWhereUniqueWithoutModelInput | VehicleUpsertWithWhereUniqueWithoutModelInput[]
    createMany?: VehicleCreateManyModelInputEnvelope
    set?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    disconnect?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    delete?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    connect?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    update?: VehicleUpdateWithWhereUniqueWithoutModelInput | VehicleUpdateWithWhereUniqueWithoutModelInput[]
    updateMany?: VehicleUpdateManyWithWhereWithoutModelInput | VehicleUpdateManyWithWhereWithoutModelInput[]
    deleteMany?: VehicleScalarWhereInput | VehicleScalarWhereInput[]
  }

  export type VehicleModelCreateNestedOneWithoutVehiclesInput = {
    create?: XOR<VehicleModelCreateWithoutVehiclesInput, VehicleModelUncheckedCreateWithoutVehiclesInput>
    connectOrCreate?: VehicleModelCreateOrConnectWithoutVehiclesInput
    connect?: VehicleModelWhereUniqueInput
  }

  export type TripCreateNestedManyWithoutVehicleInput = {
    create?: XOR<TripCreateWithoutVehicleInput, TripUncheckedCreateWithoutVehicleInput> | TripCreateWithoutVehicleInput[] | TripUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: TripCreateOrConnectWithoutVehicleInput | TripCreateOrConnectWithoutVehicleInput[]
    createMany?: TripCreateManyVehicleInputEnvelope
    connect?: TripWhereUniqueInput | TripWhereUniqueInput[]
  }

  export type ShiftCreateNestedManyWithoutVehicleInput = {
    create?: XOR<ShiftCreateWithoutVehicleInput, ShiftUncheckedCreateWithoutVehicleInput> | ShiftCreateWithoutVehicleInput[] | ShiftUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: ShiftCreateOrConnectWithoutVehicleInput | ShiftCreateOrConnectWithoutVehicleInput[]
    createMany?: ShiftCreateManyVehicleInputEnvelope
    connect?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
  }

  export type VehicleTelemetryCreateNestedManyWithoutVehicleInput = {
    create?: XOR<VehicleTelemetryCreateWithoutVehicleInput, VehicleTelemetryUncheckedCreateWithoutVehicleInput> | VehicleTelemetryCreateWithoutVehicleInput[] | VehicleTelemetryUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: VehicleTelemetryCreateOrConnectWithoutVehicleInput | VehicleTelemetryCreateOrConnectWithoutVehicleInput[]
    createMany?: VehicleTelemetryCreateManyVehicleInputEnvelope
    connect?: VehicleTelemetryWhereUniqueInput | VehicleTelemetryWhereUniqueInput[]
  }

  export type VehicleTelemetryHistoryCreateNestedManyWithoutVehicleInput = {
    create?: XOR<VehicleTelemetryHistoryCreateWithoutVehicleInput, VehicleTelemetryHistoryUncheckedCreateWithoutVehicleInput> | VehicleTelemetryHistoryCreateWithoutVehicleInput[] | VehicleTelemetryHistoryUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: VehicleTelemetryHistoryCreateOrConnectWithoutVehicleInput | VehicleTelemetryHistoryCreateOrConnectWithoutVehicleInput[]
    createMany?: VehicleTelemetryHistoryCreateManyVehicleInputEnvelope
    connect?: VehicleTelemetryHistoryWhereUniqueInput | VehicleTelemetryHistoryWhereUniqueInput[]
  }

  export type DutyCreateNestedManyWithoutVehicleInput = {
    create?: XOR<DutyCreateWithoutVehicleInput, DutyUncheckedCreateWithoutVehicleInput> | DutyCreateWithoutVehicleInput[] | DutyUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: DutyCreateOrConnectWithoutVehicleInput | DutyCreateOrConnectWithoutVehicleInput[]
    createMany?: DutyCreateManyVehicleInputEnvelope
    connect?: DutyWhereUniqueInput | DutyWhereUniqueInput[]
  }

  export type TripUncheckedCreateNestedManyWithoutVehicleInput = {
    create?: XOR<TripCreateWithoutVehicleInput, TripUncheckedCreateWithoutVehicleInput> | TripCreateWithoutVehicleInput[] | TripUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: TripCreateOrConnectWithoutVehicleInput | TripCreateOrConnectWithoutVehicleInput[]
    createMany?: TripCreateManyVehicleInputEnvelope
    connect?: TripWhereUniqueInput | TripWhereUniqueInput[]
  }

  export type ShiftUncheckedCreateNestedManyWithoutVehicleInput = {
    create?: XOR<ShiftCreateWithoutVehicleInput, ShiftUncheckedCreateWithoutVehicleInput> | ShiftCreateWithoutVehicleInput[] | ShiftUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: ShiftCreateOrConnectWithoutVehicleInput | ShiftCreateOrConnectWithoutVehicleInput[]
    createMany?: ShiftCreateManyVehicleInputEnvelope
    connect?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
  }

  export type VehicleTelemetryUncheckedCreateNestedManyWithoutVehicleInput = {
    create?: XOR<VehicleTelemetryCreateWithoutVehicleInput, VehicleTelemetryUncheckedCreateWithoutVehicleInput> | VehicleTelemetryCreateWithoutVehicleInput[] | VehicleTelemetryUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: VehicleTelemetryCreateOrConnectWithoutVehicleInput | VehicleTelemetryCreateOrConnectWithoutVehicleInput[]
    createMany?: VehicleTelemetryCreateManyVehicleInputEnvelope
    connect?: VehicleTelemetryWhereUniqueInput | VehicleTelemetryWhereUniqueInput[]
  }

  export type VehicleTelemetryHistoryUncheckedCreateNestedManyWithoutVehicleInput = {
    create?: XOR<VehicleTelemetryHistoryCreateWithoutVehicleInput, VehicleTelemetryHistoryUncheckedCreateWithoutVehicleInput> | VehicleTelemetryHistoryCreateWithoutVehicleInput[] | VehicleTelemetryHistoryUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: VehicleTelemetryHistoryCreateOrConnectWithoutVehicleInput | VehicleTelemetryHistoryCreateOrConnectWithoutVehicleInput[]
    createMany?: VehicleTelemetryHistoryCreateManyVehicleInputEnvelope
    connect?: VehicleTelemetryHistoryWhereUniqueInput | VehicleTelemetryHistoryWhereUniqueInput[]
  }

  export type DutyUncheckedCreateNestedManyWithoutVehicleInput = {
    create?: XOR<DutyCreateWithoutVehicleInput, DutyUncheckedCreateWithoutVehicleInput> | DutyCreateWithoutVehicleInput[] | DutyUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: DutyCreateOrConnectWithoutVehicleInput | DutyCreateOrConnectWithoutVehicleInput[]
    createMany?: DutyCreateManyVehicleInputEnvelope
    connect?: DutyWhereUniqueInput | DutyWhereUniqueInput[]
  }

  export type VehicleModelUpdateOneRequiredWithoutVehiclesNestedInput = {
    create?: XOR<VehicleModelCreateWithoutVehiclesInput, VehicleModelUncheckedCreateWithoutVehiclesInput>
    connectOrCreate?: VehicleModelCreateOrConnectWithoutVehiclesInput
    upsert?: VehicleModelUpsertWithoutVehiclesInput
    connect?: VehicleModelWhereUniqueInput
    update?: XOR<XOR<VehicleModelUpdateToOneWithWhereWithoutVehiclesInput, VehicleModelUpdateWithoutVehiclesInput>, VehicleModelUncheckedUpdateWithoutVehiclesInput>
  }

  export type TripUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<TripCreateWithoutVehicleInput, TripUncheckedCreateWithoutVehicleInput> | TripCreateWithoutVehicleInput[] | TripUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: TripCreateOrConnectWithoutVehicleInput | TripCreateOrConnectWithoutVehicleInput[]
    upsert?: TripUpsertWithWhereUniqueWithoutVehicleInput | TripUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: TripCreateManyVehicleInputEnvelope
    set?: TripWhereUniqueInput | TripWhereUniqueInput[]
    disconnect?: TripWhereUniqueInput | TripWhereUniqueInput[]
    delete?: TripWhereUniqueInput | TripWhereUniqueInput[]
    connect?: TripWhereUniqueInput | TripWhereUniqueInput[]
    update?: TripUpdateWithWhereUniqueWithoutVehicleInput | TripUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: TripUpdateManyWithWhereWithoutVehicleInput | TripUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: TripScalarWhereInput | TripScalarWhereInput[]
  }

  export type ShiftUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<ShiftCreateWithoutVehicleInput, ShiftUncheckedCreateWithoutVehicleInput> | ShiftCreateWithoutVehicleInput[] | ShiftUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: ShiftCreateOrConnectWithoutVehicleInput | ShiftCreateOrConnectWithoutVehicleInput[]
    upsert?: ShiftUpsertWithWhereUniqueWithoutVehicleInput | ShiftUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: ShiftCreateManyVehicleInputEnvelope
    set?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    disconnect?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    delete?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    connect?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    update?: ShiftUpdateWithWhereUniqueWithoutVehicleInput | ShiftUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: ShiftUpdateManyWithWhereWithoutVehicleInput | ShiftUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: ShiftScalarWhereInput | ShiftScalarWhereInput[]
  }

  export type VehicleTelemetryUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<VehicleTelemetryCreateWithoutVehicleInput, VehicleTelemetryUncheckedCreateWithoutVehicleInput> | VehicleTelemetryCreateWithoutVehicleInput[] | VehicleTelemetryUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: VehicleTelemetryCreateOrConnectWithoutVehicleInput | VehicleTelemetryCreateOrConnectWithoutVehicleInput[]
    upsert?: VehicleTelemetryUpsertWithWhereUniqueWithoutVehicleInput | VehicleTelemetryUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: VehicleTelemetryCreateManyVehicleInputEnvelope
    set?: VehicleTelemetryWhereUniqueInput | VehicleTelemetryWhereUniqueInput[]
    disconnect?: VehicleTelemetryWhereUniqueInput | VehicleTelemetryWhereUniqueInput[]
    delete?: VehicleTelemetryWhereUniqueInput | VehicleTelemetryWhereUniqueInput[]
    connect?: VehicleTelemetryWhereUniqueInput | VehicleTelemetryWhereUniqueInput[]
    update?: VehicleTelemetryUpdateWithWhereUniqueWithoutVehicleInput | VehicleTelemetryUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: VehicleTelemetryUpdateManyWithWhereWithoutVehicleInput | VehicleTelemetryUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: VehicleTelemetryScalarWhereInput | VehicleTelemetryScalarWhereInput[]
  }

  export type VehicleTelemetryHistoryUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<VehicleTelemetryHistoryCreateWithoutVehicleInput, VehicleTelemetryHistoryUncheckedCreateWithoutVehicleInput> | VehicleTelemetryHistoryCreateWithoutVehicleInput[] | VehicleTelemetryHistoryUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: VehicleTelemetryHistoryCreateOrConnectWithoutVehicleInput | VehicleTelemetryHistoryCreateOrConnectWithoutVehicleInput[]
    upsert?: VehicleTelemetryHistoryUpsertWithWhereUniqueWithoutVehicleInput | VehicleTelemetryHistoryUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: VehicleTelemetryHistoryCreateManyVehicleInputEnvelope
    set?: VehicleTelemetryHistoryWhereUniqueInput | VehicleTelemetryHistoryWhereUniqueInput[]
    disconnect?: VehicleTelemetryHistoryWhereUniqueInput | VehicleTelemetryHistoryWhereUniqueInput[]
    delete?: VehicleTelemetryHistoryWhereUniqueInput | VehicleTelemetryHistoryWhereUniqueInput[]
    connect?: VehicleTelemetryHistoryWhereUniqueInput | VehicleTelemetryHistoryWhereUniqueInput[]
    update?: VehicleTelemetryHistoryUpdateWithWhereUniqueWithoutVehicleInput | VehicleTelemetryHistoryUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: VehicleTelemetryHistoryUpdateManyWithWhereWithoutVehicleInput | VehicleTelemetryHistoryUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: VehicleTelemetryHistoryScalarWhereInput | VehicleTelemetryHistoryScalarWhereInput[]
  }

  export type DutyUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<DutyCreateWithoutVehicleInput, DutyUncheckedCreateWithoutVehicleInput> | DutyCreateWithoutVehicleInput[] | DutyUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: DutyCreateOrConnectWithoutVehicleInput | DutyCreateOrConnectWithoutVehicleInput[]
    upsert?: DutyUpsertWithWhereUniqueWithoutVehicleInput | DutyUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: DutyCreateManyVehicleInputEnvelope
    set?: DutyWhereUniqueInput | DutyWhereUniqueInput[]
    disconnect?: DutyWhereUniqueInput | DutyWhereUniqueInput[]
    delete?: DutyWhereUniqueInput | DutyWhereUniqueInput[]
    connect?: DutyWhereUniqueInput | DutyWhereUniqueInput[]
    update?: DutyUpdateWithWhereUniqueWithoutVehicleInput | DutyUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: DutyUpdateManyWithWhereWithoutVehicleInput | DutyUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: DutyScalarWhereInput | DutyScalarWhereInput[]
  }

  export type TripUncheckedUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<TripCreateWithoutVehicleInput, TripUncheckedCreateWithoutVehicleInput> | TripCreateWithoutVehicleInput[] | TripUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: TripCreateOrConnectWithoutVehicleInput | TripCreateOrConnectWithoutVehicleInput[]
    upsert?: TripUpsertWithWhereUniqueWithoutVehicleInput | TripUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: TripCreateManyVehicleInputEnvelope
    set?: TripWhereUniqueInput | TripWhereUniqueInput[]
    disconnect?: TripWhereUniqueInput | TripWhereUniqueInput[]
    delete?: TripWhereUniqueInput | TripWhereUniqueInput[]
    connect?: TripWhereUniqueInput | TripWhereUniqueInput[]
    update?: TripUpdateWithWhereUniqueWithoutVehicleInput | TripUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: TripUpdateManyWithWhereWithoutVehicleInput | TripUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: TripScalarWhereInput | TripScalarWhereInput[]
  }

  export type ShiftUncheckedUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<ShiftCreateWithoutVehicleInput, ShiftUncheckedCreateWithoutVehicleInput> | ShiftCreateWithoutVehicleInput[] | ShiftUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: ShiftCreateOrConnectWithoutVehicleInput | ShiftCreateOrConnectWithoutVehicleInput[]
    upsert?: ShiftUpsertWithWhereUniqueWithoutVehicleInput | ShiftUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: ShiftCreateManyVehicleInputEnvelope
    set?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    disconnect?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    delete?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    connect?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    update?: ShiftUpdateWithWhereUniqueWithoutVehicleInput | ShiftUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: ShiftUpdateManyWithWhereWithoutVehicleInput | ShiftUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: ShiftScalarWhereInput | ShiftScalarWhereInput[]
  }

  export type VehicleTelemetryUncheckedUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<VehicleTelemetryCreateWithoutVehicleInput, VehicleTelemetryUncheckedCreateWithoutVehicleInput> | VehicleTelemetryCreateWithoutVehicleInput[] | VehicleTelemetryUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: VehicleTelemetryCreateOrConnectWithoutVehicleInput | VehicleTelemetryCreateOrConnectWithoutVehicleInput[]
    upsert?: VehicleTelemetryUpsertWithWhereUniqueWithoutVehicleInput | VehicleTelemetryUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: VehicleTelemetryCreateManyVehicleInputEnvelope
    set?: VehicleTelemetryWhereUniqueInput | VehicleTelemetryWhereUniqueInput[]
    disconnect?: VehicleTelemetryWhereUniqueInput | VehicleTelemetryWhereUniqueInput[]
    delete?: VehicleTelemetryWhereUniqueInput | VehicleTelemetryWhereUniqueInput[]
    connect?: VehicleTelemetryWhereUniqueInput | VehicleTelemetryWhereUniqueInput[]
    update?: VehicleTelemetryUpdateWithWhereUniqueWithoutVehicleInput | VehicleTelemetryUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: VehicleTelemetryUpdateManyWithWhereWithoutVehicleInput | VehicleTelemetryUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: VehicleTelemetryScalarWhereInput | VehicleTelemetryScalarWhereInput[]
  }

  export type VehicleTelemetryHistoryUncheckedUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<VehicleTelemetryHistoryCreateWithoutVehicleInput, VehicleTelemetryHistoryUncheckedCreateWithoutVehicleInput> | VehicleTelemetryHistoryCreateWithoutVehicleInput[] | VehicleTelemetryHistoryUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: VehicleTelemetryHistoryCreateOrConnectWithoutVehicleInput | VehicleTelemetryHistoryCreateOrConnectWithoutVehicleInput[]
    upsert?: VehicleTelemetryHistoryUpsertWithWhereUniqueWithoutVehicleInput | VehicleTelemetryHistoryUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: VehicleTelemetryHistoryCreateManyVehicleInputEnvelope
    set?: VehicleTelemetryHistoryWhereUniqueInput | VehicleTelemetryHistoryWhereUniqueInput[]
    disconnect?: VehicleTelemetryHistoryWhereUniqueInput | VehicleTelemetryHistoryWhereUniqueInput[]
    delete?: VehicleTelemetryHistoryWhereUniqueInput | VehicleTelemetryHistoryWhereUniqueInput[]
    connect?: VehicleTelemetryHistoryWhereUniqueInput | VehicleTelemetryHistoryWhereUniqueInput[]
    update?: VehicleTelemetryHistoryUpdateWithWhereUniqueWithoutVehicleInput | VehicleTelemetryHistoryUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: VehicleTelemetryHistoryUpdateManyWithWhereWithoutVehicleInput | VehicleTelemetryHistoryUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: VehicleTelemetryHistoryScalarWhereInput | VehicleTelemetryHistoryScalarWhereInput[]
  }

  export type DutyUncheckedUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<DutyCreateWithoutVehicleInput, DutyUncheckedCreateWithoutVehicleInput> | DutyCreateWithoutVehicleInput[] | DutyUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: DutyCreateOrConnectWithoutVehicleInput | DutyCreateOrConnectWithoutVehicleInput[]
    upsert?: DutyUpsertWithWhereUniqueWithoutVehicleInput | DutyUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: DutyCreateManyVehicleInputEnvelope
    set?: DutyWhereUniqueInput | DutyWhereUniqueInput[]
    disconnect?: DutyWhereUniqueInput | DutyWhereUniqueInput[]
    delete?: DutyWhereUniqueInput | DutyWhereUniqueInput[]
    connect?: DutyWhereUniqueInput | DutyWhereUniqueInput[]
    update?: DutyUpdateWithWhereUniqueWithoutVehicleInput | DutyUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: DutyUpdateManyWithWhereWithoutVehicleInput | DutyUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: DutyScalarWhereInput | DutyScalarWhereInput[]
  }

  export type StopCreateNestedManyWithoutLocationInput = {
    create?: XOR<StopCreateWithoutLocationInput, StopUncheckedCreateWithoutLocationInput> | StopCreateWithoutLocationInput[] | StopUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: StopCreateOrConnectWithoutLocationInput | StopCreateOrConnectWithoutLocationInput[]
    createMany?: StopCreateManyLocationInputEnvelope
    connect?: StopWhereUniqueInput | StopWhereUniqueInput[]
  }

  export type StopUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<StopCreateWithoutLocationInput, StopUncheckedCreateWithoutLocationInput> | StopCreateWithoutLocationInput[] | StopUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: StopCreateOrConnectWithoutLocationInput | StopCreateOrConnectWithoutLocationInput[]
    createMany?: StopCreateManyLocationInputEnvelope
    connect?: StopWhereUniqueInput | StopWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type StopUpdateManyWithoutLocationNestedInput = {
    create?: XOR<StopCreateWithoutLocationInput, StopUncheckedCreateWithoutLocationInput> | StopCreateWithoutLocationInput[] | StopUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: StopCreateOrConnectWithoutLocationInput | StopCreateOrConnectWithoutLocationInput[]
    upsert?: StopUpsertWithWhereUniqueWithoutLocationInput | StopUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: StopCreateManyLocationInputEnvelope
    set?: StopWhereUniqueInput | StopWhereUniqueInput[]
    disconnect?: StopWhereUniqueInput | StopWhereUniqueInput[]
    delete?: StopWhereUniqueInput | StopWhereUniqueInput[]
    connect?: StopWhereUniqueInput | StopWhereUniqueInput[]
    update?: StopUpdateWithWhereUniqueWithoutLocationInput | StopUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: StopUpdateManyWithWhereWithoutLocationInput | StopUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: StopScalarWhereInput | StopScalarWhereInput[]
  }

  export type StopUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<StopCreateWithoutLocationInput, StopUncheckedCreateWithoutLocationInput> | StopCreateWithoutLocationInput[] | StopUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: StopCreateOrConnectWithoutLocationInput | StopCreateOrConnectWithoutLocationInput[]
    upsert?: StopUpsertWithWhereUniqueWithoutLocationInput | StopUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: StopCreateManyLocationInputEnvelope
    set?: StopWhereUniqueInput | StopWhereUniqueInput[]
    disconnect?: StopWhereUniqueInput | StopWhereUniqueInput[]
    delete?: StopWhereUniqueInput | StopWhereUniqueInput[]
    connect?: StopWhereUniqueInput | StopWhereUniqueInput[]
    update?: StopUpdateWithWhereUniqueWithoutLocationInput | StopUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: StopUpdateManyWithWhereWithoutLocationInput | StopUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: StopScalarWhereInput | StopScalarWhereInput[]
  }

  export type LocationCreateNestedOneWithoutStopsInput = {
    create?: XOR<LocationCreateWithoutStopsInput, LocationUncheckedCreateWithoutStopsInput>
    connectOrCreate?: LocationCreateOrConnectWithoutStopsInput
    connect?: LocationWhereUniqueInput
  }

  export type RouteStopCreateNestedManyWithoutStopInput = {
    create?: XOR<RouteStopCreateWithoutStopInput, RouteStopUncheckedCreateWithoutStopInput> | RouteStopCreateWithoutStopInput[] | RouteStopUncheckedCreateWithoutStopInput[]
    connectOrCreate?: RouteStopCreateOrConnectWithoutStopInput | RouteStopCreateOrConnectWithoutStopInput[]
    createMany?: RouteStopCreateManyStopInputEnvelope
    connect?: RouteStopWhereUniqueInput | RouteStopWhereUniqueInput[]
  }

  export type TripStopCreateNestedManyWithoutStopInput = {
    create?: XOR<TripStopCreateWithoutStopInput, TripStopUncheckedCreateWithoutStopInput> | TripStopCreateWithoutStopInput[] | TripStopUncheckedCreateWithoutStopInput[]
    connectOrCreate?: TripStopCreateOrConnectWithoutStopInput | TripStopCreateOrConnectWithoutStopInput[]
    createMany?: TripStopCreateManyStopInputEnvelope
    connect?: TripStopWhereUniqueInput | TripStopWhereUniqueInput[]
  }

  export type RouteStopUncheckedCreateNestedManyWithoutStopInput = {
    create?: XOR<RouteStopCreateWithoutStopInput, RouteStopUncheckedCreateWithoutStopInput> | RouteStopCreateWithoutStopInput[] | RouteStopUncheckedCreateWithoutStopInput[]
    connectOrCreate?: RouteStopCreateOrConnectWithoutStopInput | RouteStopCreateOrConnectWithoutStopInput[]
    createMany?: RouteStopCreateManyStopInputEnvelope
    connect?: RouteStopWhereUniqueInput | RouteStopWhereUniqueInput[]
  }

  export type TripStopUncheckedCreateNestedManyWithoutStopInput = {
    create?: XOR<TripStopCreateWithoutStopInput, TripStopUncheckedCreateWithoutStopInput> | TripStopCreateWithoutStopInput[] | TripStopUncheckedCreateWithoutStopInput[]
    connectOrCreate?: TripStopCreateOrConnectWithoutStopInput | TripStopCreateOrConnectWithoutStopInput[]
    createMany?: TripStopCreateManyStopInputEnvelope
    connect?: TripStopWhereUniqueInput | TripStopWhereUniqueInput[]
  }

  export type LocationUpdateOneRequiredWithoutStopsNestedInput = {
    create?: XOR<LocationCreateWithoutStopsInput, LocationUncheckedCreateWithoutStopsInput>
    connectOrCreate?: LocationCreateOrConnectWithoutStopsInput
    upsert?: LocationUpsertWithoutStopsInput
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutStopsInput, LocationUpdateWithoutStopsInput>, LocationUncheckedUpdateWithoutStopsInput>
  }

  export type RouteStopUpdateManyWithoutStopNestedInput = {
    create?: XOR<RouteStopCreateWithoutStopInput, RouteStopUncheckedCreateWithoutStopInput> | RouteStopCreateWithoutStopInput[] | RouteStopUncheckedCreateWithoutStopInput[]
    connectOrCreate?: RouteStopCreateOrConnectWithoutStopInput | RouteStopCreateOrConnectWithoutStopInput[]
    upsert?: RouteStopUpsertWithWhereUniqueWithoutStopInput | RouteStopUpsertWithWhereUniqueWithoutStopInput[]
    createMany?: RouteStopCreateManyStopInputEnvelope
    set?: RouteStopWhereUniqueInput | RouteStopWhereUniqueInput[]
    disconnect?: RouteStopWhereUniqueInput | RouteStopWhereUniqueInput[]
    delete?: RouteStopWhereUniqueInput | RouteStopWhereUniqueInput[]
    connect?: RouteStopWhereUniqueInput | RouteStopWhereUniqueInput[]
    update?: RouteStopUpdateWithWhereUniqueWithoutStopInput | RouteStopUpdateWithWhereUniqueWithoutStopInput[]
    updateMany?: RouteStopUpdateManyWithWhereWithoutStopInput | RouteStopUpdateManyWithWhereWithoutStopInput[]
    deleteMany?: RouteStopScalarWhereInput | RouteStopScalarWhereInput[]
  }

  export type TripStopUpdateManyWithoutStopNestedInput = {
    create?: XOR<TripStopCreateWithoutStopInput, TripStopUncheckedCreateWithoutStopInput> | TripStopCreateWithoutStopInput[] | TripStopUncheckedCreateWithoutStopInput[]
    connectOrCreate?: TripStopCreateOrConnectWithoutStopInput | TripStopCreateOrConnectWithoutStopInput[]
    upsert?: TripStopUpsertWithWhereUniqueWithoutStopInput | TripStopUpsertWithWhereUniqueWithoutStopInput[]
    createMany?: TripStopCreateManyStopInputEnvelope
    set?: TripStopWhereUniqueInput | TripStopWhereUniqueInput[]
    disconnect?: TripStopWhereUniqueInput | TripStopWhereUniqueInput[]
    delete?: TripStopWhereUniqueInput | TripStopWhereUniqueInput[]
    connect?: TripStopWhereUniqueInput | TripStopWhereUniqueInput[]
    update?: TripStopUpdateWithWhereUniqueWithoutStopInput | TripStopUpdateWithWhereUniqueWithoutStopInput[]
    updateMany?: TripStopUpdateManyWithWhereWithoutStopInput | TripStopUpdateManyWithWhereWithoutStopInput[]
    deleteMany?: TripStopScalarWhereInput | TripStopScalarWhereInput[]
  }

  export type RouteStopUncheckedUpdateManyWithoutStopNestedInput = {
    create?: XOR<RouteStopCreateWithoutStopInput, RouteStopUncheckedCreateWithoutStopInput> | RouteStopCreateWithoutStopInput[] | RouteStopUncheckedCreateWithoutStopInput[]
    connectOrCreate?: RouteStopCreateOrConnectWithoutStopInput | RouteStopCreateOrConnectWithoutStopInput[]
    upsert?: RouteStopUpsertWithWhereUniqueWithoutStopInput | RouteStopUpsertWithWhereUniqueWithoutStopInput[]
    createMany?: RouteStopCreateManyStopInputEnvelope
    set?: RouteStopWhereUniqueInput | RouteStopWhereUniqueInput[]
    disconnect?: RouteStopWhereUniqueInput | RouteStopWhereUniqueInput[]
    delete?: RouteStopWhereUniqueInput | RouteStopWhereUniqueInput[]
    connect?: RouteStopWhereUniqueInput | RouteStopWhereUniqueInput[]
    update?: RouteStopUpdateWithWhereUniqueWithoutStopInput | RouteStopUpdateWithWhereUniqueWithoutStopInput[]
    updateMany?: RouteStopUpdateManyWithWhereWithoutStopInput | RouteStopUpdateManyWithWhereWithoutStopInput[]
    deleteMany?: RouteStopScalarWhereInput | RouteStopScalarWhereInput[]
  }

  export type TripStopUncheckedUpdateManyWithoutStopNestedInput = {
    create?: XOR<TripStopCreateWithoutStopInput, TripStopUncheckedCreateWithoutStopInput> | TripStopCreateWithoutStopInput[] | TripStopUncheckedCreateWithoutStopInput[]
    connectOrCreate?: TripStopCreateOrConnectWithoutStopInput | TripStopCreateOrConnectWithoutStopInput[]
    upsert?: TripStopUpsertWithWhereUniqueWithoutStopInput | TripStopUpsertWithWhereUniqueWithoutStopInput[]
    createMany?: TripStopCreateManyStopInputEnvelope
    set?: TripStopWhereUniqueInput | TripStopWhereUniqueInput[]
    disconnect?: TripStopWhereUniqueInput | TripStopWhereUniqueInput[]
    delete?: TripStopWhereUniqueInput | TripStopWhereUniqueInput[]
    connect?: TripStopWhereUniqueInput | TripStopWhereUniqueInput[]
    update?: TripStopUpdateWithWhereUniqueWithoutStopInput | TripStopUpdateWithWhereUniqueWithoutStopInput[]
    updateMany?: TripStopUpdateManyWithWhereWithoutStopInput | TripStopUpdateManyWithWhereWithoutStopInput[]
    deleteMany?: TripStopScalarWhereInput | TripStopScalarWhereInput[]
  }

  export type RouteStopCreateNestedManyWithoutRouteInput = {
    create?: XOR<RouteStopCreateWithoutRouteInput, RouteStopUncheckedCreateWithoutRouteInput> | RouteStopCreateWithoutRouteInput[] | RouteStopUncheckedCreateWithoutRouteInput[]
    connectOrCreate?: RouteStopCreateOrConnectWithoutRouteInput | RouteStopCreateOrConnectWithoutRouteInput[]
    createMany?: RouteStopCreateManyRouteInputEnvelope
    connect?: RouteStopWhereUniqueInput | RouteStopWhereUniqueInput[]
  }

  export type TripCreateNestedManyWithoutRouteInput = {
    create?: XOR<TripCreateWithoutRouteInput, TripUncheckedCreateWithoutRouteInput> | TripCreateWithoutRouteInput[] | TripUncheckedCreateWithoutRouteInput[]
    connectOrCreate?: TripCreateOrConnectWithoutRouteInput | TripCreateOrConnectWithoutRouteInput[]
    createMany?: TripCreateManyRouteInputEnvelope
    connect?: TripWhereUniqueInput | TripWhereUniqueInput[]
  }

  export type TripDutyCreateNestedManyWithoutRouteInput = {
    create?: XOR<TripDutyCreateWithoutRouteInput, TripDutyUncheckedCreateWithoutRouteInput> | TripDutyCreateWithoutRouteInput[] | TripDutyUncheckedCreateWithoutRouteInput[]
    connectOrCreate?: TripDutyCreateOrConnectWithoutRouteInput | TripDutyCreateOrConnectWithoutRouteInput[]
    createMany?: TripDutyCreateManyRouteInputEnvelope
    connect?: TripDutyWhereUniqueInput | TripDutyWhereUniqueInput[]
  }

  export type RouteStopUncheckedCreateNestedManyWithoutRouteInput = {
    create?: XOR<RouteStopCreateWithoutRouteInput, RouteStopUncheckedCreateWithoutRouteInput> | RouteStopCreateWithoutRouteInput[] | RouteStopUncheckedCreateWithoutRouteInput[]
    connectOrCreate?: RouteStopCreateOrConnectWithoutRouteInput | RouteStopCreateOrConnectWithoutRouteInput[]
    createMany?: RouteStopCreateManyRouteInputEnvelope
    connect?: RouteStopWhereUniqueInput | RouteStopWhereUniqueInput[]
  }

  export type TripUncheckedCreateNestedManyWithoutRouteInput = {
    create?: XOR<TripCreateWithoutRouteInput, TripUncheckedCreateWithoutRouteInput> | TripCreateWithoutRouteInput[] | TripUncheckedCreateWithoutRouteInput[]
    connectOrCreate?: TripCreateOrConnectWithoutRouteInput | TripCreateOrConnectWithoutRouteInput[]
    createMany?: TripCreateManyRouteInputEnvelope
    connect?: TripWhereUniqueInput | TripWhereUniqueInput[]
  }

  export type TripDutyUncheckedCreateNestedManyWithoutRouteInput = {
    create?: XOR<TripDutyCreateWithoutRouteInput, TripDutyUncheckedCreateWithoutRouteInput> | TripDutyCreateWithoutRouteInput[] | TripDutyUncheckedCreateWithoutRouteInput[]
    connectOrCreate?: TripDutyCreateOrConnectWithoutRouteInput | TripDutyCreateOrConnectWithoutRouteInput[]
    createMany?: TripDutyCreateManyRouteInputEnvelope
    connect?: TripDutyWhereUniqueInput | TripDutyWhereUniqueInput[]
  }

  export type RouteStopUpdateManyWithoutRouteNestedInput = {
    create?: XOR<RouteStopCreateWithoutRouteInput, RouteStopUncheckedCreateWithoutRouteInput> | RouteStopCreateWithoutRouteInput[] | RouteStopUncheckedCreateWithoutRouteInput[]
    connectOrCreate?: RouteStopCreateOrConnectWithoutRouteInput | RouteStopCreateOrConnectWithoutRouteInput[]
    upsert?: RouteStopUpsertWithWhereUniqueWithoutRouteInput | RouteStopUpsertWithWhereUniqueWithoutRouteInput[]
    createMany?: RouteStopCreateManyRouteInputEnvelope
    set?: RouteStopWhereUniqueInput | RouteStopWhereUniqueInput[]
    disconnect?: RouteStopWhereUniqueInput | RouteStopWhereUniqueInput[]
    delete?: RouteStopWhereUniqueInput | RouteStopWhereUniqueInput[]
    connect?: RouteStopWhereUniqueInput | RouteStopWhereUniqueInput[]
    update?: RouteStopUpdateWithWhereUniqueWithoutRouteInput | RouteStopUpdateWithWhereUniqueWithoutRouteInput[]
    updateMany?: RouteStopUpdateManyWithWhereWithoutRouteInput | RouteStopUpdateManyWithWhereWithoutRouteInput[]
    deleteMany?: RouteStopScalarWhereInput | RouteStopScalarWhereInput[]
  }

  export type TripUpdateManyWithoutRouteNestedInput = {
    create?: XOR<TripCreateWithoutRouteInput, TripUncheckedCreateWithoutRouteInput> | TripCreateWithoutRouteInput[] | TripUncheckedCreateWithoutRouteInput[]
    connectOrCreate?: TripCreateOrConnectWithoutRouteInput | TripCreateOrConnectWithoutRouteInput[]
    upsert?: TripUpsertWithWhereUniqueWithoutRouteInput | TripUpsertWithWhereUniqueWithoutRouteInput[]
    createMany?: TripCreateManyRouteInputEnvelope
    set?: TripWhereUniqueInput | TripWhereUniqueInput[]
    disconnect?: TripWhereUniqueInput | TripWhereUniqueInput[]
    delete?: TripWhereUniqueInput | TripWhereUniqueInput[]
    connect?: TripWhereUniqueInput | TripWhereUniqueInput[]
    update?: TripUpdateWithWhereUniqueWithoutRouteInput | TripUpdateWithWhereUniqueWithoutRouteInput[]
    updateMany?: TripUpdateManyWithWhereWithoutRouteInput | TripUpdateManyWithWhereWithoutRouteInput[]
    deleteMany?: TripScalarWhereInput | TripScalarWhereInput[]
  }

  export type TripDutyUpdateManyWithoutRouteNestedInput = {
    create?: XOR<TripDutyCreateWithoutRouteInput, TripDutyUncheckedCreateWithoutRouteInput> | TripDutyCreateWithoutRouteInput[] | TripDutyUncheckedCreateWithoutRouteInput[]
    connectOrCreate?: TripDutyCreateOrConnectWithoutRouteInput | TripDutyCreateOrConnectWithoutRouteInput[]
    upsert?: TripDutyUpsertWithWhereUniqueWithoutRouteInput | TripDutyUpsertWithWhereUniqueWithoutRouteInput[]
    createMany?: TripDutyCreateManyRouteInputEnvelope
    set?: TripDutyWhereUniqueInput | TripDutyWhereUniqueInput[]
    disconnect?: TripDutyWhereUniqueInput | TripDutyWhereUniqueInput[]
    delete?: TripDutyWhereUniqueInput | TripDutyWhereUniqueInput[]
    connect?: TripDutyWhereUniqueInput | TripDutyWhereUniqueInput[]
    update?: TripDutyUpdateWithWhereUniqueWithoutRouteInput | TripDutyUpdateWithWhereUniqueWithoutRouteInput[]
    updateMany?: TripDutyUpdateManyWithWhereWithoutRouteInput | TripDutyUpdateManyWithWhereWithoutRouteInput[]
    deleteMany?: TripDutyScalarWhereInput | TripDutyScalarWhereInput[]
  }

  export type RouteStopUncheckedUpdateManyWithoutRouteNestedInput = {
    create?: XOR<RouteStopCreateWithoutRouteInput, RouteStopUncheckedCreateWithoutRouteInput> | RouteStopCreateWithoutRouteInput[] | RouteStopUncheckedCreateWithoutRouteInput[]
    connectOrCreate?: RouteStopCreateOrConnectWithoutRouteInput | RouteStopCreateOrConnectWithoutRouteInput[]
    upsert?: RouteStopUpsertWithWhereUniqueWithoutRouteInput | RouteStopUpsertWithWhereUniqueWithoutRouteInput[]
    createMany?: RouteStopCreateManyRouteInputEnvelope
    set?: RouteStopWhereUniqueInput | RouteStopWhereUniqueInput[]
    disconnect?: RouteStopWhereUniqueInput | RouteStopWhereUniqueInput[]
    delete?: RouteStopWhereUniqueInput | RouteStopWhereUniqueInput[]
    connect?: RouteStopWhereUniqueInput | RouteStopWhereUniqueInput[]
    update?: RouteStopUpdateWithWhereUniqueWithoutRouteInput | RouteStopUpdateWithWhereUniqueWithoutRouteInput[]
    updateMany?: RouteStopUpdateManyWithWhereWithoutRouteInput | RouteStopUpdateManyWithWhereWithoutRouteInput[]
    deleteMany?: RouteStopScalarWhereInput | RouteStopScalarWhereInput[]
  }

  export type TripUncheckedUpdateManyWithoutRouteNestedInput = {
    create?: XOR<TripCreateWithoutRouteInput, TripUncheckedCreateWithoutRouteInput> | TripCreateWithoutRouteInput[] | TripUncheckedCreateWithoutRouteInput[]
    connectOrCreate?: TripCreateOrConnectWithoutRouteInput | TripCreateOrConnectWithoutRouteInput[]
    upsert?: TripUpsertWithWhereUniqueWithoutRouteInput | TripUpsertWithWhereUniqueWithoutRouteInput[]
    createMany?: TripCreateManyRouteInputEnvelope
    set?: TripWhereUniqueInput | TripWhereUniqueInput[]
    disconnect?: TripWhereUniqueInput | TripWhereUniqueInput[]
    delete?: TripWhereUniqueInput | TripWhereUniqueInput[]
    connect?: TripWhereUniqueInput | TripWhereUniqueInput[]
    update?: TripUpdateWithWhereUniqueWithoutRouteInput | TripUpdateWithWhereUniqueWithoutRouteInput[]
    updateMany?: TripUpdateManyWithWhereWithoutRouteInput | TripUpdateManyWithWhereWithoutRouteInput[]
    deleteMany?: TripScalarWhereInput | TripScalarWhereInput[]
  }

  export type TripDutyUncheckedUpdateManyWithoutRouteNestedInput = {
    create?: XOR<TripDutyCreateWithoutRouteInput, TripDutyUncheckedCreateWithoutRouteInput> | TripDutyCreateWithoutRouteInput[] | TripDutyUncheckedCreateWithoutRouteInput[]
    connectOrCreate?: TripDutyCreateOrConnectWithoutRouteInput | TripDutyCreateOrConnectWithoutRouteInput[]
    upsert?: TripDutyUpsertWithWhereUniqueWithoutRouteInput | TripDutyUpsertWithWhereUniqueWithoutRouteInput[]
    createMany?: TripDutyCreateManyRouteInputEnvelope
    set?: TripDutyWhereUniqueInput | TripDutyWhereUniqueInput[]
    disconnect?: TripDutyWhereUniqueInput | TripDutyWhereUniqueInput[]
    delete?: TripDutyWhereUniqueInput | TripDutyWhereUniqueInput[]
    connect?: TripDutyWhereUniqueInput | TripDutyWhereUniqueInput[]
    update?: TripDutyUpdateWithWhereUniqueWithoutRouteInput | TripDutyUpdateWithWhereUniqueWithoutRouteInput[]
    updateMany?: TripDutyUpdateManyWithWhereWithoutRouteInput | TripDutyUpdateManyWithWhereWithoutRouteInput[]
    deleteMany?: TripDutyScalarWhereInput | TripDutyScalarWhereInput[]
  }

  export type RouteCreateNestedOneWithoutRouteStopsInput = {
    create?: XOR<RouteCreateWithoutRouteStopsInput, RouteUncheckedCreateWithoutRouteStopsInput>
    connectOrCreate?: RouteCreateOrConnectWithoutRouteStopsInput
    connect?: RouteWhereUniqueInput
  }

  export type StopCreateNestedOneWithoutRouteStopsInput = {
    create?: XOR<StopCreateWithoutRouteStopsInput, StopUncheckedCreateWithoutRouteStopsInput>
    connectOrCreate?: StopCreateOrConnectWithoutRouteStopsInput
    connect?: StopWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type RouteUpdateOneRequiredWithoutRouteStopsNestedInput = {
    create?: XOR<RouteCreateWithoutRouteStopsInput, RouteUncheckedCreateWithoutRouteStopsInput>
    connectOrCreate?: RouteCreateOrConnectWithoutRouteStopsInput
    upsert?: RouteUpsertWithoutRouteStopsInput
    connect?: RouteWhereUniqueInput
    update?: XOR<XOR<RouteUpdateToOneWithWhereWithoutRouteStopsInput, RouteUpdateWithoutRouteStopsInput>, RouteUncheckedUpdateWithoutRouteStopsInput>
  }

  export type StopUpdateOneRequiredWithoutRouteStopsNestedInput = {
    create?: XOR<StopCreateWithoutRouteStopsInput, StopUncheckedCreateWithoutRouteStopsInput>
    connectOrCreate?: StopCreateOrConnectWithoutRouteStopsInput
    upsert?: StopUpsertWithoutRouteStopsInput
    connect?: StopWhereUniqueInput
    update?: XOR<XOR<StopUpdateToOneWithWhereWithoutRouteStopsInput, StopUpdateWithoutRouteStopsInput>, StopUncheckedUpdateWithoutRouteStopsInput>
  }

  export type RouteCreateNestedOneWithoutTripsInput = {
    create?: XOR<RouteCreateWithoutTripsInput, RouteUncheckedCreateWithoutTripsInput>
    connectOrCreate?: RouteCreateOrConnectWithoutTripsInput
    connect?: RouteWhereUniqueInput
  }

  export type DriverCreateNestedOneWithoutTripsInput = {
    create?: XOR<DriverCreateWithoutTripsInput, DriverUncheckedCreateWithoutTripsInput>
    connectOrCreate?: DriverCreateOrConnectWithoutTripsInput
    connect?: DriverWhereUniqueInput
  }

  export type VehicleCreateNestedOneWithoutTripsInput = {
    create?: XOR<VehicleCreateWithoutTripsInput, VehicleUncheckedCreateWithoutTripsInput>
    connectOrCreate?: VehicleCreateOrConnectWithoutTripsInput
    connect?: VehicleWhereUniqueInput
  }

  export type TripStopCreateNestedManyWithoutTripInput = {
    create?: XOR<TripStopCreateWithoutTripInput, TripStopUncheckedCreateWithoutTripInput> | TripStopCreateWithoutTripInput[] | TripStopUncheckedCreateWithoutTripInput[]
    connectOrCreate?: TripStopCreateOrConnectWithoutTripInput | TripStopCreateOrConnectWithoutTripInput[]
    createMany?: TripStopCreateManyTripInputEnvelope
    connect?: TripStopWhereUniqueInput | TripStopWhereUniqueInput[]
  }

  export type TripStopUncheckedCreateNestedManyWithoutTripInput = {
    create?: XOR<TripStopCreateWithoutTripInput, TripStopUncheckedCreateWithoutTripInput> | TripStopCreateWithoutTripInput[] | TripStopUncheckedCreateWithoutTripInput[]
    connectOrCreate?: TripStopCreateOrConnectWithoutTripInput | TripStopCreateOrConnectWithoutTripInput[]
    createMany?: TripStopCreateManyTripInputEnvelope
    connect?: TripStopWhereUniqueInput | TripStopWhereUniqueInput[]
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type RouteUpdateOneRequiredWithoutTripsNestedInput = {
    create?: XOR<RouteCreateWithoutTripsInput, RouteUncheckedCreateWithoutTripsInput>
    connectOrCreate?: RouteCreateOrConnectWithoutTripsInput
    upsert?: RouteUpsertWithoutTripsInput
    connect?: RouteWhereUniqueInput
    update?: XOR<XOR<RouteUpdateToOneWithWhereWithoutTripsInput, RouteUpdateWithoutTripsInput>, RouteUncheckedUpdateWithoutTripsInput>
  }

  export type DriverUpdateOneRequiredWithoutTripsNestedInput = {
    create?: XOR<DriverCreateWithoutTripsInput, DriverUncheckedCreateWithoutTripsInput>
    connectOrCreate?: DriverCreateOrConnectWithoutTripsInput
    upsert?: DriverUpsertWithoutTripsInput
    connect?: DriverWhereUniqueInput
    update?: XOR<XOR<DriverUpdateToOneWithWhereWithoutTripsInput, DriverUpdateWithoutTripsInput>, DriverUncheckedUpdateWithoutTripsInput>
  }

  export type VehicleUpdateOneRequiredWithoutTripsNestedInput = {
    create?: XOR<VehicleCreateWithoutTripsInput, VehicleUncheckedCreateWithoutTripsInput>
    connectOrCreate?: VehicleCreateOrConnectWithoutTripsInput
    upsert?: VehicleUpsertWithoutTripsInput
    connect?: VehicleWhereUniqueInput
    update?: XOR<XOR<VehicleUpdateToOneWithWhereWithoutTripsInput, VehicleUpdateWithoutTripsInput>, VehicleUncheckedUpdateWithoutTripsInput>
  }

  export type TripStopUpdateManyWithoutTripNestedInput = {
    create?: XOR<TripStopCreateWithoutTripInput, TripStopUncheckedCreateWithoutTripInput> | TripStopCreateWithoutTripInput[] | TripStopUncheckedCreateWithoutTripInput[]
    connectOrCreate?: TripStopCreateOrConnectWithoutTripInput | TripStopCreateOrConnectWithoutTripInput[]
    upsert?: TripStopUpsertWithWhereUniqueWithoutTripInput | TripStopUpsertWithWhereUniqueWithoutTripInput[]
    createMany?: TripStopCreateManyTripInputEnvelope
    set?: TripStopWhereUniqueInput | TripStopWhereUniqueInput[]
    disconnect?: TripStopWhereUniqueInput | TripStopWhereUniqueInput[]
    delete?: TripStopWhereUniqueInput | TripStopWhereUniqueInput[]
    connect?: TripStopWhereUniqueInput | TripStopWhereUniqueInput[]
    update?: TripStopUpdateWithWhereUniqueWithoutTripInput | TripStopUpdateWithWhereUniqueWithoutTripInput[]
    updateMany?: TripStopUpdateManyWithWhereWithoutTripInput | TripStopUpdateManyWithWhereWithoutTripInput[]
    deleteMany?: TripStopScalarWhereInput | TripStopScalarWhereInput[]
  }

  export type TripStopUncheckedUpdateManyWithoutTripNestedInput = {
    create?: XOR<TripStopCreateWithoutTripInput, TripStopUncheckedCreateWithoutTripInput> | TripStopCreateWithoutTripInput[] | TripStopUncheckedCreateWithoutTripInput[]
    connectOrCreate?: TripStopCreateOrConnectWithoutTripInput | TripStopCreateOrConnectWithoutTripInput[]
    upsert?: TripStopUpsertWithWhereUniqueWithoutTripInput | TripStopUpsertWithWhereUniqueWithoutTripInput[]
    createMany?: TripStopCreateManyTripInputEnvelope
    set?: TripStopWhereUniqueInput | TripStopWhereUniqueInput[]
    disconnect?: TripStopWhereUniqueInput | TripStopWhereUniqueInput[]
    delete?: TripStopWhereUniqueInput | TripStopWhereUniqueInput[]
    connect?: TripStopWhereUniqueInput | TripStopWhereUniqueInput[]
    update?: TripStopUpdateWithWhereUniqueWithoutTripInput | TripStopUpdateWithWhereUniqueWithoutTripInput[]
    updateMany?: TripStopUpdateManyWithWhereWithoutTripInput | TripStopUpdateManyWithWhereWithoutTripInput[]
    deleteMany?: TripStopScalarWhereInput | TripStopScalarWhereInput[]
  }

  export type TripCreateNestedOneWithoutTripStopsInput = {
    create?: XOR<TripCreateWithoutTripStopsInput, TripUncheckedCreateWithoutTripStopsInput>
    connectOrCreate?: TripCreateOrConnectWithoutTripStopsInput
    connect?: TripWhereUniqueInput
  }

  export type StopCreateNestedOneWithoutTripStopsInput = {
    create?: XOR<StopCreateWithoutTripStopsInput, StopUncheckedCreateWithoutTripStopsInput>
    connectOrCreate?: StopCreateOrConnectWithoutTripStopsInput
    connect?: StopWhereUniqueInput
  }

  export type TripUpdateOneRequiredWithoutTripStopsNestedInput = {
    create?: XOR<TripCreateWithoutTripStopsInput, TripUncheckedCreateWithoutTripStopsInput>
    connectOrCreate?: TripCreateOrConnectWithoutTripStopsInput
    upsert?: TripUpsertWithoutTripStopsInput
    connect?: TripWhereUniqueInput
    update?: XOR<XOR<TripUpdateToOneWithWhereWithoutTripStopsInput, TripUpdateWithoutTripStopsInput>, TripUncheckedUpdateWithoutTripStopsInput>
  }

  export type StopUpdateOneRequiredWithoutTripStopsNestedInput = {
    create?: XOR<StopCreateWithoutTripStopsInput, StopUncheckedCreateWithoutTripStopsInput>
    connectOrCreate?: StopCreateOrConnectWithoutTripStopsInput
    upsert?: StopUpsertWithoutTripStopsInput
    connect?: StopWhereUniqueInput
    update?: XOR<XOR<StopUpdateToOneWithWhereWithoutTripStopsInput, StopUpdateWithoutTripStopsInput>, StopUncheckedUpdateWithoutTripStopsInput>
  }

  export type VehicleCreateNestedOneWithoutTelemetryInput = {
    create?: XOR<VehicleCreateWithoutTelemetryInput, VehicleUncheckedCreateWithoutTelemetryInput>
    connectOrCreate?: VehicleCreateOrConnectWithoutTelemetryInput
    connect?: VehicleWhereUniqueInput
  }

  export type VehicleUpdateOneRequiredWithoutTelemetryNestedInput = {
    create?: XOR<VehicleCreateWithoutTelemetryInput, VehicleUncheckedCreateWithoutTelemetryInput>
    connectOrCreate?: VehicleCreateOrConnectWithoutTelemetryInput
    upsert?: VehicleUpsertWithoutTelemetryInput
    connect?: VehicleWhereUniqueInput
    update?: XOR<XOR<VehicleUpdateToOneWithWhereWithoutTelemetryInput, VehicleUpdateWithoutTelemetryInput>, VehicleUncheckedUpdateWithoutTelemetryInput>
  }

  export type VehicleCreateNestedOneWithoutTelemetryHistoryInput = {
    create?: XOR<VehicleCreateWithoutTelemetryHistoryInput, VehicleUncheckedCreateWithoutTelemetryHistoryInput>
    connectOrCreate?: VehicleCreateOrConnectWithoutTelemetryHistoryInput
    connect?: VehicleWhereUniqueInput
  }

  export type VehicleUpdateOneRequiredWithoutTelemetryHistoryNestedInput = {
    create?: XOR<VehicleCreateWithoutTelemetryHistoryInput, VehicleUncheckedCreateWithoutTelemetryHistoryInput>
    connectOrCreate?: VehicleCreateOrConnectWithoutTelemetryHistoryInput
    upsert?: VehicleUpsertWithoutTelemetryHistoryInput
    connect?: VehicleWhereUniqueInput
    update?: XOR<XOR<VehicleUpdateToOneWithWhereWithoutTelemetryHistoryInput, VehicleUpdateWithoutTelemetryHistoryInput>, VehicleUncheckedUpdateWithoutTelemetryHistoryInput>
  }

  export type VehicleCreateNestedOneWithoutShiftsInput = {
    create?: XOR<VehicleCreateWithoutShiftsInput, VehicleUncheckedCreateWithoutShiftsInput>
    connectOrCreate?: VehicleCreateOrConnectWithoutShiftsInput
    connect?: VehicleWhereUniqueInput
  }

  export type DriverCreateNestedOneWithoutShiftsInput = {
    create?: XOR<DriverCreateWithoutShiftsInput, DriverUncheckedCreateWithoutShiftsInput>
    connectOrCreate?: DriverCreateOrConnectWithoutShiftsInput
    connect?: DriverWhereUniqueInput
  }

  export type VehicleUpdateOneRequiredWithoutShiftsNestedInput = {
    create?: XOR<VehicleCreateWithoutShiftsInput, VehicleUncheckedCreateWithoutShiftsInput>
    connectOrCreate?: VehicleCreateOrConnectWithoutShiftsInput
    upsert?: VehicleUpsertWithoutShiftsInput
    connect?: VehicleWhereUniqueInput
    update?: XOR<XOR<VehicleUpdateToOneWithWhereWithoutShiftsInput, VehicleUpdateWithoutShiftsInput>, VehicleUncheckedUpdateWithoutShiftsInput>
  }

  export type DriverUpdateOneRequiredWithoutShiftsNestedInput = {
    create?: XOR<DriverCreateWithoutShiftsInput, DriverUncheckedCreateWithoutShiftsInput>
    connectOrCreate?: DriverCreateOrConnectWithoutShiftsInput
    upsert?: DriverUpsertWithoutShiftsInput
    connect?: DriverWhereUniqueInput
    update?: XOR<XOR<DriverUpdateToOneWithWhereWithoutShiftsInput, DriverUpdateWithoutShiftsInput>, DriverUncheckedUpdateWithoutShiftsInput>
  }

  export type DutyTemplateCreateNestedManyWithoutScheduleInput = {
    create?: XOR<DutyTemplateCreateWithoutScheduleInput, DutyTemplateUncheckedCreateWithoutScheduleInput> | DutyTemplateCreateWithoutScheduleInput[] | DutyTemplateUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: DutyTemplateCreateOrConnectWithoutScheduleInput | DutyTemplateCreateOrConnectWithoutScheduleInput[]
    createMany?: DutyTemplateCreateManyScheduleInputEnvelope
    connect?: DutyTemplateWhereUniqueInput | DutyTemplateWhereUniqueInput[]
  }

  export type VehicleBlockTemplateCreateNestedManyWithoutScheduleInput = {
    create?: XOR<VehicleBlockTemplateCreateWithoutScheduleInput, VehicleBlockTemplateUncheckedCreateWithoutScheduleInput> | VehicleBlockTemplateCreateWithoutScheduleInput[] | VehicleBlockTemplateUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: VehicleBlockTemplateCreateOrConnectWithoutScheduleInput | VehicleBlockTemplateCreateOrConnectWithoutScheduleInput[]
    createMany?: VehicleBlockTemplateCreateManyScheduleInputEnvelope
    connect?: VehicleBlockTemplateWhereUniqueInput | VehicleBlockTemplateWhereUniqueInput[]
  }

  export type DriverRunTemplateCreateNestedManyWithoutScheduleInput = {
    create?: XOR<DriverRunTemplateCreateWithoutScheduleInput, DriverRunTemplateUncheckedCreateWithoutScheduleInput> | DriverRunTemplateCreateWithoutScheduleInput[] | DriverRunTemplateUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: DriverRunTemplateCreateOrConnectWithoutScheduleInput | DriverRunTemplateCreateOrConnectWithoutScheduleInput[]
    createMany?: DriverRunTemplateCreateManyScheduleInputEnvelope
    connect?: DriverRunTemplateWhereUniqueInput | DriverRunTemplateWhereUniqueInput[]
  }

  export type DutyTemplateUncheckedCreateNestedManyWithoutScheduleInput = {
    create?: XOR<DutyTemplateCreateWithoutScheduleInput, DutyTemplateUncheckedCreateWithoutScheduleInput> | DutyTemplateCreateWithoutScheduleInput[] | DutyTemplateUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: DutyTemplateCreateOrConnectWithoutScheduleInput | DutyTemplateCreateOrConnectWithoutScheduleInput[]
    createMany?: DutyTemplateCreateManyScheduleInputEnvelope
    connect?: DutyTemplateWhereUniqueInput | DutyTemplateWhereUniqueInput[]
  }

  export type VehicleBlockTemplateUncheckedCreateNestedManyWithoutScheduleInput = {
    create?: XOR<VehicleBlockTemplateCreateWithoutScheduleInput, VehicleBlockTemplateUncheckedCreateWithoutScheduleInput> | VehicleBlockTemplateCreateWithoutScheduleInput[] | VehicleBlockTemplateUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: VehicleBlockTemplateCreateOrConnectWithoutScheduleInput | VehicleBlockTemplateCreateOrConnectWithoutScheduleInput[]
    createMany?: VehicleBlockTemplateCreateManyScheduleInputEnvelope
    connect?: VehicleBlockTemplateWhereUniqueInput | VehicleBlockTemplateWhereUniqueInput[]
  }

  export type DriverRunTemplateUncheckedCreateNestedManyWithoutScheduleInput = {
    create?: XOR<DriverRunTemplateCreateWithoutScheduleInput, DriverRunTemplateUncheckedCreateWithoutScheduleInput> | DriverRunTemplateCreateWithoutScheduleInput[] | DriverRunTemplateUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: DriverRunTemplateCreateOrConnectWithoutScheduleInput | DriverRunTemplateCreateOrConnectWithoutScheduleInput[]
    createMany?: DriverRunTemplateCreateManyScheduleInputEnvelope
    connect?: DriverRunTemplateWhereUniqueInput | DriverRunTemplateWhereUniqueInput[]
  }

  export type DutyTemplateUpdateManyWithoutScheduleNestedInput = {
    create?: XOR<DutyTemplateCreateWithoutScheduleInput, DutyTemplateUncheckedCreateWithoutScheduleInput> | DutyTemplateCreateWithoutScheduleInput[] | DutyTemplateUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: DutyTemplateCreateOrConnectWithoutScheduleInput | DutyTemplateCreateOrConnectWithoutScheduleInput[]
    upsert?: DutyTemplateUpsertWithWhereUniqueWithoutScheduleInput | DutyTemplateUpsertWithWhereUniqueWithoutScheduleInput[]
    createMany?: DutyTemplateCreateManyScheduleInputEnvelope
    set?: DutyTemplateWhereUniqueInput | DutyTemplateWhereUniqueInput[]
    disconnect?: DutyTemplateWhereUniqueInput | DutyTemplateWhereUniqueInput[]
    delete?: DutyTemplateWhereUniqueInput | DutyTemplateWhereUniqueInput[]
    connect?: DutyTemplateWhereUniqueInput | DutyTemplateWhereUniqueInput[]
    update?: DutyTemplateUpdateWithWhereUniqueWithoutScheduleInput | DutyTemplateUpdateWithWhereUniqueWithoutScheduleInput[]
    updateMany?: DutyTemplateUpdateManyWithWhereWithoutScheduleInput | DutyTemplateUpdateManyWithWhereWithoutScheduleInput[]
    deleteMany?: DutyTemplateScalarWhereInput | DutyTemplateScalarWhereInput[]
  }

  export type VehicleBlockTemplateUpdateManyWithoutScheduleNestedInput = {
    create?: XOR<VehicleBlockTemplateCreateWithoutScheduleInput, VehicleBlockTemplateUncheckedCreateWithoutScheduleInput> | VehicleBlockTemplateCreateWithoutScheduleInput[] | VehicleBlockTemplateUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: VehicleBlockTemplateCreateOrConnectWithoutScheduleInput | VehicleBlockTemplateCreateOrConnectWithoutScheduleInput[]
    upsert?: VehicleBlockTemplateUpsertWithWhereUniqueWithoutScheduleInput | VehicleBlockTemplateUpsertWithWhereUniqueWithoutScheduleInput[]
    createMany?: VehicleBlockTemplateCreateManyScheduleInputEnvelope
    set?: VehicleBlockTemplateWhereUniqueInput | VehicleBlockTemplateWhereUniqueInput[]
    disconnect?: VehicleBlockTemplateWhereUniqueInput | VehicleBlockTemplateWhereUniqueInput[]
    delete?: VehicleBlockTemplateWhereUniqueInput | VehicleBlockTemplateWhereUniqueInput[]
    connect?: VehicleBlockTemplateWhereUniqueInput | VehicleBlockTemplateWhereUniqueInput[]
    update?: VehicleBlockTemplateUpdateWithWhereUniqueWithoutScheduleInput | VehicleBlockTemplateUpdateWithWhereUniqueWithoutScheduleInput[]
    updateMany?: VehicleBlockTemplateUpdateManyWithWhereWithoutScheduleInput | VehicleBlockTemplateUpdateManyWithWhereWithoutScheduleInput[]
    deleteMany?: VehicleBlockTemplateScalarWhereInput | VehicleBlockTemplateScalarWhereInput[]
  }

  export type DriverRunTemplateUpdateManyWithoutScheduleNestedInput = {
    create?: XOR<DriverRunTemplateCreateWithoutScheduleInput, DriverRunTemplateUncheckedCreateWithoutScheduleInput> | DriverRunTemplateCreateWithoutScheduleInput[] | DriverRunTemplateUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: DriverRunTemplateCreateOrConnectWithoutScheduleInput | DriverRunTemplateCreateOrConnectWithoutScheduleInput[]
    upsert?: DriverRunTemplateUpsertWithWhereUniqueWithoutScheduleInput | DriverRunTemplateUpsertWithWhereUniqueWithoutScheduleInput[]
    createMany?: DriverRunTemplateCreateManyScheduleInputEnvelope
    set?: DriverRunTemplateWhereUniqueInput | DriverRunTemplateWhereUniqueInput[]
    disconnect?: DriverRunTemplateWhereUniqueInput | DriverRunTemplateWhereUniqueInput[]
    delete?: DriverRunTemplateWhereUniqueInput | DriverRunTemplateWhereUniqueInput[]
    connect?: DriverRunTemplateWhereUniqueInput | DriverRunTemplateWhereUniqueInput[]
    update?: DriverRunTemplateUpdateWithWhereUniqueWithoutScheduleInput | DriverRunTemplateUpdateWithWhereUniqueWithoutScheduleInput[]
    updateMany?: DriverRunTemplateUpdateManyWithWhereWithoutScheduleInput | DriverRunTemplateUpdateManyWithWhereWithoutScheduleInput[]
    deleteMany?: DriverRunTemplateScalarWhereInput | DriverRunTemplateScalarWhereInput[]
  }

  export type DutyTemplateUncheckedUpdateManyWithoutScheduleNestedInput = {
    create?: XOR<DutyTemplateCreateWithoutScheduleInput, DutyTemplateUncheckedCreateWithoutScheduleInput> | DutyTemplateCreateWithoutScheduleInput[] | DutyTemplateUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: DutyTemplateCreateOrConnectWithoutScheduleInput | DutyTemplateCreateOrConnectWithoutScheduleInput[]
    upsert?: DutyTemplateUpsertWithWhereUniqueWithoutScheduleInput | DutyTemplateUpsertWithWhereUniqueWithoutScheduleInput[]
    createMany?: DutyTemplateCreateManyScheduleInputEnvelope
    set?: DutyTemplateWhereUniqueInput | DutyTemplateWhereUniqueInput[]
    disconnect?: DutyTemplateWhereUniqueInput | DutyTemplateWhereUniqueInput[]
    delete?: DutyTemplateWhereUniqueInput | DutyTemplateWhereUniqueInput[]
    connect?: DutyTemplateWhereUniqueInput | DutyTemplateWhereUniqueInput[]
    update?: DutyTemplateUpdateWithWhereUniqueWithoutScheduleInput | DutyTemplateUpdateWithWhereUniqueWithoutScheduleInput[]
    updateMany?: DutyTemplateUpdateManyWithWhereWithoutScheduleInput | DutyTemplateUpdateManyWithWhereWithoutScheduleInput[]
    deleteMany?: DutyTemplateScalarWhereInput | DutyTemplateScalarWhereInput[]
  }

  export type VehicleBlockTemplateUncheckedUpdateManyWithoutScheduleNestedInput = {
    create?: XOR<VehicleBlockTemplateCreateWithoutScheduleInput, VehicleBlockTemplateUncheckedCreateWithoutScheduleInput> | VehicleBlockTemplateCreateWithoutScheduleInput[] | VehicleBlockTemplateUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: VehicleBlockTemplateCreateOrConnectWithoutScheduleInput | VehicleBlockTemplateCreateOrConnectWithoutScheduleInput[]
    upsert?: VehicleBlockTemplateUpsertWithWhereUniqueWithoutScheduleInput | VehicleBlockTemplateUpsertWithWhereUniqueWithoutScheduleInput[]
    createMany?: VehicleBlockTemplateCreateManyScheduleInputEnvelope
    set?: VehicleBlockTemplateWhereUniqueInput | VehicleBlockTemplateWhereUniqueInput[]
    disconnect?: VehicleBlockTemplateWhereUniqueInput | VehicleBlockTemplateWhereUniqueInput[]
    delete?: VehicleBlockTemplateWhereUniqueInput | VehicleBlockTemplateWhereUniqueInput[]
    connect?: VehicleBlockTemplateWhereUniqueInput | VehicleBlockTemplateWhereUniqueInput[]
    update?: VehicleBlockTemplateUpdateWithWhereUniqueWithoutScheduleInput | VehicleBlockTemplateUpdateWithWhereUniqueWithoutScheduleInput[]
    updateMany?: VehicleBlockTemplateUpdateManyWithWhereWithoutScheduleInput | VehicleBlockTemplateUpdateManyWithWhereWithoutScheduleInput[]
    deleteMany?: VehicleBlockTemplateScalarWhereInput | VehicleBlockTemplateScalarWhereInput[]
  }

  export type DriverRunTemplateUncheckedUpdateManyWithoutScheduleNestedInput = {
    create?: XOR<DriverRunTemplateCreateWithoutScheduleInput, DriverRunTemplateUncheckedCreateWithoutScheduleInput> | DriverRunTemplateCreateWithoutScheduleInput[] | DriverRunTemplateUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: DriverRunTemplateCreateOrConnectWithoutScheduleInput | DriverRunTemplateCreateOrConnectWithoutScheduleInput[]
    upsert?: DriverRunTemplateUpsertWithWhereUniqueWithoutScheduleInput | DriverRunTemplateUpsertWithWhereUniqueWithoutScheduleInput[]
    createMany?: DriverRunTemplateCreateManyScheduleInputEnvelope
    set?: DriverRunTemplateWhereUniqueInput | DriverRunTemplateWhereUniqueInput[]
    disconnect?: DriverRunTemplateWhereUniqueInput | DriverRunTemplateWhereUniqueInput[]
    delete?: DriverRunTemplateWhereUniqueInput | DriverRunTemplateWhereUniqueInput[]
    connect?: DriverRunTemplateWhereUniqueInput | DriverRunTemplateWhereUniqueInput[]
    update?: DriverRunTemplateUpdateWithWhereUniqueWithoutScheduleInput | DriverRunTemplateUpdateWithWhereUniqueWithoutScheduleInput[]
    updateMany?: DriverRunTemplateUpdateManyWithWhereWithoutScheduleInput | DriverRunTemplateUpdateManyWithWhereWithoutScheduleInput[]
    deleteMany?: DriverRunTemplateScalarWhereInput | DriverRunTemplateScalarWhereInput[]
  }

  export type ServiceScheduleCreateNestedOneWithoutVehicleBlockTemplatesInput = {
    create?: XOR<ServiceScheduleCreateWithoutVehicleBlockTemplatesInput, ServiceScheduleUncheckedCreateWithoutVehicleBlockTemplatesInput>
    connectOrCreate?: ServiceScheduleCreateOrConnectWithoutVehicleBlockTemplatesInput
    connect?: ServiceScheduleWhereUniqueInput
  }

  export type DutyTemplateCreateNestedManyWithoutVehicleBlockTemplateInput = {
    create?: XOR<DutyTemplateCreateWithoutVehicleBlockTemplateInput, DutyTemplateUncheckedCreateWithoutVehicleBlockTemplateInput> | DutyTemplateCreateWithoutVehicleBlockTemplateInput[] | DutyTemplateUncheckedCreateWithoutVehicleBlockTemplateInput[]
    connectOrCreate?: DutyTemplateCreateOrConnectWithoutVehicleBlockTemplateInput | DutyTemplateCreateOrConnectWithoutVehicleBlockTemplateInput[]
    createMany?: DutyTemplateCreateManyVehicleBlockTemplateInputEnvelope
    connect?: DutyTemplateWhereUniqueInput | DutyTemplateWhereUniqueInput[]
  }

  export type VehicleBlockCreateNestedManyWithoutVehicleBlockTemplateInput = {
    create?: XOR<VehicleBlockCreateWithoutVehicleBlockTemplateInput, VehicleBlockUncheckedCreateWithoutVehicleBlockTemplateInput> | VehicleBlockCreateWithoutVehicleBlockTemplateInput[] | VehicleBlockUncheckedCreateWithoutVehicleBlockTemplateInput[]
    connectOrCreate?: VehicleBlockCreateOrConnectWithoutVehicleBlockTemplateInput | VehicleBlockCreateOrConnectWithoutVehicleBlockTemplateInput[]
    createMany?: VehicleBlockCreateManyVehicleBlockTemplateInputEnvelope
    connect?: VehicleBlockWhereUniqueInput | VehicleBlockWhereUniqueInput[]
  }

  export type DutyTemplateUncheckedCreateNestedManyWithoutVehicleBlockTemplateInput = {
    create?: XOR<DutyTemplateCreateWithoutVehicleBlockTemplateInput, DutyTemplateUncheckedCreateWithoutVehicleBlockTemplateInput> | DutyTemplateCreateWithoutVehicleBlockTemplateInput[] | DutyTemplateUncheckedCreateWithoutVehicleBlockTemplateInput[]
    connectOrCreate?: DutyTemplateCreateOrConnectWithoutVehicleBlockTemplateInput | DutyTemplateCreateOrConnectWithoutVehicleBlockTemplateInput[]
    createMany?: DutyTemplateCreateManyVehicleBlockTemplateInputEnvelope
    connect?: DutyTemplateWhereUniqueInput | DutyTemplateWhereUniqueInput[]
  }

  export type VehicleBlockUncheckedCreateNestedManyWithoutVehicleBlockTemplateInput = {
    create?: XOR<VehicleBlockCreateWithoutVehicleBlockTemplateInput, VehicleBlockUncheckedCreateWithoutVehicleBlockTemplateInput> | VehicleBlockCreateWithoutVehicleBlockTemplateInput[] | VehicleBlockUncheckedCreateWithoutVehicleBlockTemplateInput[]
    connectOrCreate?: VehicleBlockCreateOrConnectWithoutVehicleBlockTemplateInput | VehicleBlockCreateOrConnectWithoutVehicleBlockTemplateInput[]
    createMany?: VehicleBlockCreateManyVehicleBlockTemplateInputEnvelope
    connect?: VehicleBlockWhereUniqueInput | VehicleBlockWhereUniqueInput[]
  }

  export type ServiceScheduleUpdateOneRequiredWithoutVehicleBlockTemplatesNestedInput = {
    create?: XOR<ServiceScheduleCreateWithoutVehicleBlockTemplatesInput, ServiceScheduleUncheckedCreateWithoutVehicleBlockTemplatesInput>
    connectOrCreate?: ServiceScheduleCreateOrConnectWithoutVehicleBlockTemplatesInput
    upsert?: ServiceScheduleUpsertWithoutVehicleBlockTemplatesInput
    connect?: ServiceScheduleWhereUniqueInput
    update?: XOR<XOR<ServiceScheduleUpdateToOneWithWhereWithoutVehicleBlockTemplatesInput, ServiceScheduleUpdateWithoutVehicleBlockTemplatesInput>, ServiceScheduleUncheckedUpdateWithoutVehicleBlockTemplatesInput>
  }

  export type DutyTemplateUpdateManyWithoutVehicleBlockTemplateNestedInput = {
    create?: XOR<DutyTemplateCreateWithoutVehicleBlockTemplateInput, DutyTemplateUncheckedCreateWithoutVehicleBlockTemplateInput> | DutyTemplateCreateWithoutVehicleBlockTemplateInput[] | DutyTemplateUncheckedCreateWithoutVehicleBlockTemplateInput[]
    connectOrCreate?: DutyTemplateCreateOrConnectWithoutVehicleBlockTemplateInput | DutyTemplateCreateOrConnectWithoutVehicleBlockTemplateInput[]
    upsert?: DutyTemplateUpsertWithWhereUniqueWithoutVehicleBlockTemplateInput | DutyTemplateUpsertWithWhereUniqueWithoutVehicleBlockTemplateInput[]
    createMany?: DutyTemplateCreateManyVehicleBlockTemplateInputEnvelope
    set?: DutyTemplateWhereUniqueInput | DutyTemplateWhereUniqueInput[]
    disconnect?: DutyTemplateWhereUniqueInput | DutyTemplateWhereUniqueInput[]
    delete?: DutyTemplateWhereUniqueInput | DutyTemplateWhereUniqueInput[]
    connect?: DutyTemplateWhereUniqueInput | DutyTemplateWhereUniqueInput[]
    update?: DutyTemplateUpdateWithWhereUniqueWithoutVehicleBlockTemplateInput | DutyTemplateUpdateWithWhereUniqueWithoutVehicleBlockTemplateInput[]
    updateMany?: DutyTemplateUpdateManyWithWhereWithoutVehicleBlockTemplateInput | DutyTemplateUpdateManyWithWhereWithoutVehicleBlockTemplateInput[]
    deleteMany?: DutyTemplateScalarWhereInput | DutyTemplateScalarWhereInput[]
  }

  export type VehicleBlockUpdateManyWithoutVehicleBlockTemplateNestedInput = {
    create?: XOR<VehicleBlockCreateWithoutVehicleBlockTemplateInput, VehicleBlockUncheckedCreateWithoutVehicleBlockTemplateInput> | VehicleBlockCreateWithoutVehicleBlockTemplateInput[] | VehicleBlockUncheckedCreateWithoutVehicleBlockTemplateInput[]
    connectOrCreate?: VehicleBlockCreateOrConnectWithoutVehicleBlockTemplateInput | VehicleBlockCreateOrConnectWithoutVehicleBlockTemplateInput[]
    upsert?: VehicleBlockUpsertWithWhereUniqueWithoutVehicleBlockTemplateInput | VehicleBlockUpsertWithWhereUniqueWithoutVehicleBlockTemplateInput[]
    createMany?: VehicleBlockCreateManyVehicleBlockTemplateInputEnvelope
    set?: VehicleBlockWhereUniqueInput | VehicleBlockWhereUniqueInput[]
    disconnect?: VehicleBlockWhereUniqueInput | VehicleBlockWhereUniqueInput[]
    delete?: VehicleBlockWhereUniqueInput | VehicleBlockWhereUniqueInput[]
    connect?: VehicleBlockWhereUniqueInput | VehicleBlockWhereUniqueInput[]
    update?: VehicleBlockUpdateWithWhereUniqueWithoutVehicleBlockTemplateInput | VehicleBlockUpdateWithWhereUniqueWithoutVehicleBlockTemplateInput[]
    updateMany?: VehicleBlockUpdateManyWithWhereWithoutVehicleBlockTemplateInput | VehicleBlockUpdateManyWithWhereWithoutVehicleBlockTemplateInput[]
    deleteMany?: VehicleBlockScalarWhereInput | VehicleBlockScalarWhereInput[]
  }

  export type DutyTemplateUncheckedUpdateManyWithoutVehicleBlockTemplateNestedInput = {
    create?: XOR<DutyTemplateCreateWithoutVehicleBlockTemplateInput, DutyTemplateUncheckedCreateWithoutVehicleBlockTemplateInput> | DutyTemplateCreateWithoutVehicleBlockTemplateInput[] | DutyTemplateUncheckedCreateWithoutVehicleBlockTemplateInput[]
    connectOrCreate?: DutyTemplateCreateOrConnectWithoutVehicleBlockTemplateInput | DutyTemplateCreateOrConnectWithoutVehicleBlockTemplateInput[]
    upsert?: DutyTemplateUpsertWithWhereUniqueWithoutVehicleBlockTemplateInput | DutyTemplateUpsertWithWhereUniqueWithoutVehicleBlockTemplateInput[]
    createMany?: DutyTemplateCreateManyVehicleBlockTemplateInputEnvelope
    set?: DutyTemplateWhereUniqueInput | DutyTemplateWhereUniqueInput[]
    disconnect?: DutyTemplateWhereUniqueInput | DutyTemplateWhereUniqueInput[]
    delete?: DutyTemplateWhereUniqueInput | DutyTemplateWhereUniqueInput[]
    connect?: DutyTemplateWhereUniqueInput | DutyTemplateWhereUniqueInput[]
    update?: DutyTemplateUpdateWithWhereUniqueWithoutVehicleBlockTemplateInput | DutyTemplateUpdateWithWhereUniqueWithoutVehicleBlockTemplateInput[]
    updateMany?: DutyTemplateUpdateManyWithWhereWithoutVehicleBlockTemplateInput | DutyTemplateUpdateManyWithWhereWithoutVehicleBlockTemplateInput[]
    deleteMany?: DutyTemplateScalarWhereInput | DutyTemplateScalarWhereInput[]
  }

  export type VehicleBlockUncheckedUpdateManyWithoutVehicleBlockTemplateNestedInput = {
    create?: XOR<VehicleBlockCreateWithoutVehicleBlockTemplateInput, VehicleBlockUncheckedCreateWithoutVehicleBlockTemplateInput> | VehicleBlockCreateWithoutVehicleBlockTemplateInput[] | VehicleBlockUncheckedCreateWithoutVehicleBlockTemplateInput[]
    connectOrCreate?: VehicleBlockCreateOrConnectWithoutVehicleBlockTemplateInput | VehicleBlockCreateOrConnectWithoutVehicleBlockTemplateInput[]
    upsert?: VehicleBlockUpsertWithWhereUniqueWithoutVehicleBlockTemplateInput | VehicleBlockUpsertWithWhereUniqueWithoutVehicleBlockTemplateInput[]
    createMany?: VehicleBlockCreateManyVehicleBlockTemplateInputEnvelope
    set?: VehicleBlockWhereUniqueInput | VehicleBlockWhereUniqueInput[]
    disconnect?: VehicleBlockWhereUniqueInput | VehicleBlockWhereUniqueInput[]
    delete?: VehicleBlockWhereUniqueInput | VehicleBlockWhereUniqueInput[]
    connect?: VehicleBlockWhereUniqueInput | VehicleBlockWhereUniqueInput[]
    update?: VehicleBlockUpdateWithWhereUniqueWithoutVehicleBlockTemplateInput | VehicleBlockUpdateWithWhereUniqueWithoutVehicleBlockTemplateInput[]
    updateMany?: VehicleBlockUpdateManyWithWhereWithoutVehicleBlockTemplateInput | VehicleBlockUpdateManyWithWhereWithoutVehicleBlockTemplateInput[]
    deleteMany?: VehicleBlockScalarWhereInput | VehicleBlockScalarWhereInput[]
  }

  export type ServiceScheduleCreateNestedOneWithoutDriverRunTemplatesInput = {
    create?: XOR<ServiceScheduleCreateWithoutDriverRunTemplatesInput, ServiceScheduleUncheckedCreateWithoutDriverRunTemplatesInput>
    connectOrCreate?: ServiceScheduleCreateOrConnectWithoutDriverRunTemplatesInput
    connect?: ServiceScheduleWhereUniqueInput
  }

  export type DutyTemplateCreateNestedManyWithoutDriverRunTemplateInput = {
    create?: XOR<DutyTemplateCreateWithoutDriverRunTemplateInput, DutyTemplateUncheckedCreateWithoutDriverRunTemplateInput> | DutyTemplateCreateWithoutDriverRunTemplateInput[] | DutyTemplateUncheckedCreateWithoutDriverRunTemplateInput[]
    connectOrCreate?: DutyTemplateCreateOrConnectWithoutDriverRunTemplateInput | DutyTemplateCreateOrConnectWithoutDriverRunTemplateInput[]
    createMany?: DutyTemplateCreateManyDriverRunTemplateInputEnvelope
    connect?: DutyTemplateWhereUniqueInput | DutyTemplateWhereUniqueInput[]
  }

  export type DriverRunCreateNestedManyWithoutDriverRunTemplateInput = {
    create?: XOR<DriverRunCreateWithoutDriverRunTemplateInput, DriverRunUncheckedCreateWithoutDriverRunTemplateInput> | DriverRunCreateWithoutDriverRunTemplateInput[] | DriverRunUncheckedCreateWithoutDriverRunTemplateInput[]
    connectOrCreate?: DriverRunCreateOrConnectWithoutDriverRunTemplateInput | DriverRunCreateOrConnectWithoutDriverRunTemplateInput[]
    createMany?: DriverRunCreateManyDriverRunTemplateInputEnvelope
    connect?: DriverRunWhereUniqueInput | DriverRunWhereUniqueInput[]
  }

  export type DutyTemplateUncheckedCreateNestedManyWithoutDriverRunTemplateInput = {
    create?: XOR<DutyTemplateCreateWithoutDriverRunTemplateInput, DutyTemplateUncheckedCreateWithoutDriverRunTemplateInput> | DutyTemplateCreateWithoutDriverRunTemplateInput[] | DutyTemplateUncheckedCreateWithoutDriverRunTemplateInput[]
    connectOrCreate?: DutyTemplateCreateOrConnectWithoutDriverRunTemplateInput | DutyTemplateCreateOrConnectWithoutDriverRunTemplateInput[]
    createMany?: DutyTemplateCreateManyDriverRunTemplateInputEnvelope
    connect?: DutyTemplateWhereUniqueInput | DutyTemplateWhereUniqueInput[]
  }

  export type DriverRunUncheckedCreateNestedManyWithoutDriverRunTemplateInput = {
    create?: XOR<DriverRunCreateWithoutDriverRunTemplateInput, DriverRunUncheckedCreateWithoutDriverRunTemplateInput> | DriverRunCreateWithoutDriverRunTemplateInput[] | DriverRunUncheckedCreateWithoutDriverRunTemplateInput[]
    connectOrCreate?: DriverRunCreateOrConnectWithoutDriverRunTemplateInput | DriverRunCreateOrConnectWithoutDriverRunTemplateInput[]
    createMany?: DriverRunCreateManyDriverRunTemplateInputEnvelope
    connect?: DriverRunWhereUniqueInput | DriverRunWhereUniqueInput[]
  }

  export type ServiceScheduleUpdateOneRequiredWithoutDriverRunTemplatesNestedInput = {
    create?: XOR<ServiceScheduleCreateWithoutDriverRunTemplatesInput, ServiceScheduleUncheckedCreateWithoutDriverRunTemplatesInput>
    connectOrCreate?: ServiceScheduleCreateOrConnectWithoutDriverRunTemplatesInput
    upsert?: ServiceScheduleUpsertWithoutDriverRunTemplatesInput
    connect?: ServiceScheduleWhereUniqueInput
    update?: XOR<XOR<ServiceScheduleUpdateToOneWithWhereWithoutDriverRunTemplatesInput, ServiceScheduleUpdateWithoutDriverRunTemplatesInput>, ServiceScheduleUncheckedUpdateWithoutDriverRunTemplatesInput>
  }

  export type DutyTemplateUpdateManyWithoutDriverRunTemplateNestedInput = {
    create?: XOR<DutyTemplateCreateWithoutDriverRunTemplateInput, DutyTemplateUncheckedCreateWithoutDriverRunTemplateInput> | DutyTemplateCreateWithoutDriverRunTemplateInput[] | DutyTemplateUncheckedCreateWithoutDriverRunTemplateInput[]
    connectOrCreate?: DutyTemplateCreateOrConnectWithoutDriverRunTemplateInput | DutyTemplateCreateOrConnectWithoutDriverRunTemplateInput[]
    upsert?: DutyTemplateUpsertWithWhereUniqueWithoutDriverRunTemplateInput | DutyTemplateUpsertWithWhereUniqueWithoutDriverRunTemplateInput[]
    createMany?: DutyTemplateCreateManyDriverRunTemplateInputEnvelope
    set?: DutyTemplateWhereUniqueInput | DutyTemplateWhereUniqueInput[]
    disconnect?: DutyTemplateWhereUniqueInput | DutyTemplateWhereUniqueInput[]
    delete?: DutyTemplateWhereUniqueInput | DutyTemplateWhereUniqueInput[]
    connect?: DutyTemplateWhereUniqueInput | DutyTemplateWhereUniqueInput[]
    update?: DutyTemplateUpdateWithWhereUniqueWithoutDriverRunTemplateInput | DutyTemplateUpdateWithWhereUniqueWithoutDriverRunTemplateInput[]
    updateMany?: DutyTemplateUpdateManyWithWhereWithoutDriverRunTemplateInput | DutyTemplateUpdateManyWithWhereWithoutDriverRunTemplateInput[]
    deleteMany?: DutyTemplateScalarWhereInput | DutyTemplateScalarWhereInput[]
  }

  export type DriverRunUpdateManyWithoutDriverRunTemplateNestedInput = {
    create?: XOR<DriverRunCreateWithoutDriverRunTemplateInput, DriverRunUncheckedCreateWithoutDriverRunTemplateInput> | DriverRunCreateWithoutDriverRunTemplateInput[] | DriverRunUncheckedCreateWithoutDriverRunTemplateInput[]
    connectOrCreate?: DriverRunCreateOrConnectWithoutDriverRunTemplateInput | DriverRunCreateOrConnectWithoutDriverRunTemplateInput[]
    upsert?: DriverRunUpsertWithWhereUniqueWithoutDriverRunTemplateInput | DriverRunUpsertWithWhereUniqueWithoutDriverRunTemplateInput[]
    createMany?: DriverRunCreateManyDriverRunTemplateInputEnvelope
    set?: DriverRunWhereUniqueInput | DriverRunWhereUniqueInput[]
    disconnect?: DriverRunWhereUniqueInput | DriverRunWhereUniqueInput[]
    delete?: DriverRunWhereUniqueInput | DriverRunWhereUniqueInput[]
    connect?: DriverRunWhereUniqueInput | DriverRunWhereUniqueInput[]
    update?: DriverRunUpdateWithWhereUniqueWithoutDriverRunTemplateInput | DriverRunUpdateWithWhereUniqueWithoutDriverRunTemplateInput[]
    updateMany?: DriverRunUpdateManyWithWhereWithoutDriverRunTemplateInput | DriverRunUpdateManyWithWhereWithoutDriverRunTemplateInput[]
    deleteMany?: DriverRunScalarWhereInput | DriverRunScalarWhereInput[]
  }

  export type DutyTemplateUncheckedUpdateManyWithoutDriverRunTemplateNestedInput = {
    create?: XOR<DutyTemplateCreateWithoutDriverRunTemplateInput, DutyTemplateUncheckedCreateWithoutDriverRunTemplateInput> | DutyTemplateCreateWithoutDriverRunTemplateInput[] | DutyTemplateUncheckedCreateWithoutDriverRunTemplateInput[]
    connectOrCreate?: DutyTemplateCreateOrConnectWithoutDriverRunTemplateInput | DutyTemplateCreateOrConnectWithoutDriverRunTemplateInput[]
    upsert?: DutyTemplateUpsertWithWhereUniqueWithoutDriverRunTemplateInput | DutyTemplateUpsertWithWhereUniqueWithoutDriverRunTemplateInput[]
    createMany?: DutyTemplateCreateManyDriverRunTemplateInputEnvelope
    set?: DutyTemplateWhereUniqueInput | DutyTemplateWhereUniqueInput[]
    disconnect?: DutyTemplateWhereUniqueInput | DutyTemplateWhereUniqueInput[]
    delete?: DutyTemplateWhereUniqueInput | DutyTemplateWhereUniqueInput[]
    connect?: DutyTemplateWhereUniqueInput | DutyTemplateWhereUniqueInput[]
    update?: DutyTemplateUpdateWithWhereUniqueWithoutDriverRunTemplateInput | DutyTemplateUpdateWithWhereUniqueWithoutDriverRunTemplateInput[]
    updateMany?: DutyTemplateUpdateManyWithWhereWithoutDriverRunTemplateInput | DutyTemplateUpdateManyWithWhereWithoutDriverRunTemplateInput[]
    deleteMany?: DutyTemplateScalarWhereInput | DutyTemplateScalarWhereInput[]
  }

  export type DriverRunUncheckedUpdateManyWithoutDriverRunTemplateNestedInput = {
    create?: XOR<DriverRunCreateWithoutDriverRunTemplateInput, DriverRunUncheckedCreateWithoutDriverRunTemplateInput> | DriverRunCreateWithoutDriverRunTemplateInput[] | DriverRunUncheckedCreateWithoutDriverRunTemplateInput[]
    connectOrCreate?: DriverRunCreateOrConnectWithoutDriverRunTemplateInput | DriverRunCreateOrConnectWithoutDriverRunTemplateInput[]
    upsert?: DriverRunUpsertWithWhereUniqueWithoutDriverRunTemplateInput | DriverRunUpsertWithWhereUniqueWithoutDriverRunTemplateInput[]
    createMany?: DriverRunCreateManyDriverRunTemplateInputEnvelope
    set?: DriverRunWhereUniqueInput | DriverRunWhereUniqueInput[]
    disconnect?: DriverRunWhereUniqueInput | DriverRunWhereUniqueInput[]
    delete?: DriverRunWhereUniqueInput | DriverRunWhereUniqueInput[]
    connect?: DriverRunWhereUniqueInput | DriverRunWhereUniqueInput[]
    update?: DriverRunUpdateWithWhereUniqueWithoutDriverRunTemplateInput | DriverRunUpdateWithWhereUniqueWithoutDriverRunTemplateInput[]
    updateMany?: DriverRunUpdateManyWithWhereWithoutDriverRunTemplateInput | DriverRunUpdateManyWithWhereWithoutDriverRunTemplateInput[]
    deleteMany?: DriverRunScalarWhereInput | DriverRunScalarWhereInput[]
  }

  export type VehicleBlockTemplateCreateNestedOneWithoutDutyTemplateInput = {
    create?: XOR<VehicleBlockTemplateCreateWithoutDutyTemplateInput, VehicleBlockTemplateUncheckedCreateWithoutDutyTemplateInput>
    connectOrCreate?: VehicleBlockTemplateCreateOrConnectWithoutDutyTemplateInput
    connect?: VehicleBlockTemplateWhereUniqueInput
  }

  export type DriverRunTemplateCreateNestedOneWithoutDutyTemplateInput = {
    create?: XOR<DriverRunTemplateCreateWithoutDutyTemplateInput, DriverRunTemplateUncheckedCreateWithoutDutyTemplateInput>
    connectOrCreate?: DriverRunTemplateCreateOrConnectWithoutDutyTemplateInput
    connect?: DriverRunTemplateWhereUniqueInput
  }

  export type ServiceScheduleCreateNestedOneWithoutDutyTemplatesInput = {
    create?: XOR<ServiceScheduleCreateWithoutDutyTemplatesInput, ServiceScheduleUncheckedCreateWithoutDutyTemplatesInput>
    connectOrCreate?: ServiceScheduleCreateOrConnectWithoutDutyTemplatesInput
    connect?: ServiceScheduleWhereUniqueInput
  }

  export type EnumDutyTypeFieldUpdateOperationsInput = {
    set?: $Enums.DutyType
  }

  export type VehicleBlockTemplateUpdateOneWithoutDutyTemplateNestedInput = {
    create?: XOR<VehicleBlockTemplateCreateWithoutDutyTemplateInput, VehicleBlockTemplateUncheckedCreateWithoutDutyTemplateInput>
    connectOrCreate?: VehicleBlockTemplateCreateOrConnectWithoutDutyTemplateInput
    upsert?: VehicleBlockTemplateUpsertWithoutDutyTemplateInput
    disconnect?: VehicleBlockTemplateWhereInput | boolean
    delete?: VehicleBlockTemplateWhereInput | boolean
    connect?: VehicleBlockTemplateWhereUniqueInput
    update?: XOR<XOR<VehicleBlockTemplateUpdateToOneWithWhereWithoutDutyTemplateInput, VehicleBlockTemplateUpdateWithoutDutyTemplateInput>, VehicleBlockTemplateUncheckedUpdateWithoutDutyTemplateInput>
  }

  export type DriverRunTemplateUpdateOneWithoutDutyTemplateNestedInput = {
    create?: XOR<DriverRunTemplateCreateWithoutDutyTemplateInput, DriverRunTemplateUncheckedCreateWithoutDutyTemplateInput>
    connectOrCreate?: DriverRunTemplateCreateOrConnectWithoutDutyTemplateInput
    upsert?: DriverRunTemplateUpsertWithoutDutyTemplateInput
    disconnect?: DriverRunTemplateWhereInput | boolean
    delete?: DriverRunTemplateWhereInput | boolean
    connect?: DriverRunTemplateWhereUniqueInput
    update?: XOR<XOR<DriverRunTemplateUpdateToOneWithWhereWithoutDutyTemplateInput, DriverRunTemplateUpdateWithoutDutyTemplateInput>, DriverRunTemplateUncheckedUpdateWithoutDutyTemplateInput>
  }

  export type ServiceScheduleUpdateOneRequiredWithoutDutyTemplatesNestedInput = {
    create?: XOR<ServiceScheduleCreateWithoutDutyTemplatesInput, ServiceScheduleUncheckedCreateWithoutDutyTemplatesInput>
    connectOrCreate?: ServiceScheduleCreateOrConnectWithoutDutyTemplatesInput
    upsert?: ServiceScheduleUpsertWithoutDutyTemplatesInput
    connect?: ServiceScheduleWhereUniqueInput
    update?: XOR<XOR<ServiceScheduleUpdateToOneWithWhereWithoutDutyTemplatesInput, ServiceScheduleUpdateWithoutDutyTemplatesInput>, ServiceScheduleUncheckedUpdateWithoutDutyTemplatesInput>
  }

  export type VehicleBlockTemplateCreateNestedOneWithoutVehicleBlockInput = {
    create?: XOR<VehicleBlockTemplateCreateWithoutVehicleBlockInput, VehicleBlockTemplateUncheckedCreateWithoutVehicleBlockInput>
    connectOrCreate?: VehicleBlockTemplateCreateOrConnectWithoutVehicleBlockInput
    connect?: VehicleBlockTemplateWhereUniqueInput
  }

  export type DutyCreateNestedManyWithoutBlockInput = {
    create?: XOR<DutyCreateWithoutBlockInput, DutyUncheckedCreateWithoutBlockInput> | DutyCreateWithoutBlockInput[] | DutyUncheckedCreateWithoutBlockInput[]
    connectOrCreate?: DutyCreateOrConnectWithoutBlockInput | DutyCreateOrConnectWithoutBlockInput[]
    createMany?: DutyCreateManyBlockInputEnvelope
    connect?: DutyWhereUniqueInput | DutyWhereUniqueInput[]
  }

  export type DutyUncheckedCreateNestedManyWithoutBlockInput = {
    create?: XOR<DutyCreateWithoutBlockInput, DutyUncheckedCreateWithoutBlockInput> | DutyCreateWithoutBlockInput[] | DutyUncheckedCreateWithoutBlockInput[]
    connectOrCreate?: DutyCreateOrConnectWithoutBlockInput | DutyCreateOrConnectWithoutBlockInput[]
    createMany?: DutyCreateManyBlockInputEnvelope
    connect?: DutyWhereUniqueInput | DutyWhereUniqueInput[]
  }

  export type VehicleBlockTemplateUpdateOneRequiredWithoutVehicleBlockNestedInput = {
    create?: XOR<VehicleBlockTemplateCreateWithoutVehicleBlockInput, VehicleBlockTemplateUncheckedCreateWithoutVehicleBlockInput>
    connectOrCreate?: VehicleBlockTemplateCreateOrConnectWithoutVehicleBlockInput
    upsert?: VehicleBlockTemplateUpsertWithoutVehicleBlockInput
    connect?: VehicleBlockTemplateWhereUniqueInput
    update?: XOR<XOR<VehicleBlockTemplateUpdateToOneWithWhereWithoutVehicleBlockInput, VehicleBlockTemplateUpdateWithoutVehicleBlockInput>, VehicleBlockTemplateUncheckedUpdateWithoutVehicleBlockInput>
  }

  export type DutyUpdateManyWithoutBlockNestedInput = {
    create?: XOR<DutyCreateWithoutBlockInput, DutyUncheckedCreateWithoutBlockInput> | DutyCreateWithoutBlockInput[] | DutyUncheckedCreateWithoutBlockInput[]
    connectOrCreate?: DutyCreateOrConnectWithoutBlockInput | DutyCreateOrConnectWithoutBlockInput[]
    upsert?: DutyUpsertWithWhereUniqueWithoutBlockInput | DutyUpsertWithWhereUniqueWithoutBlockInput[]
    createMany?: DutyCreateManyBlockInputEnvelope
    set?: DutyWhereUniqueInput | DutyWhereUniqueInput[]
    disconnect?: DutyWhereUniqueInput | DutyWhereUniqueInput[]
    delete?: DutyWhereUniqueInput | DutyWhereUniqueInput[]
    connect?: DutyWhereUniqueInput | DutyWhereUniqueInput[]
    update?: DutyUpdateWithWhereUniqueWithoutBlockInput | DutyUpdateWithWhereUniqueWithoutBlockInput[]
    updateMany?: DutyUpdateManyWithWhereWithoutBlockInput | DutyUpdateManyWithWhereWithoutBlockInput[]
    deleteMany?: DutyScalarWhereInput | DutyScalarWhereInput[]
  }

  export type DutyUncheckedUpdateManyWithoutBlockNestedInput = {
    create?: XOR<DutyCreateWithoutBlockInput, DutyUncheckedCreateWithoutBlockInput> | DutyCreateWithoutBlockInput[] | DutyUncheckedCreateWithoutBlockInput[]
    connectOrCreate?: DutyCreateOrConnectWithoutBlockInput | DutyCreateOrConnectWithoutBlockInput[]
    upsert?: DutyUpsertWithWhereUniqueWithoutBlockInput | DutyUpsertWithWhereUniqueWithoutBlockInput[]
    createMany?: DutyCreateManyBlockInputEnvelope
    set?: DutyWhereUniqueInput | DutyWhereUniqueInput[]
    disconnect?: DutyWhereUniqueInput | DutyWhereUniqueInput[]
    delete?: DutyWhereUniqueInput | DutyWhereUniqueInput[]
    connect?: DutyWhereUniqueInput | DutyWhereUniqueInput[]
    update?: DutyUpdateWithWhereUniqueWithoutBlockInput | DutyUpdateWithWhereUniqueWithoutBlockInput[]
    updateMany?: DutyUpdateManyWithWhereWithoutBlockInput | DutyUpdateManyWithWhereWithoutBlockInput[]
    deleteMany?: DutyScalarWhereInput | DutyScalarWhereInput[]
  }

  export type DriverRunTemplateCreateNestedOneWithoutDriverRunInput = {
    create?: XOR<DriverRunTemplateCreateWithoutDriverRunInput, DriverRunTemplateUncheckedCreateWithoutDriverRunInput>
    connectOrCreate?: DriverRunTemplateCreateOrConnectWithoutDriverRunInput
    connect?: DriverRunTemplateWhereUniqueInput
  }

  export type DutyCreateNestedManyWithoutRunInput = {
    create?: XOR<DutyCreateWithoutRunInput, DutyUncheckedCreateWithoutRunInput> | DutyCreateWithoutRunInput[] | DutyUncheckedCreateWithoutRunInput[]
    connectOrCreate?: DutyCreateOrConnectWithoutRunInput | DutyCreateOrConnectWithoutRunInput[]
    createMany?: DutyCreateManyRunInputEnvelope
    connect?: DutyWhereUniqueInput | DutyWhereUniqueInput[]
  }

  export type DutyUncheckedCreateNestedManyWithoutRunInput = {
    create?: XOR<DutyCreateWithoutRunInput, DutyUncheckedCreateWithoutRunInput> | DutyCreateWithoutRunInput[] | DutyUncheckedCreateWithoutRunInput[]
    connectOrCreate?: DutyCreateOrConnectWithoutRunInput | DutyCreateOrConnectWithoutRunInput[]
    createMany?: DutyCreateManyRunInputEnvelope
    connect?: DutyWhereUniqueInput | DutyWhereUniqueInput[]
  }

  export type DriverRunTemplateUpdateOneRequiredWithoutDriverRunNestedInput = {
    create?: XOR<DriverRunTemplateCreateWithoutDriverRunInput, DriverRunTemplateUncheckedCreateWithoutDriverRunInput>
    connectOrCreate?: DriverRunTemplateCreateOrConnectWithoutDriverRunInput
    upsert?: DriverRunTemplateUpsertWithoutDriverRunInput
    connect?: DriverRunTemplateWhereUniqueInput
    update?: XOR<XOR<DriverRunTemplateUpdateToOneWithWhereWithoutDriverRunInput, DriverRunTemplateUpdateWithoutDriverRunInput>, DriverRunTemplateUncheckedUpdateWithoutDriverRunInput>
  }

  export type DutyUpdateManyWithoutRunNestedInput = {
    create?: XOR<DutyCreateWithoutRunInput, DutyUncheckedCreateWithoutRunInput> | DutyCreateWithoutRunInput[] | DutyUncheckedCreateWithoutRunInput[]
    connectOrCreate?: DutyCreateOrConnectWithoutRunInput | DutyCreateOrConnectWithoutRunInput[]
    upsert?: DutyUpsertWithWhereUniqueWithoutRunInput | DutyUpsertWithWhereUniqueWithoutRunInput[]
    createMany?: DutyCreateManyRunInputEnvelope
    set?: DutyWhereUniqueInput | DutyWhereUniqueInput[]
    disconnect?: DutyWhereUniqueInput | DutyWhereUniqueInput[]
    delete?: DutyWhereUniqueInput | DutyWhereUniqueInput[]
    connect?: DutyWhereUniqueInput | DutyWhereUniqueInput[]
    update?: DutyUpdateWithWhereUniqueWithoutRunInput | DutyUpdateWithWhereUniqueWithoutRunInput[]
    updateMany?: DutyUpdateManyWithWhereWithoutRunInput | DutyUpdateManyWithWhereWithoutRunInput[]
    deleteMany?: DutyScalarWhereInput | DutyScalarWhereInput[]
  }

  export type DutyUncheckedUpdateManyWithoutRunNestedInput = {
    create?: XOR<DutyCreateWithoutRunInput, DutyUncheckedCreateWithoutRunInput> | DutyCreateWithoutRunInput[] | DutyUncheckedCreateWithoutRunInput[]
    connectOrCreate?: DutyCreateOrConnectWithoutRunInput | DutyCreateOrConnectWithoutRunInput[]
    upsert?: DutyUpsertWithWhereUniqueWithoutRunInput | DutyUpsertWithWhereUniqueWithoutRunInput[]
    createMany?: DutyCreateManyRunInputEnvelope
    set?: DutyWhereUniqueInput | DutyWhereUniqueInput[]
    disconnect?: DutyWhereUniqueInput | DutyWhereUniqueInput[]
    delete?: DutyWhereUniqueInput | DutyWhereUniqueInput[]
    connect?: DutyWhereUniqueInput | DutyWhereUniqueInput[]
    update?: DutyUpdateWithWhereUniqueWithoutRunInput | DutyUpdateWithWhereUniqueWithoutRunInput[]
    updateMany?: DutyUpdateManyWithWhereWithoutRunInput | DutyUpdateManyWithWhereWithoutRunInput[]
    deleteMany?: DutyScalarWhereInput | DutyScalarWhereInput[]
  }

  export type VehicleBlockCreateNestedOneWithoutDutyInput = {
    create?: XOR<VehicleBlockCreateWithoutDutyInput, VehicleBlockUncheckedCreateWithoutDutyInput>
    connectOrCreate?: VehicleBlockCreateOrConnectWithoutDutyInput
    connect?: VehicleBlockWhereUniqueInput
  }

  export type DriverRunCreateNestedOneWithoutDutyInput = {
    create?: XOR<DriverRunCreateWithoutDutyInput, DriverRunUncheckedCreateWithoutDutyInput>
    connectOrCreate?: DriverRunCreateOrConnectWithoutDutyInput
    connect?: DriverRunWhereUniqueInput
  }

  export type DriverCreateNestedOneWithoutDutyInput = {
    create?: XOR<DriverCreateWithoutDutyInput, DriverUncheckedCreateWithoutDutyInput>
    connectOrCreate?: DriverCreateOrConnectWithoutDutyInput
    connect?: DriverWhereUniqueInput
  }

  export type VehicleCreateNestedOneWithoutDutyInput = {
    create?: XOR<VehicleCreateWithoutDutyInput, VehicleUncheckedCreateWithoutDutyInput>
    connectOrCreate?: VehicleCreateOrConnectWithoutDutyInput
    connect?: VehicleWhereUniqueInput
  }

  export type TripDutyCreateNestedManyWithoutDutyInput = {
    create?: XOR<TripDutyCreateWithoutDutyInput, TripDutyUncheckedCreateWithoutDutyInput> | TripDutyCreateWithoutDutyInput[] | TripDutyUncheckedCreateWithoutDutyInput[]
    connectOrCreate?: TripDutyCreateOrConnectWithoutDutyInput | TripDutyCreateOrConnectWithoutDutyInput[]
    createMany?: TripDutyCreateManyDutyInputEnvelope
    connect?: TripDutyWhereUniqueInput | TripDutyWhereUniqueInput[]
  }

  export type WashingDutyCreateNestedManyWithoutDutyInput = {
    create?: XOR<WashingDutyCreateWithoutDutyInput, WashingDutyUncheckedCreateWithoutDutyInput> | WashingDutyCreateWithoutDutyInput[] | WashingDutyUncheckedCreateWithoutDutyInput[]
    connectOrCreate?: WashingDutyCreateOrConnectWithoutDutyInput | WashingDutyCreateOrConnectWithoutDutyInput[]
    createMany?: WashingDutyCreateManyDutyInputEnvelope
    connect?: WashingDutyWhereUniqueInput | WashingDutyWhereUniqueInput[]
  }

  export type MaintenanceDutyCreateNestedManyWithoutDutyInput = {
    create?: XOR<MaintenanceDutyCreateWithoutDutyInput, MaintenanceDutyUncheckedCreateWithoutDutyInput> | MaintenanceDutyCreateWithoutDutyInput[] | MaintenanceDutyUncheckedCreateWithoutDutyInput[]
    connectOrCreate?: MaintenanceDutyCreateOrConnectWithoutDutyInput | MaintenanceDutyCreateOrConnectWithoutDutyInput[]
    createMany?: MaintenanceDutyCreateManyDutyInputEnvelope
    connect?: MaintenanceDutyWhereUniqueInput | MaintenanceDutyWhereUniqueInput[]
  }

  export type TripDutyUncheckedCreateNestedManyWithoutDutyInput = {
    create?: XOR<TripDutyCreateWithoutDutyInput, TripDutyUncheckedCreateWithoutDutyInput> | TripDutyCreateWithoutDutyInput[] | TripDutyUncheckedCreateWithoutDutyInput[]
    connectOrCreate?: TripDutyCreateOrConnectWithoutDutyInput | TripDutyCreateOrConnectWithoutDutyInput[]
    createMany?: TripDutyCreateManyDutyInputEnvelope
    connect?: TripDutyWhereUniqueInput | TripDutyWhereUniqueInput[]
  }

  export type WashingDutyUncheckedCreateNestedManyWithoutDutyInput = {
    create?: XOR<WashingDutyCreateWithoutDutyInput, WashingDutyUncheckedCreateWithoutDutyInput> | WashingDutyCreateWithoutDutyInput[] | WashingDutyUncheckedCreateWithoutDutyInput[]
    connectOrCreate?: WashingDutyCreateOrConnectWithoutDutyInput | WashingDutyCreateOrConnectWithoutDutyInput[]
    createMany?: WashingDutyCreateManyDutyInputEnvelope
    connect?: WashingDutyWhereUniqueInput | WashingDutyWhereUniqueInput[]
  }

  export type MaintenanceDutyUncheckedCreateNestedManyWithoutDutyInput = {
    create?: XOR<MaintenanceDutyCreateWithoutDutyInput, MaintenanceDutyUncheckedCreateWithoutDutyInput> | MaintenanceDutyCreateWithoutDutyInput[] | MaintenanceDutyUncheckedCreateWithoutDutyInput[]
    connectOrCreate?: MaintenanceDutyCreateOrConnectWithoutDutyInput | MaintenanceDutyCreateOrConnectWithoutDutyInput[]
    createMany?: MaintenanceDutyCreateManyDutyInputEnvelope
    connect?: MaintenanceDutyWhereUniqueInput | MaintenanceDutyWhereUniqueInput[]
  }

  export type VehicleBlockUpdateOneWithoutDutyNestedInput = {
    create?: XOR<VehicleBlockCreateWithoutDutyInput, VehicleBlockUncheckedCreateWithoutDutyInput>
    connectOrCreate?: VehicleBlockCreateOrConnectWithoutDutyInput
    upsert?: VehicleBlockUpsertWithoutDutyInput
    disconnect?: VehicleBlockWhereInput | boolean
    delete?: VehicleBlockWhereInput | boolean
    connect?: VehicleBlockWhereUniqueInput
    update?: XOR<XOR<VehicleBlockUpdateToOneWithWhereWithoutDutyInput, VehicleBlockUpdateWithoutDutyInput>, VehicleBlockUncheckedUpdateWithoutDutyInput>
  }

  export type DriverRunUpdateOneWithoutDutyNestedInput = {
    create?: XOR<DriverRunCreateWithoutDutyInput, DriverRunUncheckedCreateWithoutDutyInput>
    connectOrCreate?: DriverRunCreateOrConnectWithoutDutyInput
    upsert?: DriverRunUpsertWithoutDutyInput
    disconnect?: DriverRunWhereInput | boolean
    delete?: DriverRunWhereInput | boolean
    connect?: DriverRunWhereUniqueInput
    update?: XOR<XOR<DriverRunUpdateToOneWithWhereWithoutDutyInput, DriverRunUpdateWithoutDutyInput>, DriverRunUncheckedUpdateWithoutDutyInput>
  }

  export type DriverUpdateOneWithoutDutyNestedInput = {
    create?: XOR<DriverCreateWithoutDutyInput, DriverUncheckedCreateWithoutDutyInput>
    connectOrCreate?: DriverCreateOrConnectWithoutDutyInput
    upsert?: DriverUpsertWithoutDutyInput
    disconnect?: DriverWhereInput | boolean
    delete?: DriverWhereInput | boolean
    connect?: DriverWhereUniqueInput
    update?: XOR<XOR<DriverUpdateToOneWithWhereWithoutDutyInput, DriverUpdateWithoutDutyInput>, DriverUncheckedUpdateWithoutDutyInput>
  }

  export type VehicleUpdateOneWithoutDutyNestedInput = {
    create?: XOR<VehicleCreateWithoutDutyInput, VehicleUncheckedCreateWithoutDutyInput>
    connectOrCreate?: VehicleCreateOrConnectWithoutDutyInput
    upsert?: VehicleUpsertWithoutDutyInput
    disconnect?: VehicleWhereInput | boolean
    delete?: VehicleWhereInput | boolean
    connect?: VehicleWhereUniqueInput
    update?: XOR<XOR<VehicleUpdateToOneWithWhereWithoutDutyInput, VehicleUpdateWithoutDutyInput>, VehicleUncheckedUpdateWithoutDutyInput>
  }

  export type TripDutyUpdateManyWithoutDutyNestedInput = {
    create?: XOR<TripDutyCreateWithoutDutyInput, TripDutyUncheckedCreateWithoutDutyInput> | TripDutyCreateWithoutDutyInput[] | TripDutyUncheckedCreateWithoutDutyInput[]
    connectOrCreate?: TripDutyCreateOrConnectWithoutDutyInput | TripDutyCreateOrConnectWithoutDutyInput[]
    upsert?: TripDutyUpsertWithWhereUniqueWithoutDutyInput | TripDutyUpsertWithWhereUniqueWithoutDutyInput[]
    createMany?: TripDutyCreateManyDutyInputEnvelope
    set?: TripDutyWhereUniqueInput | TripDutyWhereUniqueInput[]
    disconnect?: TripDutyWhereUniqueInput | TripDutyWhereUniqueInput[]
    delete?: TripDutyWhereUniqueInput | TripDutyWhereUniqueInput[]
    connect?: TripDutyWhereUniqueInput | TripDutyWhereUniqueInput[]
    update?: TripDutyUpdateWithWhereUniqueWithoutDutyInput | TripDutyUpdateWithWhereUniqueWithoutDutyInput[]
    updateMany?: TripDutyUpdateManyWithWhereWithoutDutyInput | TripDutyUpdateManyWithWhereWithoutDutyInput[]
    deleteMany?: TripDutyScalarWhereInput | TripDutyScalarWhereInput[]
  }

  export type WashingDutyUpdateManyWithoutDutyNestedInput = {
    create?: XOR<WashingDutyCreateWithoutDutyInput, WashingDutyUncheckedCreateWithoutDutyInput> | WashingDutyCreateWithoutDutyInput[] | WashingDutyUncheckedCreateWithoutDutyInput[]
    connectOrCreate?: WashingDutyCreateOrConnectWithoutDutyInput | WashingDutyCreateOrConnectWithoutDutyInput[]
    upsert?: WashingDutyUpsertWithWhereUniqueWithoutDutyInput | WashingDutyUpsertWithWhereUniqueWithoutDutyInput[]
    createMany?: WashingDutyCreateManyDutyInputEnvelope
    set?: WashingDutyWhereUniqueInput | WashingDutyWhereUniqueInput[]
    disconnect?: WashingDutyWhereUniqueInput | WashingDutyWhereUniqueInput[]
    delete?: WashingDutyWhereUniqueInput | WashingDutyWhereUniqueInput[]
    connect?: WashingDutyWhereUniqueInput | WashingDutyWhereUniqueInput[]
    update?: WashingDutyUpdateWithWhereUniqueWithoutDutyInput | WashingDutyUpdateWithWhereUniqueWithoutDutyInput[]
    updateMany?: WashingDutyUpdateManyWithWhereWithoutDutyInput | WashingDutyUpdateManyWithWhereWithoutDutyInput[]
    deleteMany?: WashingDutyScalarWhereInput | WashingDutyScalarWhereInput[]
  }

  export type MaintenanceDutyUpdateManyWithoutDutyNestedInput = {
    create?: XOR<MaintenanceDutyCreateWithoutDutyInput, MaintenanceDutyUncheckedCreateWithoutDutyInput> | MaintenanceDutyCreateWithoutDutyInput[] | MaintenanceDutyUncheckedCreateWithoutDutyInput[]
    connectOrCreate?: MaintenanceDutyCreateOrConnectWithoutDutyInput | MaintenanceDutyCreateOrConnectWithoutDutyInput[]
    upsert?: MaintenanceDutyUpsertWithWhereUniqueWithoutDutyInput | MaintenanceDutyUpsertWithWhereUniqueWithoutDutyInput[]
    createMany?: MaintenanceDutyCreateManyDutyInputEnvelope
    set?: MaintenanceDutyWhereUniqueInput | MaintenanceDutyWhereUniqueInput[]
    disconnect?: MaintenanceDutyWhereUniqueInput | MaintenanceDutyWhereUniqueInput[]
    delete?: MaintenanceDutyWhereUniqueInput | MaintenanceDutyWhereUniqueInput[]
    connect?: MaintenanceDutyWhereUniqueInput | MaintenanceDutyWhereUniqueInput[]
    update?: MaintenanceDutyUpdateWithWhereUniqueWithoutDutyInput | MaintenanceDutyUpdateWithWhereUniqueWithoutDutyInput[]
    updateMany?: MaintenanceDutyUpdateManyWithWhereWithoutDutyInput | MaintenanceDutyUpdateManyWithWhereWithoutDutyInput[]
    deleteMany?: MaintenanceDutyScalarWhereInput | MaintenanceDutyScalarWhereInput[]
  }

  export type TripDutyUncheckedUpdateManyWithoutDutyNestedInput = {
    create?: XOR<TripDutyCreateWithoutDutyInput, TripDutyUncheckedCreateWithoutDutyInput> | TripDutyCreateWithoutDutyInput[] | TripDutyUncheckedCreateWithoutDutyInput[]
    connectOrCreate?: TripDutyCreateOrConnectWithoutDutyInput | TripDutyCreateOrConnectWithoutDutyInput[]
    upsert?: TripDutyUpsertWithWhereUniqueWithoutDutyInput | TripDutyUpsertWithWhereUniqueWithoutDutyInput[]
    createMany?: TripDutyCreateManyDutyInputEnvelope
    set?: TripDutyWhereUniqueInput | TripDutyWhereUniqueInput[]
    disconnect?: TripDutyWhereUniqueInput | TripDutyWhereUniqueInput[]
    delete?: TripDutyWhereUniqueInput | TripDutyWhereUniqueInput[]
    connect?: TripDutyWhereUniqueInput | TripDutyWhereUniqueInput[]
    update?: TripDutyUpdateWithWhereUniqueWithoutDutyInput | TripDutyUpdateWithWhereUniqueWithoutDutyInput[]
    updateMany?: TripDutyUpdateManyWithWhereWithoutDutyInput | TripDutyUpdateManyWithWhereWithoutDutyInput[]
    deleteMany?: TripDutyScalarWhereInput | TripDutyScalarWhereInput[]
  }

  export type WashingDutyUncheckedUpdateManyWithoutDutyNestedInput = {
    create?: XOR<WashingDutyCreateWithoutDutyInput, WashingDutyUncheckedCreateWithoutDutyInput> | WashingDutyCreateWithoutDutyInput[] | WashingDutyUncheckedCreateWithoutDutyInput[]
    connectOrCreate?: WashingDutyCreateOrConnectWithoutDutyInput | WashingDutyCreateOrConnectWithoutDutyInput[]
    upsert?: WashingDutyUpsertWithWhereUniqueWithoutDutyInput | WashingDutyUpsertWithWhereUniqueWithoutDutyInput[]
    createMany?: WashingDutyCreateManyDutyInputEnvelope
    set?: WashingDutyWhereUniqueInput | WashingDutyWhereUniqueInput[]
    disconnect?: WashingDutyWhereUniqueInput | WashingDutyWhereUniqueInput[]
    delete?: WashingDutyWhereUniqueInput | WashingDutyWhereUniqueInput[]
    connect?: WashingDutyWhereUniqueInput | WashingDutyWhereUniqueInput[]
    update?: WashingDutyUpdateWithWhereUniqueWithoutDutyInput | WashingDutyUpdateWithWhereUniqueWithoutDutyInput[]
    updateMany?: WashingDutyUpdateManyWithWhereWithoutDutyInput | WashingDutyUpdateManyWithWhereWithoutDutyInput[]
    deleteMany?: WashingDutyScalarWhereInput | WashingDutyScalarWhereInput[]
  }

  export type MaintenanceDutyUncheckedUpdateManyWithoutDutyNestedInput = {
    create?: XOR<MaintenanceDutyCreateWithoutDutyInput, MaintenanceDutyUncheckedCreateWithoutDutyInput> | MaintenanceDutyCreateWithoutDutyInput[] | MaintenanceDutyUncheckedCreateWithoutDutyInput[]
    connectOrCreate?: MaintenanceDutyCreateOrConnectWithoutDutyInput | MaintenanceDutyCreateOrConnectWithoutDutyInput[]
    upsert?: MaintenanceDutyUpsertWithWhereUniqueWithoutDutyInput | MaintenanceDutyUpsertWithWhereUniqueWithoutDutyInput[]
    createMany?: MaintenanceDutyCreateManyDutyInputEnvelope
    set?: MaintenanceDutyWhereUniqueInput | MaintenanceDutyWhereUniqueInput[]
    disconnect?: MaintenanceDutyWhereUniqueInput | MaintenanceDutyWhereUniqueInput[]
    delete?: MaintenanceDutyWhereUniqueInput | MaintenanceDutyWhereUniqueInput[]
    connect?: MaintenanceDutyWhereUniqueInput | MaintenanceDutyWhereUniqueInput[]
    update?: MaintenanceDutyUpdateWithWhereUniqueWithoutDutyInput | MaintenanceDutyUpdateWithWhereUniqueWithoutDutyInput[]
    updateMany?: MaintenanceDutyUpdateManyWithWhereWithoutDutyInput | MaintenanceDutyUpdateManyWithWhereWithoutDutyInput[]
    deleteMany?: MaintenanceDutyScalarWhereInput | MaintenanceDutyScalarWhereInput[]
  }

  export type DutyCreateNestedOneWithoutTripDutiesInput = {
    create?: XOR<DutyCreateWithoutTripDutiesInput, DutyUncheckedCreateWithoutTripDutiesInput>
    connectOrCreate?: DutyCreateOrConnectWithoutTripDutiesInput
    connect?: DutyWhereUniqueInput
  }

  export type RouteCreateNestedOneWithoutTripDutyInput = {
    create?: XOR<RouteCreateWithoutTripDutyInput, RouteUncheckedCreateWithoutTripDutyInput>
    connectOrCreate?: RouteCreateOrConnectWithoutTripDutyInput
    connect?: RouteWhereUniqueInput
  }

  export type DutyUpdateOneRequiredWithoutTripDutiesNestedInput = {
    create?: XOR<DutyCreateWithoutTripDutiesInput, DutyUncheckedCreateWithoutTripDutiesInput>
    connectOrCreate?: DutyCreateOrConnectWithoutTripDutiesInput
    upsert?: DutyUpsertWithoutTripDutiesInput
    connect?: DutyWhereUniqueInput
    update?: XOR<XOR<DutyUpdateToOneWithWhereWithoutTripDutiesInput, DutyUpdateWithoutTripDutiesInput>, DutyUncheckedUpdateWithoutTripDutiesInput>
  }

  export type RouteUpdateOneRequiredWithoutTripDutyNestedInput = {
    create?: XOR<RouteCreateWithoutTripDutyInput, RouteUncheckedCreateWithoutTripDutyInput>
    connectOrCreate?: RouteCreateOrConnectWithoutTripDutyInput
    upsert?: RouteUpsertWithoutTripDutyInput
    connect?: RouteWhereUniqueInput
    update?: XOR<XOR<RouteUpdateToOneWithWhereWithoutTripDutyInput, RouteUpdateWithoutTripDutyInput>, RouteUncheckedUpdateWithoutTripDutyInput>
  }

  export type DutyCreateNestedOneWithoutWashingDutiesInput = {
    create?: XOR<DutyCreateWithoutWashingDutiesInput, DutyUncheckedCreateWithoutWashingDutiesInput>
    connectOrCreate?: DutyCreateOrConnectWithoutWashingDutiesInput
    connect?: DutyWhereUniqueInput
  }

  export type DutyUpdateOneRequiredWithoutWashingDutiesNestedInput = {
    create?: XOR<DutyCreateWithoutWashingDutiesInput, DutyUncheckedCreateWithoutWashingDutiesInput>
    connectOrCreate?: DutyCreateOrConnectWithoutWashingDutiesInput
    upsert?: DutyUpsertWithoutWashingDutiesInput
    connect?: DutyWhereUniqueInput
    update?: XOR<XOR<DutyUpdateToOneWithWhereWithoutWashingDutiesInput, DutyUpdateWithoutWashingDutiesInput>, DutyUncheckedUpdateWithoutWashingDutiesInput>
  }

  export type DutyCreateNestedOneWithoutMaintenanceDutiesInput = {
    create?: XOR<DutyCreateWithoutMaintenanceDutiesInput, DutyUncheckedCreateWithoutMaintenanceDutiesInput>
    connectOrCreate?: DutyCreateOrConnectWithoutMaintenanceDutiesInput
    connect?: DutyWhereUniqueInput
  }

  export type DutyUpdateOneRequiredWithoutMaintenanceDutiesNestedInput = {
    create?: XOR<DutyCreateWithoutMaintenanceDutiesInput, DutyUncheckedCreateWithoutMaintenanceDutiesInput>
    connectOrCreate?: DutyCreateOrConnectWithoutMaintenanceDutiesInput
    upsert?: DutyUpsertWithoutMaintenanceDutiesInput
    connect?: DutyWhereUniqueInput
    update?: XOR<XOR<DutyUpdateToOneWithWhereWithoutMaintenanceDutiesInput, DutyUpdateWithoutMaintenanceDutiesInput>, DutyUncheckedUpdateWithoutMaintenanceDutiesInput>
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumDutyTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DutyType | EnumDutyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DutyType[] | ListEnumDutyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DutyType[] | ListEnumDutyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDutyTypeFilter<$PrismaModel> | $Enums.DutyType
  }

  export type NestedEnumDutyTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DutyType | EnumDutyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DutyType[] | ListEnumDutyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DutyType[] | ListEnumDutyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDutyTypeWithAggregatesFilter<$PrismaModel> | $Enums.DutyType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDutyTypeFilter<$PrismaModel>
    _max?: NestedEnumDutyTypeFilter<$PrismaModel>
  }

  export type UserCreateWithoutUserAuthsInput = {
    id?: bigint | number
    name: string
    email: string
    phone: string
    qid?: string | null
    userType?: number
    isActive?: boolean
    roles?: UserRoleCreateNestedManyWithoutUserInput
    userActivations?: UserActivationCreateNestedManyWithoutUserInput
    drivers?: DriverCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserAuthsInput = {
    id?: bigint | number
    name: string
    email: string
    phone: string
    qid?: string | null
    userType?: number
    isActive?: boolean
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    userActivations?: UserActivationUncheckedCreateNestedManyWithoutUserInput
    drivers?: DriverUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserAuthsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserAuthsInput, UserUncheckedCreateWithoutUserAuthsInput>
  }

  export type UserUpsertWithoutUserAuthsInput = {
    update: XOR<UserUpdateWithoutUserAuthsInput, UserUncheckedUpdateWithoutUserAuthsInput>
    create: XOR<UserCreateWithoutUserAuthsInput, UserUncheckedCreateWithoutUserAuthsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserAuthsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserAuthsInput, UserUncheckedUpdateWithoutUserAuthsInput>
  }

  export type UserUpdateWithoutUserAuthsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    qid?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    userActivations?: UserActivationUpdateManyWithoutUserNestedInput
    drivers?: DriverUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserAuthsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    qid?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    userActivations?: UserActivationUncheckedUpdateManyWithoutUserNestedInput
    drivers?: DriverUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutUserActivationsInput = {
    id?: bigint | number
    name: string
    email: string
    phone: string
    qid?: string | null
    userType?: number
    isActive?: boolean
    roles?: UserRoleCreateNestedManyWithoutUserInput
    userAuths?: UserAuthCreateNestedManyWithoutUserInput
    drivers?: DriverCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserActivationsInput = {
    id?: bigint | number
    name: string
    email: string
    phone: string
    qid?: string | null
    userType?: number
    isActive?: boolean
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    userAuths?: UserAuthUncheckedCreateNestedManyWithoutUserInput
    drivers?: DriverUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserActivationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserActivationsInput, UserUncheckedCreateWithoutUserActivationsInput>
  }

  export type UserUpsertWithoutUserActivationsInput = {
    update: XOR<UserUpdateWithoutUserActivationsInput, UserUncheckedUpdateWithoutUserActivationsInput>
    create: XOR<UserCreateWithoutUserActivationsInput, UserUncheckedCreateWithoutUserActivationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserActivationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserActivationsInput, UserUncheckedUpdateWithoutUserActivationsInput>
  }

  export type UserUpdateWithoutUserActivationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    qid?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    userAuths?: UserAuthUpdateManyWithoutUserNestedInput
    drivers?: DriverUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserActivationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    qid?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    userAuths?: UserAuthUncheckedUpdateManyWithoutUserNestedInput
    drivers?: DriverUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserRoleCreateWithoutUserInput = {
    id?: bigint | number
    role: RoleCreateNestedOneWithoutUsersInput
  }

  export type UserRoleUncheckedCreateWithoutUserInput = {
    id?: bigint | number
    roleId: bigint | number
  }

  export type UserRoleCreateOrConnectWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    create: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput>
  }

  export type UserRoleCreateManyUserInputEnvelope = {
    data: UserRoleCreateManyUserInput | UserRoleCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserActivationCreateWithoutUserInput = {
    id?: bigint | number
    activationCode: string
    expiresAt: Date | string
    isUsed?: boolean
    createdAt?: Date | string
  }

  export type UserActivationUncheckedCreateWithoutUserInput = {
    id?: bigint | number
    activationCode: string
    expiresAt: Date | string
    isUsed?: boolean
    createdAt?: Date | string
  }

  export type UserActivationCreateOrConnectWithoutUserInput = {
    where: UserActivationWhereUniqueInput
    create: XOR<UserActivationCreateWithoutUserInput, UserActivationUncheckedCreateWithoutUserInput>
  }

  export type UserActivationCreateManyUserInputEnvelope = {
    data: UserActivationCreateManyUserInput | UserActivationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserAuthCreateWithoutUserInput = {
    id?: bigint | number
    userType: string
    provider: string
    identifier: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserAuthUncheckedCreateWithoutUserInput = {
    id?: bigint | number
    userType: string
    provider: string
    identifier: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserAuthCreateOrConnectWithoutUserInput = {
    where: UserAuthWhereUniqueInput
    create: XOR<UserAuthCreateWithoutUserInput, UserAuthUncheckedCreateWithoutUserInput>
  }

  export type UserAuthCreateManyUserInputEnvelope = {
    data: UserAuthCreateManyUserInput | UserAuthCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DriverCreateWithoutUserInput = {
    id?: bigint | number
    licenseExpiry?: Date | string | null
    trips?: TripCreateNestedManyWithoutDriverInput
    shifts?: ShiftCreateNestedManyWithoutDriverInput
    Duty?: DutyCreateNestedManyWithoutDriverInput
  }

  export type DriverUncheckedCreateWithoutUserInput = {
    id?: bigint | number
    licenseExpiry?: Date | string | null
    trips?: TripUncheckedCreateNestedManyWithoutDriverInput
    shifts?: ShiftUncheckedCreateNestedManyWithoutDriverInput
    Duty?: DutyUncheckedCreateNestedManyWithoutDriverInput
  }

  export type DriverCreateOrConnectWithoutUserInput = {
    where: DriverWhereUniqueInput
    create: XOR<DriverCreateWithoutUserInput, DriverUncheckedCreateWithoutUserInput>
  }

  export type DriverCreateManyUserInputEnvelope = {
    data: DriverCreateManyUserInput | DriverCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserRoleUpsertWithWhereUniqueWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    update: XOR<UserRoleUpdateWithoutUserInput, UserRoleUncheckedUpdateWithoutUserInput>
    create: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput>
  }

  export type UserRoleUpdateWithWhereUniqueWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    data: XOR<UserRoleUpdateWithoutUserInput, UserRoleUncheckedUpdateWithoutUserInput>
  }

  export type UserRoleUpdateManyWithWhereWithoutUserInput = {
    where: UserRoleScalarWhereInput
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyWithoutUserInput>
  }

  export type UserRoleScalarWhereInput = {
    AND?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
    OR?: UserRoleScalarWhereInput[]
    NOT?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
    id?: BigIntFilter<"UserRole"> | bigint | number
    userId?: BigIntFilter<"UserRole"> | bigint | number
    roleId?: BigIntFilter<"UserRole"> | bigint | number
  }

  export type UserActivationUpsertWithWhereUniqueWithoutUserInput = {
    where: UserActivationWhereUniqueInput
    update: XOR<UserActivationUpdateWithoutUserInput, UserActivationUncheckedUpdateWithoutUserInput>
    create: XOR<UserActivationCreateWithoutUserInput, UserActivationUncheckedCreateWithoutUserInput>
  }

  export type UserActivationUpdateWithWhereUniqueWithoutUserInput = {
    where: UserActivationWhereUniqueInput
    data: XOR<UserActivationUpdateWithoutUserInput, UserActivationUncheckedUpdateWithoutUserInput>
  }

  export type UserActivationUpdateManyWithWhereWithoutUserInput = {
    where: UserActivationScalarWhereInput
    data: XOR<UserActivationUpdateManyMutationInput, UserActivationUncheckedUpdateManyWithoutUserInput>
  }

  export type UserActivationScalarWhereInput = {
    AND?: UserActivationScalarWhereInput | UserActivationScalarWhereInput[]
    OR?: UserActivationScalarWhereInput[]
    NOT?: UserActivationScalarWhereInput | UserActivationScalarWhereInput[]
    id?: BigIntFilter<"UserActivation"> | bigint | number
    userId?: BigIntFilter<"UserActivation"> | bigint | number
    activationCode?: StringFilter<"UserActivation"> | string
    expiresAt?: DateTimeFilter<"UserActivation"> | Date | string
    isUsed?: BoolFilter<"UserActivation"> | boolean
    createdAt?: DateTimeFilter<"UserActivation"> | Date | string
  }

  export type UserAuthUpsertWithWhereUniqueWithoutUserInput = {
    where: UserAuthWhereUniqueInput
    update: XOR<UserAuthUpdateWithoutUserInput, UserAuthUncheckedUpdateWithoutUserInput>
    create: XOR<UserAuthCreateWithoutUserInput, UserAuthUncheckedCreateWithoutUserInput>
  }

  export type UserAuthUpdateWithWhereUniqueWithoutUserInput = {
    where: UserAuthWhereUniqueInput
    data: XOR<UserAuthUpdateWithoutUserInput, UserAuthUncheckedUpdateWithoutUserInput>
  }

  export type UserAuthUpdateManyWithWhereWithoutUserInput = {
    where: UserAuthScalarWhereInput
    data: XOR<UserAuthUpdateManyMutationInput, UserAuthUncheckedUpdateManyWithoutUserInput>
  }

  export type UserAuthScalarWhereInput = {
    AND?: UserAuthScalarWhereInput | UserAuthScalarWhereInput[]
    OR?: UserAuthScalarWhereInput[]
    NOT?: UserAuthScalarWhereInput | UserAuthScalarWhereInput[]
    id?: BigIntFilter<"UserAuth"> | bigint | number
    userId?: BigIntFilter<"UserAuth"> | bigint | number
    userType?: StringFilter<"UserAuth"> | string
    provider?: StringFilter<"UserAuth"> | string
    identifier?: StringFilter<"UserAuth"> | string
    password?: StringFilter<"UserAuth"> | string
    createdAt?: DateTimeFilter<"UserAuth"> | Date | string
    updatedAt?: DateTimeFilter<"UserAuth"> | Date | string
  }

  export type DriverUpsertWithWhereUniqueWithoutUserInput = {
    where: DriverWhereUniqueInput
    update: XOR<DriverUpdateWithoutUserInput, DriverUncheckedUpdateWithoutUserInput>
    create: XOR<DriverCreateWithoutUserInput, DriverUncheckedCreateWithoutUserInput>
  }

  export type DriverUpdateWithWhereUniqueWithoutUserInput = {
    where: DriverWhereUniqueInput
    data: XOR<DriverUpdateWithoutUserInput, DriverUncheckedUpdateWithoutUserInput>
  }

  export type DriverUpdateManyWithWhereWithoutUserInput = {
    where: DriverScalarWhereInput
    data: XOR<DriverUpdateManyMutationInput, DriverUncheckedUpdateManyWithoutUserInput>
  }

  export type DriverScalarWhereInput = {
    AND?: DriverScalarWhereInput | DriverScalarWhereInput[]
    OR?: DriverScalarWhereInput[]
    NOT?: DriverScalarWhereInput | DriverScalarWhereInput[]
    id?: BigIntFilter<"Driver"> | bigint | number
    userId?: BigIntFilter<"Driver"> | bigint | number
    licenseExpiry?: DateTimeNullableFilter<"Driver"> | Date | string | null
  }

  export type UserRoleCreateWithoutRoleInput = {
    id?: bigint | number
    user: UserCreateNestedOneWithoutRolesInput
  }

  export type UserRoleUncheckedCreateWithoutRoleInput = {
    id?: bigint | number
    userId: bigint | number
  }

  export type UserRoleCreateOrConnectWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    create: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput>
  }

  export type UserRoleCreateManyRoleInputEnvelope = {
    data: UserRoleCreateManyRoleInput | UserRoleCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type UserRoleUpsertWithWhereUniqueWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    update: XOR<UserRoleUpdateWithoutRoleInput, UserRoleUncheckedUpdateWithoutRoleInput>
    create: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput>
  }

  export type UserRoleUpdateWithWhereUniqueWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    data: XOR<UserRoleUpdateWithoutRoleInput, UserRoleUncheckedUpdateWithoutRoleInput>
  }

  export type UserRoleUpdateManyWithWhereWithoutRoleInput = {
    where: UserRoleScalarWhereInput
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyWithoutRoleInput>
  }

  export type UserCreateWithoutRolesInput = {
    id?: bigint | number
    name: string
    email: string
    phone: string
    qid?: string | null
    userType?: number
    isActive?: boolean
    userActivations?: UserActivationCreateNestedManyWithoutUserInput
    userAuths?: UserAuthCreateNestedManyWithoutUserInput
    drivers?: DriverCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRolesInput = {
    id?: bigint | number
    name: string
    email: string
    phone: string
    qid?: string | null
    userType?: number
    isActive?: boolean
    userActivations?: UserActivationUncheckedCreateNestedManyWithoutUserInput
    userAuths?: UserAuthUncheckedCreateNestedManyWithoutUserInput
    drivers?: DriverUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRolesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
  }

  export type RoleCreateWithoutUsersInput = {
    id?: bigint | number
    name: string
  }

  export type RoleUncheckedCreateWithoutUsersInput = {
    id?: bigint | number
    name: string
  }

  export type RoleCreateOrConnectWithoutUsersInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
  }

  export type UserUpsertWithoutRolesInput = {
    update: XOR<UserUpdateWithoutRolesInput, UserUncheckedUpdateWithoutRolesInput>
    create: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRolesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRolesInput, UserUncheckedUpdateWithoutRolesInput>
  }

  export type UserUpdateWithoutRolesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    qid?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    userActivations?: UserActivationUpdateManyWithoutUserNestedInput
    userAuths?: UserAuthUpdateManyWithoutUserNestedInput
    drivers?: DriverUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRolesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    qid?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    userActivations?: UserActivationUncheckedUpdateManyWithoutUserNestedInput
    userAuths?: UserAuthUncheckedUpdateManyWithoutUserNestedInput
    drivers?: DriverUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RoleUpsertWithoutUsersInput = {
    update: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutUsersInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type RoleUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type RoleUncheckedUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TripCreateWithoutDriverInput = {
    id?: bigint | number
    startTime: Date | string
    endTime?: Date | string | null
    startLocation: bigint | number
    endLocation?: bigint | number | null
    averageSpeed?: Decimal | DecimalJsLike | number | string | null
    maxSpeed?: Decimal | DecimalJsLike | number | string | null
    totalDistance?: Decimal | DecimalJsLike | number | string | null
    totalDuration?: number | null
    idleTime?: number | null
    path?: string | null
    route: RouteCreateNestedOneWithoutTripsInput
    vehicle: VehicleCreateNestedOneWithoutTripsInput
    tripStops?: TripStopCreateNestedManyWithoutTripInput
  }

  export type TripUncheckedCreateWithoutDriverInput = {
    id?: bigint | number
    routeId: bigint | number
    startTime: Date | string
    endTime?: Date | string | null
    startLocation: bigint | number
    endLocation?: bigint | number | null
    vehicleId: bigint | number
    averageSpeed?: Decimal | DecimalJsLike | number | string | null
    maxSpeed?: Decimal | DecimalJsLike | number | string | null
    totalDistance?: Decimal | DecimalJsLike | number | string | null
    totalDuration?: number | null
    idleTime?: number | null
    path?: string | null
    tripStops?: TripStopUncheckedCreateNestedManyWithoutTripInput
  }

  export type TripCreateOrConnectWithoutDriverInput = {
    where: TripWhereUniqueInput
    create: XOR<TripCreateWithoutDriverInput, TripUncheckedCreateWithoutDriverInput>
  }

  export type TripCreateManyDriverInputEnvelope = {
    data: TripCreateManyDriverInput | TripCreateManyDriverInput[]
    skipDuplicates?: boolean
  }

  export type ShiftCreateWithoutDriverInput = {
    id?: bigint | number
    startTime: Date | string
    endTime: Date | string
    vehicle: VehicleCreateNestedOneWithoutShiftsInput
  }

  export type ShiftUncheckedCreateWithoutDriverInput = {
    id?: bigint | number
    startTime: Date | string
    endTime: Date | string
    vehicleId: bigint | number
  }

  export type ShiftCreateOrConnectWithoutDriverInput = {
    where: ShiftWhereUniqueInput
    create: XOR<ShiftCreateWithoutDriverInput, ShiftUncheckedCreateWithoutDriverInput>
  }

  export type ShiftCreateManyDriverInputEnvelope = {
    data: ShiftCreateManyDriverInput | ShiftCreateManyDriverInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutDriversInput = {
    id?: bigint | number
    name: string
    email: string
    phone: string
    qid?: string | null
    userType?: number
    isActive?: boolean
    roles?: UserRoleCreateNestedManyWithoutUserInput
    userActivations?: UserActivationCreateNestedManyWithoutUserInput
    userAuths?: UserAuthCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDriversInput = {
    id?: bigint | number
    name: string
    email: string
    phone: string
    qid?: string | null
    userType?: number
    isActive?: boolean
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    userActivations?: UserActivationUncheckedCreateNestedManyWithoutUserInput
    userAuths?: UserAuthUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDriversInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDriversInput, UserUncheckedCreateWithoutDriversInput>
  }

  export type DutyCreateWithoutDriverInput = {
    id?: bigint | number
    date: Date | string
    startTime: Date | string
    endTime: Date | string
    dutyTemplateId?: bigint | number | null
    dutyType: $Enums.DutyType
    block?: VehicleBlockCreateNestedOneWithoutDutyInput
    run?: DriverRunCreateNestedOneWithoutDutyInput
    vehicle?: VehicleCreateNestedOneWithoutDutyInput
    tripDuties?: TripDutyCreateNestedManyWithoutDutyInput
    washingDuties?: WashingDutyCreateNestedManyWithoutDutyInput
    maintenanceDuties?: MaintenanceDutyCreateNestedManyWithoutDutyInput
  }

  export type DutyUncheckedCreateWithoutDriverInput = {
    id?: bigint | number
    date: Date | string
    startTime: Date | string
    endTime: Date | string
    vehicleId?: bigint | number | null
    dutyTemplateId?: bigint | number | null
    blockId?: bigint | number | null
    runId?: bigint | number | null
    dutyType: $Enums.DutyType
    tripDuties?: TripDutyUncheckedCreateNestedManyWithoutDutyInput
    washingDuties?: WashingDutyUncheckedCreateNestedManyWithoutDutyInput
    maintenanceDuties?: MaintenanceDutyUncheckedCreateNestedManyWithoutDutyInput
  }

  export type DutyCreateOrConnectWithoutDriverInput = {
    where: DutyWhereUniqueInput
    create: XOR<DutyCreateWithoutDriverInput, DutyUncheckedCreateWithoutDriverInput>
  }

  export type DutyCreateManyDriverInputEnvelope = {
    data: DutyCreateManyDriverInput | DutyCreateManyDriverInput[]
    skipDuplicates?: boolean
  }

  export type TripUpsertWithWhereUniqueWithoutDriverInput = {
    where: TripWhereUniqueInput
    update: XOR<TripUpdateWithoutDriverInput, TripUncheckedUpdateWithoutDriverInput>
    create: XOR<TripCreateWithoutDriverInput, TripUncheckedCreateWithoutDriverInput>
  }

  export type TripUpdateWithWhereUniqueWithoutDriverInput = {
    where: TripWhereUniqueInput
    data: XOR<TripUpdateWithoutDriverInput, TripUncheckedUpdateWithoutDriverInput>
  }

  export type TripUpdateManyWithWhereWithoutDriverInput = {
    where: TripScalarWhereInput
    data: XOR<TripUpdateManyMutationInput, TripUncheckedUpdateManyWithoutDriverInput>
  }

  export type TripScalarWhereInput = {
    AND?: TripScalarWhereInput | TripScalarWhereInput[]
    OR?: TripScalarWhereInput[]
    NOT?: TripScalarWhereInput | TripScalarWhereInput[]
    id?: BigIntFilter<"Trip"> | bigint | number
    routeId?: BigIntFilter<"Trip"> | bigint | number
    startTime?: DateTimeFilter<"Trip"> | Date | string
    endTime?: DateTimeNullableFilter<"Trip"> | Date | string | null
    startLocation?: BigIntFilter<"Trip"> | bigint | number
    endLocation?: BigIntNullableFilter<"Trip"> | bigint | number | null
    driverId?: BigIntFilter<"Trip"> | bigint | number
    vehicleId?: BigIntFilter<"Trip"> | bigint | number
    averageSpeed?: DecimalNullableFilter<"Trip"> | Decimal | DecimalJsLike | number | string | null
    maxSpeed?: DecimalNullableFilter<"Trip"> | Decimal | DecimalJsLike | number | string | null
    totalDistance?: DecimalNullableFilter<"Trip"> | Decimal | DecimalJsLike | number | string | null
    totalDuration?: IntNullableFilter<"Trip"> | number | null
    idleTime?: IntNullableFilter<"Trip"> | number | null
    path?: StringNullableFilter<"Trip"> | string | null
  }

  export type ShiftUpsertWithWhereUniqueWithoutDriverInput = {
    where: ShiftWhereUniqueInput
    update: XOR<ShiftUpdateWithoutDriverInput, ShiftUncheckedUpdateWithoutDriverInput>
    create: XOR<ShiftCreateWithoutDriverInput, ShiftUncheckedCreateWithoutDriverInput>
  }

  export type ShiftUpdateWithWhereUniqueWithoutDriverInput = {
    where: ShiftWhereUniqueInput
    data: XOR<ShiftUpdateWithoutDriverInput, ShiftUncheckedUpdateWithoutDriverInput>
  }

  export type ShiftUpdateManyWithWhereWithoutDriverInput = {
    where: ShiftScalarWhereInput
    data: XOR<ShiftUpdateManyMutationInput, ShiftUncheckedUpdateManyWithoutDriverInput>
  }

  export type ShiftScalarWhereInput = {
    AND?: ShiftScalarWhereInput | ShiftScalarWhereInput[]
    OR?: ShiftScalarWhereInput[]
    NOT?: ShiftScalarWhereInput | ShiftScalarWhereInput[]
    id?: BigIntFilter<"Shift"> | bigint | number
    startTime?: DateTimeFilter<"Shift"> | Date | string
    endTime?: DateTimeFilter<"Shift"> | Date | string
    vehicleId?: BigIntFilter<"Shift"> | bigint | number
    driverId?: BigIntFilter<"Shift"> | bigint | number
  }

  export type UserUpsertWithoutDriversInput = {
    update: XOR<UserUpdateWithoutDriversInput, UserUncheckedUpdateWithoutDriversInput>
    create: XOR<UserCreateWithoutDriversInput, UserUncheckedCreateWithoutDriversInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDriversInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDriversInput, UserUncheckedUpdateWithoutDriversInput>
  }

  export type UserUpdateWithoutDriversInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    qid?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    userActivations?: UserActivationUpdateManyWithoutUserNestedInput
    userAuths?: UserAuthUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDriversInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    qid?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    userActivations?: UserActivationUncheckedUpdateManyWithoutUserNestedInput
    userAuths?: UserAuthUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DutyUpsertWithWhereUniqueWithoutDriverInput = {
    where: DutyWhereUniqueInput
    update: XOR<DutyUpdateWithoutDriverInput, DutyUncheckedUpdateWithoutDriverInput>
    create: XOR<DutyCreateWithoutDriverInput, DutyUncheckedCreateWithoutDriverInput>
  }

  export type DutyUpdateWithWhereUniqueWithoutDriverInput = {
    where: DutyWhereUniqueInput
    data: XOR<DutyUpdateWithoutDriverInput, DutyUncheckedUpdateWithoutDriverInput>
  }

  export type DutyUpdateManyWithWhereWithoutDriverInput = {
    where: DutyScalarWhereInput
    data: XOR<DutyUpdateManyMutationInput, DutyUncheckedUpdateManyWithoutDriverInput>
  }

  export type DutyScalarWhereInput = {
    AND?: DutyScalarWhereInput | DutyScalarWhereInput[]
    OR?: DutyScalarWhereInput[]
    NOT?: DutyScalarWhereInput | DutyScalarWhereInput[]
    id?: BigIntFilter<"Duty"> | bigint | number
    date?: DateTimeFilter<"Duty"> | Date | string
    startTime?: DateTimeFilter<"Duty"> | Date | string
    endTime?: DateTimeFilter<"Duty"> | Date | string
    driverId?: BigIntNullableFilter<"Duty"> | bigint | number | null
    vehicleId?: BigIntNullableFilter<"Duty"> | bigint | number | null
    dutyTemplateId?: BigIntNullableFilter<"Duty"> | bigint | number | null
    blockId?: BigIntNullableFilter<"Duty"> | bigint | number | null
    runId?: BigIntNullableFilter<"Duty"> | bigint | number | null
    dutyType?: EnumDutyTypeFilter<"Duty"> | $Enums.DutyType
  }

  export type VehicleCreateWithoutModelInput = {
    id?: bigint | number
    plateNo: string
    fleetNo: string
    trips?: TripCreateNestedManyWithoutVehicleInput
    shifts?: ShiftCreateNestedManyWithoutVehicleInput
    telemetry?: VehicleTelemetryCreateNestedManyWithoutVehicleInput
    telemetryHistory?: VehicleTelemetryHistoryCreateNestedManyWithoutVehicleInput
    Duty?: DutyCreateNestedManyWithoutVehicleInput
  }

  export type VehicleUncheckedCreateWithoutModelInput = {
    id?: bigint | number
    plateNo: string
    fleetNo: string
    trips?: TripUncheckedCreateNestedManyWithoutVehicleInput
    shifts?: ShiftUncheckedCreateNestedManyWithoutVehicleInput
    telemetry?: VehicleTelemetryUncheckedCreateNestedManyWithoutVehicleInput
    telemetryHistory?: VehicleTelemetryHistoryUncheckedCreateNestedManyWithoutVehicleInput
    Duty?: DutyUncheckedCreateNestedManyWithoutVehicleInput
  }

  export type VehicleCreateOrConnectWithoutModelInput = {
    where: VehicleWhereUniqueInput
    create: XOR<VehicleCreateWithoutModelInput, VehicleUncheckedCreateWithoutModelInput>
  }

  export type VehicleCreateManyModelInputEnvelope = {
    data: VehicleCreateManyModelInput | VehicleCreateManyModelInput[]
    skipDuplicates?: boolean
  }

  export type VehicleUpsertWithWhereUniqueWithoutModelInput = {
    where: VehicleWhereUniqueInput
    update: XOR<VehicleUpdateWithoutModelInput, VehicleUncheckedUpdateWithoutModelInput>
    create: XOR<VehicleCreateWithoutModelInput, VehicleUncheckedCreateWithoutModelInput>
  }

  export type VehicleUpdateWithWhereUniqueWithoutModelInput = {
    where: VehicleWhereUniqueInput
    data: XOR<VehicleUpdateWithoutModelInput, VehicleUncheckedUpdateWithoutModelInput>
  }

  export type VehicleUpdateManyWithWhereWithoutModelInput = {
    where: VehicleScalarWhereInput
    data: XOR<VehicleUpdateManyMutationInput, VehicleUncheckedUpdateManyWithoutModelInput>
  }

  export type VehicleScalarWhereInput = {
    AND?: VehicleScalarWhereInput | VehicleScalarWhereInput[]
    OR?: VehicleScalarWhereInput[]
    NOT?: VehicleScalarWhereInput | VehicleScalarWhereInput[]
    id?: BigIntFilter<"Vehicle"> | bigint | number
    plateNo?: StringFilter<"Vehicle"> | string
    fleetNo?: StringFilter<"Vehicle"> | string
    modelId?: BigIntFilter<"Vehicle"> | bigint | number
  }

  export type VehicleModelCreateWithoutVehiclesInput = {
    id?: bigint | number
    make: string
    year: number
    manufacturer: string
    capacity: number
  }

  export type VehicleModelUncheckedCreateWithoutVehiclesInput = {
    id?: bigint | number
    make: string
    year: number
    manufacturer: string
    capacity: number
  }

  export type VehicleModelCreateOrConnectWithoutVehiclesInput = {
    where: VehicleModelWhereUniqueInput
    create: XOR<VehicleModelCreateWithoutVehiclesInput, VehicleModelUncheckedCreateWithoutVehiclesInput>
  }

  export type TripCreateWithoutVehicleInput = {
    id?: bigint | number
    startTime: Date | string
    endTime?: Date | string | null
    startLocation: bigint | number
    endLocation?: bigint | number | null
    averageSpeed?: Decimal | DecimalJsLike | number | string | null
    maxSpeed?: Decimal | DecimalJsLike | number | string | null
    totalDistance?: Decimal | DecimalJsLike | number | string | null
    totalDuration?: number | null
    idleTime?: number | null
    path?: string | null
    route: RouteCreateNestedOneWithoutTripsInput
    driver: DriverCreateNestedOneWithoutTripsInput
    tripStops?: TripStopCreateNestedManyWithoutTripInput
  }

  export type TripUncheckedCreateWithoutVehicleInput = {
    id?: bigint | number
    routeId: bigint | number
    startTime: Date | string
    endTime?: Date | string | null
    startLocation: bigint | number
    endLocation?: bigint | number | null
    driverId: bigint | number
    averageSpeed?: Decimal | DecimalJsLike | number | string | null
    maxSpeed?: Decimal | DecimalJsLike | number | string | null
    totalDistance?: Decimal | DecimalJsLike | number | string | null
    totalDuration?: number | null
    idleTime?: number | null
    path?: string | null
    tripStops?: TripStopUncheckedCreateNestedManyWithoutTripInput
  }

  export type TripCreateOrConnectWithoutVehicleInput = {
    where: TripWhereUniqueInput
    create: XOR<TripCreateWithoutVehicleInput, TripUncheckedCreateWithoutVehicleInput>
  }

  export type TripCreateManyVehicleInputEnvelope = {
    data: TripCreateManyVehicleInput | TripCreateManyVehicleInput[]
    skipDuplicates?: boolean
  }

  export type ShiftCreateWithoutVehicleInput = {
    id?: bigint | number
    startTime: Date | string
    endTime: Date | string
    driver: DriverCreateNestedOneWithoutShiftsInput
  }

  export type ShiftUncheckedCreateWithoutVehicleInput = {
    id?: bigint | number
    startTime: Date | string
    endTime: Date | string
    driverId: bigint | number
  }

  export type ShiftCreateOrConnectWithoutVehicleInput = {
    where: ShiftWhereUniqueInput
    create: XOR<ShiftCreateWithoutVehicleInput, ShiftUncheckedCreateWithoutVehicleInput>
  }

  export type ShiftCreateManyVehicleInputEnvelope = {
    data: ShiftCreateManyVehicleInput | ShiftCreateManyVehicleInput[]
    skipDuplicates?: boolean
  }

  export type VehicleTelemetryCreateWithoutVehicleInput = {
    id?: bigint | number
    lat: Decimal | DecimalJsLike | number | string
    lon: Decimal | DecimalJsLike | number | string
    speed?: Decimal | DecimalJsLike | number | string | null
    ignition: boolean
    trackedOn?: Date | string
  }

  export type VehicleTelemetryUncheckedCreateWithoutVehicleInput = {
    id?: bigint | number
    lat: Decimal | DecimalJsLike | number | string
    lon: Decimal | DecimalJsLike | number | string
    speed?: Decimal | DecimalJsLike | number | string | null
    ignition: boolean
    trackedOn?: Date | string
  }

  export type VehicleTelemetryCreateOrConnectWithoutVehicleInput = {
    where: VehicleTelemetryWhereUniqueInput
    create: XOR<VehicleTelemetryCreateWithoutVehicleInput, VehicleTelemetryUncheckedCreateWithoutVehicleInput>
  }

  export type VehicleTelemetryCreateManyVehicleInputEnvelope = {
    data: VehicleTelemetryCreateManyVehicleInput | VehicleTelemetryCreateManyVehicleInput[]
    skipDuplicates?: boolean
  }

  export type VehicleTelemetryHistoryCreateWithoutVehicleInput = {
    id?: bigint | number
    lat: Decimal | DecimalJsLike | number | string
    lon: Decimal | DecimalJsLike | number | string
    speed?: Decimal | DecimalJsLike | number | string | null
    ignition: boolean
    trackedOn: Date | string
  }

  export type VehicleTelemetryHistoryUncheckedCreateWithoutVehicleInput = {
    id?: bigint | number
    lat: Decimal | DecimalJsLike | number | string
    lon: Decimal | DecimalJsLike | number | string
    speed?: Decimal | DecimalJsLike | number | string | null
    ignition: boolean
    trackedOn: Date | string
  }

  export type VehicleTelemetryHistoryCreateOrConnectWithoutVehicleInput = {
    where: VehicleTelemetryHistoryWhereUniqueInput
    create: XOR<VehicleTelemetryHistoryCreateWithoutVehicleInput, VehicleTelemetryHistoryUncheckedCreateWithoutVehicleInput>
  }

  export type VehicleTelemetryHistoryCreateManyVehicleInputEnvelope = {
    data: VehicleTelemetryHistoryCreateManyVehicleInput | VehicleTelemetryHistoryCreateManyVehicleInput[]
    skipDuplicates?: boolean
  }

  export type DutyCreateWithoutVehicleInput = {
    id?: bigint | number
    date: Date | string
    startTime: Date | string
    endTime: Date | string
    dutyTemplateId?: bigint | number | null
    dutyType: $Enums.DutyType
    block?: VehicleBlockCreateNestedOneWithoutDutyInput
    run?: DriverRunCreateNestedOneWithoutDutyInput
    driver?: DriverCreateNestedOneWithoutDutyInput
    tripDuties?: TripDutyCreateNestedManyWithoutDutyInput
    washingDuties?: WashingDutyCreateNestedManyWithoutDutyInput
    maintenanceDuties?: MaintenanceDutyCreateNestedManyWithoutDutyInput
  }

  export type DutyUncheckedCreateWithoutVehicleInput = {
    id?: bigint | number
    date: Date | string
    startTime: Date | string
    endTime: Date | string
    driverId?: bigint | number | null
    dutyTemplateId?: bigint | number | null
    blockId?: bigint | number | null
    runId?: bigint | number | null
    dutyType: $Enums.DutyType
    tripDuties?: TripDutyUncheckedCreateNestedManyWithoutDutyInput
    washingDuties?: WashingDutyUncheckedCreateNestedManyWithoutDutyInput
    maintenanceDuties?: MaintenanceDutyUncheckedCreateNestedManyWithoutDutyInput
  }

  export type DutyCreateOrConnectWithoutVehicleInput = {
    where: DutyWhereUniqueInput
    create: XOR<DutyCreateWithoutVehicleInput, DutyUncheckedCreateWithoutVehicleInput>
  }

  export type DutyCreateManyVehicleInputEnvelope = {
    data: DutyCreateManyVehicleInput | DutyCreateManyVehicleInput[]
    skipDuplicates?: boolean
  }

  export type VehicleModelUpsertWithoutVehiclesInput = {
    update: XOR<VehicleModelUpdateWithoutVehiclesInput, VehicleModelUncheckedUpdateWithoutVehiclesInput>
    create: XOR<VehicleModelCreateWithoutVehiclesInput, VehicleModelUncheckedCreateWithoutVehiclesInput>
    where?: VehicleModelWhereInput
  }

  export type VehicleModelUpdateToOneWithWhereWithoutVehiclesInput = {
    where?: VehicleModelWhereInput
    data: XOR<VehicleModelUpdateWithoutVehiclesInput, VehicleModelUncheckedUpdateWithoutVehiclesInput>
  }

  export type VehicleModelUpdateWithoutVehiclesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    make?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    manufacturer?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
  }

  export type VehicleModelUncheckedUpdateWithoutVehiclesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    make?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    manufacturer?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
  }

  export type TripUpsertWithWhereUniqueWithoutVehicleInput = {
    where: TripWhereUniqueInput
    update: XOR<TripUpdateWithoutVehicleInput, TripUncheckedUpdateWithoutVehicleInput>
    create: XOR<TripCreateWithoutVehicleInput, TripUncheckedCreateWithoutVehicleInput>
  }

  export type TripUpdateWithWhereUniqueWithoutVehicleInput = {
    where: TripWhereUniqueInput
    data: XOR<TripUpdateWithoutVehicleInput, TripUncheckedUpdateWithoutVehicleInput>
  }

  export type TripUpdateManyWithWhereWithoutVehicleInput = {
    where: TripScalarWhereInput
    data: XOR<TripUpdateManyMutationInput, TripUncheckedUpdateManyWithoutVehicleInput>
  }

  export type ShiftUpsertWithWhereUniqueWithoutVehicleInput = {
    where: ShiftWhereUniqueInput
    update: XOR<ShiftUpdateWithoutVehicleInput, ShiftUncheckedUpdateWithoutVehicleInput>
    create: XOR<ShiftCreateWithoutVehicleInput, ShiftUncheckedCreateWithoutVehicleInput>
  }

  export type ShiftUpdateWithWhereUniqueWithoutVehicleInput = {
    where: ShiftWhereUniqueInput
    data: XOR<ShiftUpdateWithoutVehicleInput, ShiftUncheckedUpdateWithoutVehicleInput>
  }

  export type ShiftUpdateManyWithWhereWithoutVehicleInput = {
    where: ShiftScalarWhereInput
    data: XOR<ShiftUpdateManyMutationInput, ShiftUncheckedUpdateManyWithoutVehicleInput>
  }

  export type VehicleTelemetryUpsertWithWhereUniqueWithoutVehicleInput = {
    where: VehicleTelemetryWhereUniqueInput
    update: XOR<VehicleTelemetryUpdateWithoutVehicleInput, VehicleTelemetryUncheckedUpdateWithoutVehicleInput>
    create: XOR<VehicleTelemetryCreateWithoutVehicleInput, VehicleTelemetryUncheckedCreateWithoutVehicleInput>
  }

  export type VehicleTelemetryUpdateWithWhereUniqueWithoutVehicleInput = {
    where: VehicleTelemetryWhereUniqueInput
    data: XOR<VehicleTelemetryUpdateWithoutVehicleInput, VehicleTelemetryUncheckedUpdateWithoutVehicleInput>
  }

  export type VehicleTelemetryUpdateManyWithWhereWithoutVehicleInput = {
    where: VehicleTelemetryScalarWhereInput
    data: XOR<VehicleTelemetryUpdateManyMutationInput, VehicleTelemetryUncheckedUpdateManyWithoutVehicleInput>
  }

  export type VehicleTelemetryScalarWhereInput = {
    AND?: VehicleTelemetryScalarWhereInput | VehicleTelemetryScalarWhereInput[]
    OR?: VehicleTelemetryScalarWhereInput[]
    NOT?: VehicleTelemetryScalarWhereInput | VehicleTelemetryScalarWhereInput[]
    id?: BigIntFilter<"VehicleTelemetry"> | bigint | number
    lat?: DecimalFilter<"VehicleTelemetry"> | Decimal | DecimalJsLike | number | string
    lon?: DecimalFilter<"VehicleTelemetry"> | Decimal | DecimalJsLike | number | string
    speed?: DecimalNullableFilter<"VehicleTelemetry"> | Decimal | DecimalJsLike | number | string | null
    ignition?: BoolFilter<"VehicleTelemetry"> | boolean
    trackedOn?: DateTimeFilter<"VehicleTelemetry"> | Date | string
    vehicleId?: BigIntFilter<"VehicleTelemetry"> | bigint | number
  }

  export type VehicleTelemetryHistoryUpsertWithWhereUniqueWithoutVehicleInput = {
    where: VehicleTelemetryHistoryWhereUniqueInput
    update: XOR<VehicleTelemetryHistoryUpdateWithoutVehicleInput, VehicleTelemetryHistoryUncheckedUpdateWithoutVehicleInput>
    create: XOR<VehicleTelemetryHistoryCreateWithoutVehicleInput, VehicleTelemetryHistoryUncheckedCreateWithoutVehicleInput>
  }

  export type VehicleTelemetryHistoryUpdateWithWhereUniqueWithoutVehicleInput = {
    where: VehicleTelemetryHistoryWhereUniqueInput
    data: XOR<VehicleTelemetryHistoryUpdateWithoutVehicleInput, VehicleTelemetryHistoryUncheckedUpdateWithoutVehicleInput>
  }

  export type VehicleTelemetryHistoryUpdateManyWithWhereWithoutVehicleInput = {
    where: VehicleTelemetryHistoryScalarWhereInput
    data: XOR<VehicleTelemetryHistoryUpdateManyMutationInput, VehicleTelemetryHistoryUncheckedUpdateManyWithoutVehicleInput>
  }

  export type VehicleTelemetryHistoryScalarWhereInput = {
    AND?: VehicleTelemetryHistoryScalarWhereInput | VehicleTelemetryHistoryScalarWhereInput[]
    OR?: VehicleTelemetryHistoryScalarWhereInput[]
    NOT?: VehicleTelemetryHistoryScalarWhereInput | VehicleTelemetryHistoryScalarWhereInput[]
    id?: BigIntFilter<"VehicleTelemetryHistory"> | bigint | number
    lat?: DecimalFilter<"VehicleTelemetryHistory"> | Decimal | DecimalJsLike | number | string
    lon?: DecimalFilter<"VehicleTelemetryHistory"> | Decimal | DecimalJsLike | number | string
    speed?: DecimalNullableFilter<"VehicleTelemetryHistory"> | Decimal | DecimalJsLike | number | string | null
    ignition?: BoolFilter<"VehicleTelemetryHistory"> | boolean
    trackedOn?: DateTimeFilter<"VehicleTelemetryHistory"> | Date | string
    vehicleId?: BigIntFilter<"VehicleTelemetryHistory"> | bigint | number
  }

  export type DutyUpsertWithWhereUniqueWithoutVehicleInput = {
    where: DutyWhereUniqueInput
    update: XOR<DutyUpdateWithoutVehicleInput, DutyUncheckedUpdateWithoutVehicleInput>
    create: XOR<DutyCreateWithoutVehicleInput, DutyUncheckedCreateWithoutVehicleInput>
  }

  export type DutyUpdateWithWhereUniqueWithoutVehicleInput = {
    where: DutyWhereUniqueInput
    data: XOR<DutyUpdateWithoutVehicleInput, DutyUncheckedUpdateWithoutVehicleInput>
  }

  export type DutyUpdateManyWithWhereWithoutVehicleInput = {
    where: DutyScalarWhereInput
    data: XOR<DutyUpdateManyMutationInput, DutyUncheckedUpdateManyWithoutVehicleInput>
  }

  export type StopCreateWithoutLocationInput = {
    id?: bigint | number
    name: string
    code: string
    routeStops?: RouteStopCreateNestedManyWithoutStopInput
    tripStops?: TripStopCreateNestedManyWithoutStopInput
  }

  export type StopUncheckedCreateWithoutLocationInput = {
    id?: bigint | number
    name: string
    code: string
    routeStops?: RouteStopUncheckedCreateNestedManyWithoutStopInput
    tripStops?: TripStopUncheckedCreateNestedManyWithoutStopInput
  }

  export type StopCreateOrConnectWithoutLocationInput = {
    where: StopWhereUniqueInput
    create: XOR<StopCreateWithoutLocationInput, StopUncheckedCreateWithoutLocationInput>
  }

  export type StopCreateManyLocationInputEnvelope = {
    data: StopCreateManyLocationInput | StopCreateManyLocationInput[]
    skipDuplicates?: boolean
  }

  export type StopUpsertWithWhereUniqueWithoutLocationInput = {
    where: StopWhereUniqueInput
    update: XOR<StopUpdateWithoutLocationInput, StopUncheckedUpdateWithoutLocationInput>
    create: XOR<StopCreateWithoutLocationInput, StopUncheckedCreateWithoutLocationInput>
  }

  export type StopUpdateWithWhereUniqueWithoutLocationInput = {
    where: StopWhereUniqueInput
    data: XOR<StopUpdateWithoutLocationInput, StopUncheckedUpdateWithoutLocationInput>
  }

  export type StopUpdateManyWithWhereWithoutLocationInput = {
    where: StopScalarWhereInput
    data: XOR<StopUpdateManyMutationInput, StopUncheckedUpdateManyWithoutLocationInput>
  }

  export type StopScalarWhereInput = {
    AND?: StopScalarWhereInput | StopScalarWhereInput[]
    OR?: StopScalarWhereInput[]
    NOT?: StopScalarWhereInput | StopScalarWhereInput[]
    id?: BigIntFilter<"Stop"> | bigint | number
    locationId?: BigIntFilter<"Stop"> | bigint | number
    name?: StringFilter<"Stop"> | string
    code?: StringFilter<"Stop"> | string
  }

  export type LocationCreateWithoutStopsInput = {
    id?: bigint | number
    lat: Decimal | DecimalJsLike | number | string
    lon: Decimal | DecimalJsLike | number | string
  }

  export type LocationUncheckedCreateWithoutStopsInput = {
    id?: bigint | number
    lat: Decimal | DecimalJsLike | number | string
    lon: Decimal | DecimalJsLike | number | string
  }

  export type LocationCreateOrConnectWithoutStopsInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutStopsInput, LocationUncheckedCreateWithoutStopsInput>
  }

  export type RouteStopCreateWithoutStopInput = {
    id?: bigint | number
    stopOrder: number
    isActive?: boolean
    path?: string | null
    eta?: number | null
    waitTime?: number | null
    route: RouteCreateNestedOneWithoutRouteStopsInput
  }

  export type RouteStopUncheckedCreateWithoutStopInput = {
    id?: bigint | number
    routeId: bigint | number
    stopOrder: number
    isActive?: boolean
    path?: string | null
    eta?: number | null
    waitTime?: number | null
  }

  export type RouteStopCreateOrConnectWithoutStopInput = {
    where: RouteStopWhereUniqueInput
    create: XOR<RouteStopCreateWithoutStopInput, RouteStopUncheckedCreateWithoutStopInput>
  }

  export type RouteStopCreateManyStopInputEnvelope = {
    data: RouteStopCreateManyStopInput | RouteStopCreateManyStopInput[]
    skipDuplicates?: boolean
  }

  export type TripStopCreateWithoutStopInput = {
    id?: bigint | number
    stopOrder: number
    arrivalTime?: Date | string | null
    departureTime?: Date | string | null
    eta?: number | null
    trip: TripCreateNestedOneWithoutTripStopsInput
  }

  export type TripStopUncheckedCreateWithoutStopInput = {
    id?: bigint | number
    tripId: bigint | number
    stopOrder: number
    arrivalTime?: Date | string | null
    departureTime?: Date | string | null
    eta?: number | null
  }

  export type TripStopCreateOrConnectWithoutStopInput = {
    where: TripStopWhereUniqueInput
    create: XOR<TripStopCreateWithoutStopInput, TripStopUncheckedCreateWithoutStopInput>
  }

  export type TripStopCreateManyStopInputEnvelope = {
    data: TripStopCreateManyStopInput | TripStopCreateManyStopInput[]
    skipDuplicates?: boolean
  }

  export type LocationUpsertWithoutStopsInput = {
    update: XOR<LocationUpdateWithoutStopsInput, LocationUncheckedUpdateWithoutStopsInput>
    create: XOR<LocationCreateWithoutStopsInput, LocationUncheckedCreateWithoutStopsInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutStopsInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutStopsInput, LocationUncheckedUpdateWithoutStopsInput>
  }

  export type LocationUpdateWithoutStopsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    lat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lon?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type LocationUncheckedUpdateWithoutStopsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    lat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lon?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type RouteStopUpsertWithWhereUniqueWithoutStopInput = {
    where: RouteStopWhereUniqueInput
    update: XOR<RouteStopUpdateWithoutStopInput, RouteStopUncheckedUpdateWithoutStopInput>
    create: XOR<RouteStopCreateWithoutStopInput, RouteStopUncheckedCreateWithoutStopInput>
  }

  export type RouteStopUpdateWithWhereUniqueWithoutStopInput = {
    where: RouteStopWhereUniqueInput
    data: XOR<RouteStopUpdateWithoutStopInput, RouteStopUncheckedUpdateWithoutStopInput>
  }

  export type RouteStopUpdateManyWithWhereWithoutStopInput = {
    where: RouteStopScalarWhereInput
    data: XOR<RouteStopUpdateManyMutationInput, RouteStopUncheckedUpdateManyWithoutStopInput>
  }

  export type RouteStopScalarWhereInput = {
    AND?: RouteStopScalarWhereInput | RouteStopScalarWhereInput[]
    OR?: RouteStopScalarWhereInput[]
    NOT?: RouteStopScalarWhereInput | RouteStopScalarWhereInput[]
    id?: BigIntFilter<"RouteStop"> | bigint | number
    routeId?: BigIntFilter<"RouteStop"> | bigint | number
    stopId?: BigIntFilter<"RouteStop"> | bigint | number
    stopOrder?: IntFilter<"RouteStop"> | number
    isActive?: BoolFilter<"RouteStop"> | boolean
    path?: StringNullableFilter<"RouteStop"> | string | null
    eta?: IntNullableFilter<"RouteStop"> | number | null
    waitTime?: IntNullableFilter<"RouteStop"> | number | null
  }

  export type TripStopUpsertWithWhereUniqueWithoutStopInput = {
    where: TripStopWhereUniqueInput
    update: XOR<TripStopUpdateWithoutStopInput, TripStopUncheckedUpdateWithoutStopInput>
    create: XOR<TripStopCreateWithoutStopInput, TripStopUncheckedCreateWithoutStopInput>
  }

  export type TripStopUpdateWithWhereUniqueWithoutStopInput = {
    where: TripStopWhereUniqueInput
    data: XOR<TripStopUpdateWithoutStopInput, TripStopUncheckedUpdateWithoutStopInput>
  }

  export type TripStopUpdateManyWithWhereWithoutStopInput = {
    where: TripStopScalarWhereInput
    data: XOR<TripStopUpdateManyMutationInput, TripStopUncheckedUpdateManyWithoutStopInput>
  }

  export type TripStopScalarWhereInput = {
    AND?: TripStopScalarWhereInput | TripStopScalarWhereInput[]
    OR?: TripStopScalarWhereInput[]
    NOT?: TripStopScalarWhereInput | TripStopScalarWhereInput[]
    id?: BigIntFilter<"TripStop"> | bigint | number
    tripId?: BigIntFilter<"TripStop"> | bigint | number
    stopId?: BigIntFilter<"TripStop"> | bigint | number
    stopOrder?: IntFilter<"TripStop"> | number
    arrivalTime?: DateTimeNullableFilter<"TripStop"> | Date | string | null
    departureTime?: DateTimeNullableFilter<"TripStop"> | Date | string | null
    eta?: IntNullableFilter<"TripStop"> | number | null
  }

  export type RouteStopCreateWithoutRouteInput = {
    id?: bigint | number
    stopOrder: number
    isActive?: boolean
    path?: string | null
    eta?: number | null
    waitTime?: number | null
    stop: StopCreateNestedOneWithoutRouteStopsInput
  }

  export type RouteStopUncheckedCreateWithoutRouteInput = {
    id?: bigint | number
    stopId: bigint | number
    stopOrder: number
    isActive?: boolean
    path?: string | null
    eta?: number | null
    waitTime?: number | null
  }

  export type RouteStopCreateOrConnectWithoutRouteInput = {
    where: RouteStopWhereUniqueInput
    create: XOR<RouteStopCreateWithoutRouteInput, RouteStopUncheckedCreateWithoutRouteInput>
  }

  export type RouteStopCreateManyRouteInputEnvelope = {
    data: RouteStopCreateManyRouteInput | RouteStopCreateManyRouteInput[]
    skipDuplicates?: boolean
  }

  export type TripCreateWithoutRouteInput = {
    id?: bigint | number
    startTime: Date | string
    endTime?: Date | string | null
    startLocation: bigint | number
    endLocation?: bigint | number | null
    averageSpeed?: Decimal | DecimalJsLike | number | string | null
    maxSpeed?: Decimal | DecimalJsLike | number | string | null
    totalDistance?: Decimal | DecimalJsLike | number | string | null
    totalDuration?: number | null
    idleTime?: number | null
    path?: string | null
    driver: DriverCreateNestedOneWithoutTripsInput
    vehicle: VehicleCreateNestedOneWithoutTripsInput
    tripStops?: TripStopCreateNestedManyWithoutTripInput
  }

  export type TripUncheckedCreateWithoutRouteInput = {
    id?: bigint | number
    startTime: Date | string
    endTime?: Date | string | null
    startLocation: bigint | number
    endLocation?: bigint | number | null
    driverId: bigint | number
    vehicleId: bigint | number
    averageSpeed?: Decimal | DecimalJsLike | number | string | null
    maxSpeed?: Decimal | DecimalJsLike | number | string | null
    totalDistance?: Decimal | DecimalJsLike | number | string | null
    totalDuration?: number | null
    idleTime?: number | null
    path?: string | null
    tripStops?: TripStopUncheckedCreateNestedManyWithoutTripInput
  }

  export type TripCreateOrConnectWithoutRouteInput = {
    where: TripWhereUniqueInput
    create: XOR<TripCreateWithoutRouteInput, TripUncheckedCreateWithoutRouteInput>
  }

  export type TripCreateManyRouteInputEnvelope = {
    data: TripCreateManyRouteInput | TripCreateManyRouteInput[]
    skipDuplicates?: boolean
  }

  export type TripDutyCreateWithoutRouteInput = {
    id?: bigint | number
    duty: DutyCreateNestedOneWithoutTripDutiesInput
  }

  export type TripDutyUncheckedCreateWithoutRouteInput = {
    id?: bigint | number
    dutyId: bigint | number
  }

  export type TripDutyCreateOrConnectWithoutRouteInput = {
    where: TripDutyWhereUniqueInput
    create: XOR<TripDutyCreateWithoutRouteInput, TripDutyUncheckedCreateWithoutRouteInput>
  }

  export type TripDutyCreateManyRouteInputEnvelope = {
    data: TripDutyCreateManyRouteInput | TripDutyCreateManyRouteInput[]
    skipDuplicates?: boolean
  }

  export type RouteStopUpsertWithWhereUniqueWithoutRouteInput = {
    where: RouteStopWhereUniqueInput
    update: XOR<RouteStopUpdateWithoutRouteInput, RouteStopUncheckedUpdateWithoutRouteInput>
    create: XOR<RouteStopCreateWithoutRouteInput, RouteStopUncheckedCreateWithoutRouteInput>
  }

  export type RouteStopUpdateWithWhereUniqueWithoutRouteInput = {
    where: RouteStopWhereUniqueInput
    data: XOR<RouteStopUpdateWithoutRouteInput, RouteStopUncheckedUpdateWithoutRouteInput>
  }

  export type RouteStopUpdateManyWithWhereWithoutRouteInput = {
    where: RouteStopScalarWhereInput
    data: XOR<RouteStopUpdateManyMutationInput, RouteStopUncheckedUpdateManyWithoutRouteInput>
  }

  export type TripUpsertWithWhereUniqueWithoutRouteInput = {
    where: TripWhereUniqueInput
    update: XOR<TripUpdateWithoutRouteInput, TripUncheckedUpdateWithoutRouteInput>
    create: XOR<TripCreateWithoutRouteInput, TripUncheckedCreateWithoutRouteInput>
  }

  export type TripUpdateWithWhereUniqueWithoutRouteInput = {
    where: TripWhereUniqueInput
    data: XOR<TripUpdateWithoutRouteInput, TripUncheckedUpdateWithoutRouteInput>
  }

  export type TripUpdateManyWithWhereWithoutRouteInput = {
    where: TripScalarWhereInput
    data: XOR<TripUpdateManyMutationInput, TripUncheckedUpdateManyWithoutRouteInput>
  }

  export type TripDutyUpsertWithWhereUniqueWithoutRouteInput = {
    where: TripDutyWhereUniqueInput
    update: XOR<TripDutyUpdateWithoutRouteInput, TripDutyUncheckedUpdateWithoutRouteInput>
    create: XOR<TripDutyCreateWithoutRouteInput, TripDutyUncheckedCreateWithoutRouteInput>
  }

  export type TripDutyUpdateWithWhereUniqueWithoutRouteInput = {
    where: TripDutyWhereUniqueInput
    data: XOR<TripDutyUpdateWithoutRouteInput, TripDutyUncheckedUpdateWithoutRouteInput>
  }

  export type TripDutyUpdateManyWithWhereWithoutRouteInput = {
    where: TripDutyScalarWhereInput
    data: XOR<TripDutyUpdateManyMutationInput, TripDutyUncheckedUpdateManyWithoutRouteInput>
  }

  export type TripDutyScalarWhereInput = {
    AND?: TripDutyScalarWhereInput | TripDutyScalarWhereInput[]
    OR?: TripDutyScalarWhereInput[]
    NOT?: TripDutyScalarWhereInput | TripDutyScalarWhereInput[]
    id?: BigIntFilter<"TripDuty"> | bigint | number
    dutyId?: BigIntFilter<"TripDuty"> | bigint | number
    routeId?: BigIntFilter<"TripDuty"> | bigint | number
  }

  export type RouteCreateWithoutRouteStopsInput = {
    id?: bigint | number
    name: string
    code: string
    isActive?: boolean
    totalEstimatedDuration: number
    trips?: TripCreateNestedManyWithoutRouteInput
    TripDuty?: TripDutyCreateNestedManyWithoutRouteInput
  }

  export type RouteUncheckedCreateWithoutRouteStopsInput = {
    id?: bigint | number
    name: string
    code: string
    isActive?: boolean
    totalEstimatedDuration: number
    trips?: TripUncheckedCreateNestedManyWithoutRouteInput
    TripDuty?: TripDutyUncheckedCreateNestedManyWithoutRouteInput
  }

  export type RouteCreateOrConnectWithoutRouteStopsInput = {
    where: RouteWhereUniqueInput
    create: XOR<RouteCreateWithoutRouteStopsInput, RouteUncheckedCreateWithoutRouteStopsInput>
  }

  export type StopCreateWithoutRouteStopsInput = {
    id?: bigint | number
    name: string
    code: string
    location: LocationCreateNestedOneWithoutStopsInput
    tripStops?: TripStopCreateNestedManyWithoutStopInput
  }

  export type StopUncheckedCreateWithoutRouteStopsInput = {
    id?: bigint | number
    locationId: bigint | number
    name: string
    code: string
    tripStops?: TripStopUncheckedCreateNestedManyWithoutStopInput
  }

  export type StopCreateOrConnectWithoutRouteStopsInput = {
    where: StopWhereUniqueInput
    create: XOR<StopCreateWithoutRouteStopsInput, StopUncheckedCreateWithoutRouteStopsInput>
  }

  export type RouteUpsertWithoutRouteStopsInput = {
    update: XOR<RouteUpdateWithoutRouteStopsInput, RouteUncheckedUpdateWithoutRouteStopsInput>
    create: XOR<RouteCreateWithoutRouteStopsInput, RouteUncheckedCreateWithoutRouteStopsInput>
    where?: RouteWhereInput
  }

  export type RouteUpdateToOneWithWhereWithoutRouteStopsInput = {
    where?: RouteWhereInput
    data: XOR<RouteUpdateWithoutRouteStopsInput, RouteUncheckedUpdateWithoutRouteStopsInput>
  }

  export type RouteUpdateWithoutRouteStopsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    totalEstimatedDuration?: IntFieldUpdateOperationsInput | number
    trips?: TripUpdateManyWithoutRouteNestedInput
    TripDuty?: TripDutyUpdateManyWithoutRouteNestedInput
  }

  export type RouteUncheckedUpdateWithoutRouteStopsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    totalEstimatedDuration?: IntFieldUpdateOperationsInput | number
    trips?: TripUncheckedUpdateManyWithoutRouteNestedInput
    TripDuty?: TripDutyUncheckedUpdateManyWithoutRouteNestedInput
  }

  export type StopUpsertWithoutRouteStopsInput = {
    update: XOR<StopUpdateWithoutRouteStopsInput, StopUncheckedUpdateWithoutRouteStopsInput>
    create: XOR<StopCreateWithoutRouteStopsInput, StopUncheckedCreateWithoutRouteStopsInput>
    where?: StopWhereInput
  }

  export type StopUpdateToOneWithWhereWithoutRouteStopsInput = {
    where?: StopWhereInput
    data: XOR<StopUpdateWithoutRouteStopsInput, StopUncheckedUpdateWithoutRouteStopsInput>
  }

  export type StopUpdateWithoutRouteStopsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    location?: LocationUpdateOneRequiredWithoutStopsNestedInput
    tripStops?: TripStopUpdateManyWithoutStopNestedInput
  }

  export type StopUncheckedUpdateWithoutRouteStopsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    locationId?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    tripStops?: TripStopUncheckedUpdateManyWithoutStopNestedInput
  }

  export type RouteCreateWithoutTripsInput = {
    id?: bigint | number
    name: string
    code: string
    isActive?: boolean
    totalEstimatedDuration: number
    routeStops?: RouteStopCreateNestedManyWithoutRouteInput
    TripDuty?: TripDutyCreateNestedManyWithoutRouteInput
  }

  export type RouteUncheckedCreateWithoutTripsInput = {
    id?: bigint | number
    name: string
    code: string
    isActive?: boolean
    totalEstimatedDuration: number
    routeStops?: RouteStopUncheckedCreateNestedManyWithoutRouteInput
    TripDuty?: TripDutyUncheckedCreateNestedManyWithoutRouteInput
  }

  export type RouteCreateOrConnectWithoutTripsInput = {
    where: RouteWhereUniqueInput
    create: XOR<RouteCreateWithoutTripsInput, RouteUncheckedCreateWithoutTripsInput>
  }

  export type DriverCreateWithoutTripsInput = {
    id?: bigint | number
    licenseExpiry?: Date | string | null
    shifts?: ShiftCreateNestedManyWithoutDriverInput
    user: UserCreateNestedOneWithoutDriversInput
    Duty?: DutyCreateNestedManyWithoutDriverInput
  }

  export type DriverUncheckedCreateWithoutTripsInput = {
    id?: bigint | number
    userId: bigint | number
    licenseExpiry?: Date | string | null
    shifts?: ShiftUncheckedCreateNestedManyWithoutDriverInput
    Duty?: DutyUncheckedCreateNestedManyWithoutDriverInput
  }

  export type DriverCreateOrConnectWithoutTripsInput = {
    where: DriverWhereUniqueInput
    create: XOR<DriverCreateWithoutTripsInput, DriverUncheckedCreateWithoutTripsInput>
  }

  export type VehicleCreateWithoutTripsInput = {
    id?: bigint | number
    plateNo: string
    fleetNo: string
    model: VehicleModelCreateNestedOneWithoutVehiclesInput
    shifts?: ShiftCreateNestedManyWithoutVehicleInput
    telemetry?: VehicleTelemetryCreateNestedManyWithoutVehicleInput
    telemetryHistory?: VehicleTelemetryHistoryCreateNestedManyWithoutVehicleInput
    Duty?: DutyCreateNestedManyWithoutVehicleInput
  }

  export type VehicleUncheckedCreateWithoutTripsInput = {
    id?: bigint | number
    plateNo: string
    fleetNo: string
    modelId: bigint | number
    shifts?: ShiftUncheckedCreateNestedManyWithoutVehicleInput
    telemetry?: VehicleTelemetryUncheckedCreateNestedManyWithoutVehicleInput
    telemetryHistory?: VehicleTelemetryHistoryUncheckedCreateNestedManyWithoutVehicleInput
    Duty?: DutyUncheckedCreateNestedManyWithoutVehicleInput
  }

  export type VehicleCreateOrConnectWithoutTripsInput = {
    where: VehicleWhereUniqueInput
    create: XOR<VehicleCreateWithoutTripsInput, VehicleUncheckedCreateWithoutTripsInput>
  }

  export type TripStopCreateWithoutTripInput = {
    id?: bigint | number
    stopOrder: number
    arrivalTime?: Date | string | null
    departureTime?: Date | string | null
    eta?: number | null
    stop: StopCreateNestedOneWithoutTripStopsInput
  }

  export type TripStopUncheckedCreateWithoutTripInput = {
    id?: bigint | number
    stopId: bigint | number
    stopOrder: number
    arrivalTime?: Date | string | null
    departureTime?: Date | string | null
    eta?: number | null
  }

  export type TripStopCreateOrConnectWithoutTripInput = {
    where: TripStopWhereUniqueInput
    create: XOR<TripStopCreateWithoutTripInput, TripStopUncheckedCreateWithoutTripInput>
  }

  export type TripStopCreateManyTripInputEnvelope = {
    data: TripStopCreateManyTripInput | TripStopCreateManyTripInput[]
    skipDuplicates?: boolean
  }

  export type RouteUpsertWithoutTripsInput = {
    update: XOR<RouteUpdateWithoutTripsInput, RouteUncheckedUpdateWithoutTripsInput>
    create: XOR<RouteCreateWithoutTripsInput, RouteUncheckedCreateWithoutTripsInput>
    where?: RouteWhereInput
  }

  export type RouteUpdateToOneWithWhereWithoutTripsInput = {
    where?: RouteWhereInput
    data: XOR<RouteUpdateWithoutTripsInput, RouteUncheckedUpdateWithoutTripsInput>
  }

  export type RouteUpdateWithoutTripsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    totalEstimatedDuration?: IntFieldUpdateOperationsInput | number
    routeStops?: RouteStopUpdateManyWithoutRouteNestedInput
    TripDuty?: TripDutyUpdateManyWithoutRouteNestedInput
  }

  export type RouteUncheckedUpdateWithoutTripsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    totalEstimatedDuration?: IntFieldUpdateOperationsInput | number
    routeStops?: RouteStopUncheckedUpdateManyWithoutRouteNestedInput
    TripDuty?: TripDutyUncheckedUpdateManyWithoutRouteNestedInput
  }

  export type DriverUpsertWithoutTripsInput = {
    update: XOR<DriverUpdateWithoutTripsInput, DriverUncheckedUpdateWithoutTripsInput>
    create: XOR<DriverCreateWithoutTripsInput, DriverUncheckedCreateWithoutTripsInput>
    where?: DriverWhereInput
  }

  export type DriverUpdateToOneWithWhereWithoutTripsInput = {
    where?: DriverWhereInput
    data: XOR<DriverUpdateWithoutTripsInput, DriverUncheckedUpdateWithoutTripsInput>
  }

  export type DriverUpdateWithoutTripsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    licenseExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shifts?: ShiftUpdateManyWithoutDriverNestedInput
    user?: UserUpdateOneRequiredWithoutDriversNestedInput
    Duty?: DutyUpdateManyWithoutDriverNestedInput
  }

  export type DriverUncheckedUpdateWithoutTripsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: BigIntFieldUpdateOperationsInput | bigint | number
    licenseExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shifts?: ShiftUncheckedUpdateManyWithoutDriverNestedInput
    Duty?: DutyUncheckedUpdateManyWithoutDriverNestedInput
  }

  export type VehicleUpsertWithoutTripsInput = {
    update: XOR<VehicleUpdateWithoutTripsInput, VehicleUncheckedUpdateWithoutTripsInput>
    create: XOR<VehicleCreateWithoutTripsInput, VehicleUncheckedCreateWithoutTripsInput>
    where?: VehicleWhereInput
  }

  export type VehicleUpdateToOneWithWhereWithoutTripsInput = {
    where?: VehicleWhereInput
    data: XOR<VehicleUpdateWithoutTripsInput, VehicleUncheckedUpdateWithoutTripsInput>
  }

  export type VehicleUpdateWithoutTripsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    plateNo?: StringFieldUpdateOperationsInput | string
    fleetNo?: StringFieldUpdateOperationsInput | string
    model?: VehicleModelUpdateOneRequiredWithoutVehiclesNestedInput
    shifts?: ShiftUpdateManyWithoutVehicleNestedInput
    telemetry?: VehicleTelemetryUpdateManyWithoutVehicleNestedInput
    telemetryHistory?: VehicleTelemetryHistoryUpdateManyWithoutVehicleNestedInput
    Duty?: DutyUpdateManyWithoutVehicleNestedInput
  }

  export type VehicleUncheckedUpdateWithoutTripsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    plateNo?: StringFieldUpdateOperationsInput | string
    fleetNo?: StringFieldUpdateOperationsInput | string
    modelId?: BigIntFieldUpdateOperationsInput | bigint | number
    shifts?: ShiftUncheckedUpdateManyWithoutVehicleNestedInput
    telemetry?: VehicleTelemetryUncheckedUpdateManyWithoutVehicleNestedInput
    telemetryHistory?: VehicleTelemetryHistoryUncheckedUpdateManyWithoutVehicleNestedInput
    Duty?: DutyUncheckedUpdateManyWithoutVehicleNestedInput
  }

  export type TripStopUpsertWithWhereUniqueWithoutTripInput = {
    where: TripStopWhereUniqueInput
    update: XOR<TripStopUpdateWithoutTripInput, TripStopUncheckedUpdateWithoutTripInput>
    create: XOR<TripStopCreateWithoutTripInput, TripStopUncheckedCreateWithoutTripInput>
  }

  export type TripStopUpdateWithWhereUniqueWithoutTripInput = {
    where: TripStopWhereUniqueInput
    data: XOR<TripStopUpdateWithoutTripInput, TripStopUncheckedUpdateWithoutTripInput>
  }

  export type TripStopUpdateManyWithWhereWithoutTripInput = {
    where: TripStopScalarWhereInput
    data: XOR<TripStopUpdateManyMutationInput, TripStopUncheckedUpdateManyWithoutTripInput>
  }

  export type TripCreateWithoutTripStopsInput = {
    id?: bigint | number
    startTime: Date | string
    endTime?: Date | string | null
    startLocation: bigint | number
    endLocation?: bigint | number | null
    averageSpeed?: Decimal | DecimalJsLike | number | string | null
    maxSpeed?: Decimal | DecimalJsLike | number | string | null
    totalDistance?: Decimal | DecimalJsLike | number | string | null
    totalDuration?: number | null
    idleTime?: number | null
    path?: string | null
    route: RouteCreateNestedOneWithoutTripsInput
    driver: DriverCreateNestedOneWithoutTripsInput
    vehicle: VehicleCreateNestedOneWithoutTripsInput
  }

  export type TripUncheckedCreateWithoutTripStopsInput = {
    id?: bigint | number
    routeId: bigint | number
    startTime: Date | string
    endTime?: Date | string | null
    startLocation: bigint | number
    endLocation?: bigint | number | null
    driverId: bigint | number
    vehicleId: bigint | number
    averageSpeed?: Decimal | DecimalJsLike | number | string | null
    maxSpeed?: Decimal | DecimalJsLike | number | string | null
    totalDistance?: Decimal | DecimalJsLike | number | string | null
    totalDuration?: number | null
    idleTime?: number | null
    path?: string | null
  }

  export type TripCreateOrConnectWithoutTripStopsInput = {
    where: TripWhereUniqueInput
    create: XOR<TripCreateWithoutTripStopsInput, TripUncheckedCreateWithoutTripStopsInput>
  }

  export type StopCreateWithoutTripStopsInput = {
    id?: bigint | number
    name: string
    code: string
    location: LocationCreateNestedOneWithoutStopsInput
    routeStops?: RouteStopCreateNestedManyWithoutStopInput
  }

  export type StopUncheckedCreateWithoutTripStopsInput = {
    id?: bigint | number
    locationId: bigint | number
    name: string
    code: string
    routeStops?: RouteStopUncheckedCreateNestedManyWithoutStopInput
  }

  export type StopCreateOrConnectWithoutTripStopsInput = {
    where: StopWhereUniqueInput
    create: XOR<StopCreateWithoutTripStopsInput, StopUncheckedCreateWithoutTripStopsInput>
  }

  export type TripUpsertWithoutTripStopsInput = {
    update: XOR<TripUpdateWithoutTripStopsInput, TripUncheckedUpdateWithoutTripStopsInput>
    create: XOR<TripCreateWithoutTripStopsInput, TripUncheckedCreateWithoutTripStopsInput>
    where?: TripWhereInput
  }

  export type TripUpdateToOneWithWhereWithoutTripStopsInput = {
    where?: TripWhereInput
    data: XOR<TripUpdateWithoutTripStopsInput, TripUncheckedUpdateWithoutTripStopsInput>
  }

  export type TripUpdateWithoutTripStopsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startLocation?: BigIntFieldUpdateOperationsInput | bigint | number
    endLocation?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    averageSpeed?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxSpeed?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalDistance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalDuration?: NullableIntFieldUpdateOperationsInput | number | null
    idleTime?: NullableIntFieldUpdateOperationsInput | number | null
    path?: NullableStringFieldUpdateOperationsInput | string | null
    route?: RouteUpdateOneRequiredWithoutTripsNestedInput
    driver?: DriverUpdateOneRequiredWithoutTripsNestedInput
    vehicle?: VehicleUpdateOneRequiredWithoutTripsNestedInput
  }

  export type TripUncheckedUpdateWithoutTripStopsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    routeId?: BigIntFieldUpdateOperationsInput | bigint | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startLocation?: BigIntFieldUpdateOperationsInput | bigint | number
    endLocation?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    driverId?: BigIntFieldUpdateOperationsInput | bigint | number
    vehicleId?: BigIntFieldUpdateOperationsInput | bigint | number
    averageSpeed?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxSpeed?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalDistance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalDuration?: NullableIntFieldUpdateOperationsInput | number | null
    idleTime?: NullableIntFieldUpdateOperationsInput | number | null
    path?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StopUpsertWithoutTripStopsInput = {
    update: XOR<StopUpdateWithoutTripStopsInput, StopUncheckedUpdateWithoutTripStopsInput>
    create: XOR<StopCreateWithoutTripStopsInput, StopUncheckedCreateWithoutTripStopsInput>
    where?: StopWhereInput
  }

  export type StopUpdateToOneWithWhereWithoutTripStopsInput = {
    where?: StopWhereInput
    data: XOR<StopUpdateWithoutTripStopsInput, StopUncheckedUpdateWithoutTripStopsInput>
  }

  export type StopUpdateWithoutTripStopsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    location?: LocationUpdateOneRequiredWithoutStopsNestedInput
    routeStops?: RouteStopUpdateManyWithoutStopNestedInput
  }

  export type StopUncheckedUpdateWithoutTripStopsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    locationId?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    routeStops?: RouteStopUncheckedUpdateManyWithoutStopNestedInput
  }

  export type VehicleCreateWithoutTelemetryInput = {
    id?: bigint | number
    plateNo: string
    fleetNo: string
    model: VehicleModelCreateNestedOneWithoutVehiclesInput
    trips?: TripCreateNestedManyWithoutVehicleInput
    shifts?: ShiftCreateNestedManyWithoutVehicleInput
    telemetryHistory?: VehicleTelemetryHistoryCreateNestedManyWithoutVehicleInput
    Duty?: DutyCreateNestedManyWithoutVehicleInput
  }

  export type VehicleUncheckedCreateWithoutTelemetryInput = {
    id?: bigint | number
    plateNo: string
    fleetNo: string
    modelId: bigint | number
    trips?: TripUncheckedCreateNestedManyWithoutVehicleInput
    shifts?: ShiftUncheckedCreateNestedManyWithoutVehicleInput
    telemetryHistory?: VehicleTelemetryHistoryUncheckedCreateNestedManyWithoutVehicleInput
    Duty?: DutyUncheckedCreateNestedManyWithoutVehicleInput
  }

  export type VehicleCreateOrConnectWithoutTelemetryInput = {
    where: VehicleWhereUniqueInput
    create: XOR<VehicleCreateWithoutTelemetryInput, VehicleUncheckedCreateWithoutTelemetryInput>
  }

  export type VehicleUpsertWithoutTelemetryInput = {
    update: XOR<VehicleUpdateWithoutTelemetryInput, VehicleUncheckedUpdateWithoutTelemetryInput>
    create: XOR<VehicleCreateWithoutTelemetryInput, VehicleUncheckedCreateWithoutTelemetryInput>
    where?: VehicleWhereInput
  }

  export type VehicleUpdateToOneWithWhereWithoutTelemetryInput = {
    where?: VehicleWhereInput
    data: XOR<VehicleUpdateWithoutTelemetryInput, VehicleUncheckedUpdateWithoutTelemetryInput>
  }

  export type VehicleUpdateWithoutTelemetryInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    plateNo?: StringFieldUpdateOperationsInput | string
    fleetNo?: StringFieldUpdateOperationsInput | string
    model?: VehicleModelUpdateOneRequiredWithoutVehiclesNestedInput
    trips?: TripUpdateManyWithoutVehicleNestedInput
    shifts?: ShiftUpdateManyWithoutVehicleNestedInput
    telemetryHistory?: VehicleTelemetryHistoryUpdateManyWithoutVehicleNestedInput
    Duty?: DutyUpdateManyWithoutVehicleNestedInput
  }

  export type VehicleUncheckedUpdateWithoutTelemetryInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    plateNo?: StringFieldUpdateOperationsInput | string
    fleetNo?: StringFieldUpdateOperationsInput | string
    modelId?: BigIntFieldUpdateOperationsInput | bigint | number
    trips?: TripUncheckedUpdateManyWithoutVehicleNestedInput
    shifts?: ShiftUncheckedUpdateManyWithoutVehicleNestedInput
    telemetryHistory?: VehicleTelemetryHistoryUncheckedUpdateManyWithoutVehicleNestedInput
    Duty?: DutyUncheckedUpdateManyWithoutVehicleNestedInput
  }

  export type VehicleCreateWithoutTelemetryHistoryInput = {
    id?: bigint | number
    plateNo: string
    fleetNo: string
    model: VehicleModelCreateNestedOneWithoutVehiclesInput
    trips?: TripCreateNestedManyWithoutVehicleInput
    shifts?: ShiftCreateNestedManyWithoutVehicleInput
    telemetry?: VehicleTelemetryCreateNestedManyWithoutVehicleInput
    Duty?: DutyCreateNestedManyWithoutVehicleInput
  }

  export type VehicleUncheckedCreateWithoutTelemetryHistoryInput = {
    id?: bigint | number
    plateNo: string
    fleetNo: string
    modelId: bigint | number
    trips?: TripUncheckedCreateNestedManyWithoutVehicleInput
    shifts?: ShiftUncheckedCreateNestedManyWithoutVehicleInput
    telemetry?: VehicleTelemetryUncheckedCreateNestedManyWithoutVehicleInput
    Duty?: DutyUncheckedCreateNestedManyWithoutVehicleInput
  }

  export type VehicleCreateOrConnectWithoutTelemetryHistoryInput = {
    where: VehicleWhereUniqueInput
    create: XOR<VehicleCreateWithoutTelemetryHistoryInput, VehicleUncheckedCreateWithoutTelemetryHistoryInput>
  }

  export type VehicleUpsertWithoutTelemetryHistoryInput = {
    update: XOR<VehicleUpdateWithoutTelemetryHistoryInput, VehicleUncheckedUpdateWithoutTelemetryHistoryInput>
    create: XOR<VehicleCreateWithoutTelemetryHistoryInput, VehicleUncheckedCreateWithoutTelemetryHistoryInput>
    where?: VehicleWhereInput
  }

  export type VehicleUpdateToOneWithWhereWithoutTelemetryHistoryInput = {
    where?: VehicleWhereInput
    data: XOR<VehicleUpdateWithoutTelemetryHistoryInput, VehicleUncheckedUpdateWithoutTelemetryHistoryInput>
  }

  export type VehicleUpdateWithoutTelemetryHistoryInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    plateNo?: StringFieldUpdateOperationsInput | string
    fleetNo?: StringFieldUpdateOperationsInput | string
    model?: VehicleModelUpdateOneRequiredWithoutVehiclesNestedInput
    trips?: TripUpdateManyWithoutVehicleNestedInput
    shifts?: ShiftUpdateManyWithoutVehicleNestedInput
    telemetry?: VehicleTelemetryUpdateManyWithoutVehicleNestedInput
    Duty?: DutyUpdateManyWithoutVehicleNestedInput
  }

  export type VehicleUncheckedUpdateWithoutTelemetryHistoryInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    plateNo?: StringFieldUpdateOperationsInput | string
    fleetNo?: StringFieldUpdateOperationsInput | string
    modelId?: BigIntFieldUpdateOperationsInput | bigint | number
    trips?: TripUncheckedUpdateManyWithoutVehicleNestedInput
    shifts?: ShiftUncheckedUpdateManyWithoutVehicleNestedInput
    telemetry?: VehicleTelemetryUncheckedUpdateManyWithoutVehicleNestedInput
    Duty?: DutyUncheckedUpdateManyWithoutVehicleNestedInput
  }

  export type VehicleCreateWithoutShiftsInput = {
    id?: bigint | number
    plateNo: string
    fleetNo: string
    model: VehicleModelCreateNestedOneWithoutVehiclesInput
    trips?: TripCreateNestedManyWithoutVehicleInput
    telemetry?: VehicleTelemetryCreateNestedManyWithoutVehicleInput
    telemetryHistory?: VehicleTelemetryHistoryCreateNestedManyWithoutVehicleInput
    Duty?: DutyCreateNestedManyWithoutVehicleInput
  }

  export type VehicleUncheckedCreateWithoutShiftsInput = {
    id?: bigint | number
    plateNo: string
    fleetNo: string
    modelId: bigint | number
    trips?: TripUncheckedCreateNestedManyWithoutVehicleInput
    telemetry?: VehicleTelemetryUncheckedCreateNestedManyWithoutVehicleInput
    telemetryHistory?: VehicleTelemetryHistoryUncheckedCreateNestedManyWithoutVehicleInput
    Duty?: DutyUncheckedCreateNestedManyWithoutVehicleInput
  }

  export type VehicleCreateOrConnectWithoutShiftsInput = {
    where: VehicleWhereUniqueInput
    create: XOR<VehicleCreateWithoutShiftsInput, VehicleUncheckedCreateWithoutShiftsInput>
  }

  export type DriverCreateWithoutShiftsInput = {
    id?: bigint | number
    licenseExpiry?: Date | string | null
    trips?: TripCreateNestedManyWithoutDriverInput
    user: UserCreateNestedOneWithoutDriversInput
    Duty?: DutyCreateNestedManyWithoutDriverInput
  }

  export type DriverUncheckedCreateWithoutShiftsInput = {
    id?: bigint | number
    userId: bigint | number
    licenseExpiry?: Date | string | null
    trips?: TripUncheckedCreateNestedManyWithoutDriverInput
    Duty?: DutyUncheckedCreateNestedManyWithoutDriverInput
  }

  export type DriverCreateOrConnectWithoutShiftsInput = {
    where: DriverWhereUniqueInput
    create: XOR<DriverCreateWithoutShiftsInput, DriverUncheckedCreateWithoutShiftsInput>
  }

  export type VehicleUpsertWithoutShiftsInput = {
    update: XOR<VehicleUpdateWithoutShiftsInput, VehicleUncheckedUpdateWithoutShiftsInput>
    create: XOR<VehicleCreateWithoutShiftsInput, VehicleUncheckedCreateWithoutShiftsInput>
    where?: VehicleWhereInput
  }

  export type VehicleUpdateToOneWithWhereWithoutShiftsInput = {
    where?: VehicleWhereInput
    data: XOR<VehicleUpdateWithoutShiftsInput, VehicleUncheckedUpdateWithoutShiftsInput>
  }

  export type VehicleUpdateWithoutShiftsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    plateNo?: StringFieldUpdateOperationsInput | string
    fleetNo?: StringFieldUpdateOperationsInput | string
    model?: VehicleModelUpdateOneRequiredWithoutVehiclesNestedInput
    trips?: TripUpdateManyWithoutVehicleNestedInput
    telemetry?: VehicleTelemetryUpdateManyWithoutVehicleNestedInput
    telemetryHistory?: VehicleTelemetryHistoryUpdateManyWithoutVehicleNestedInput
    Duty?: DutyUpdateManyWithoutVehicleNestedInput
  }

  export type VehicleUncheckedUpdateWithoutShiftsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    plateNo?: StringFieldUpdateOperationsInput | string
    fleetNo?: StringFieldUpdateOperationsInput | string
    modelId?: BigIntFieldUpdateOperationsInput | bigint | number
    trips?: TripUncheckedUpdateManyWithoutVehicleNestedInput
    telemetry?: VehicleTelemetryUncheckedUpdateManyWithoutVehicleNestedInput
    telemetryHistory?: VehicleTelemetryHistoryUncheckedUpdateManyWithoutVehicleNestedInput
    Duty?: DutyUncheckedUpdateManyWithoutVehicleNestedInput
  }

  export type DriverUpsertWithoutShiftsInput = {
    update: XOR<DriverUpdateWithoutShiftsInput, DriverUncheckedUpdateWithoutShiftsInput>
    create: XOR<DriverCreateWithoutShiftsInput, DriverUncheckedCreateWithoutShiftsInput>
    where?: DriverWhereInput
  }

  export type DriverUpdateToOneWithWhereWithoutShiftsInput = {
    where?: DriverWhereInput
    data: XOR<DriverUpdateWithoutShiftsInput, DriverUncheckedUpdateWithoutShiftsInput>
  }

  export type DriverUpdateWithoutShiftsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    licenseExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trips?: TripUpdateManyWithoutDriverNestedInput
    user?: UserUpdateOneRequiredWithoutDriversNestedInput
    Duty?: DutyUpdateManyWithoutDriverNestedInput
  }

  export type DriverUncheckedUpdateWithoutShiftsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: BigIntFieldUpdateOperationsInput | bigint | number
    licenseExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trips?: TripUncheckedUpdateManyWithoutDriverNestedInput
    Duty?: DutyUncheckedUpdateManyWithoutDriverNestedInput
  }

  export type DutyTemplateCreateWithoutScheduleInput = {
    id?: bigint | number
    name?: string | null
    startTime: Date | string
    endTime: Date | string
    dutyType: $Enums.DutyType
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicleBlockTemplate?: VehicleBlockTemplateCreateNestedOneWithoutDutyTemplateInput
    driverRunTemplate?: DriverRunTemplateCreateNestedOneWithoutDutyTemplateInput
  }

  export type DutyTemplateUncheckedCreateWithoutScheduleInput = {
    id?: bigint | number
    name?: string | null
    startTime: Date | string
    endTime: Date | string
    dutyType: $Enums.DutyType
    vehicleBlockTemplateId?: bigint | number | null
    driverRunTemplateId?: bigint | number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DutyTemplateCreateOrConnectWithoutScheduleInput = {
    where: DutyTemplateWhereUniqueInput
    create: XOR<DutyTemplateCreateWithoutScheduleInput, DutyTemplateUncheckedCreateWithoutScheduleInput>
  }

  export type DutyTemplateCreateManyScheduleInputEnvelope = {
    data: DutyTemplateCreateManyScheduleInput | DutyTemplateCreateManyScheduleInput[]
    skipDuplicates?: boolean
  }

  export type VehicleBlockTemplateCreateWithoutScheduleInput = {
    id?: bigint | number
    code: string
    color: string
    DutyTemplate?: DutyTemplateCreateNestedManyWithoutVehicleBlockTemplateInput
    VehicleBlock?: VehicleBlockCreateNestedManyWithoutVehicleBlockTemplateInput
  }

  export type VehicleBlockTemplateUncheckedCreateWithoutScheduleInput = {
    id?: bigint | number
    code: string
    color: string
    DutyTemplate?: DutyTemplateUncheckedCreateNestedManyWithoutVehicleBlockTemplateInput
    VehicleBlock?: VehicleBlockUncheckedCreateNestedManyWithoutVehicleBlockTemplateInput
  }

  export type VehicleBlockTemplateCreateOrConnectWithoutScheduleInput = {
    where: VehicleBlockTemplateWhereUniqueInput
    create: XOR<VehicleBlockTemplateCreateWithoutScheduleInput, VehicleBlockTemplateUncheckedCreateWithoutScheduleInput>
  }

  export type VehicleBlockTemplateCreateManyScheduleInputEnvelope = {
    data: VehicleBlockTemplateCreateManyScheduleInput | VehicleBlockTemplateCreateManyScheduleInput[]
    skipDuplicates?: boolean
  }

  export type DriverRunTemplateCreateWithoutScheduleInput = {
    id?: bigint | number
    code: string
    color: string
    DutyTemplate?: DutyTemplateCreateNestedManyWithoutDriverRunTemplateInput
    DriverRun?: DriverRunCreateNestedManyWithoutDriverRunTemplateInput
  }

  export type DriverRunTemplateUncheckedCreateWithoutScheduleInput = {
    id?: bigint | number
    code: string
    color: string
    DutyTemplate?: DutyTemplateUncheckedCreateNestedManyWithoutDriverRunTemplateInput
    DriverRun?: DriverRunUncheckedCreateNestedManyWithoutDriverRunTemplateInput
  }

  export type DriverRunTemplateCreateOrConnectWithoutScheduleInput = {
    where: DriverRunTemplateWhereUniqueInput
    create: XOR<DriverRunTemplateCreateWithoutScheduleInput, DriverRunTemplateUncheckedCreateWithoutScheduleInput>
  }

  export type DriverRunTemplateCreateManyScheduleInputEnvelope = {
    data: DriverRunTemplateCreateManyScheduleInput | DriverRunTemplateCreateManyScheduleInput[]
    skipDuplicates?: boolean
  }

  export type DutyTemplateUpsertWithWhereUniqueWithoutScheduleInput = {
    where: DutyTemplateWhereUniqueInput
    update: XOR<DutyTemplateUpdateWithoutScheduleInput, DutyTemplateUncheckedUpdateWithoutScheduleInput>
    create: XOR<DutyTemplateCreateWithoutScheduleInput, DutyTemplateUncheckedCreateWithoutScheduleInput>
  }

  export type DutyTemplateUpdateWithWhereUniqueWithoutScheduleInput = {
    where: DutyTemplateWhereUniqueInput
    data: XOR<DutyTemplateUpdateWithoutScheduleInput, DutyTemplateUncheckedUpdateWithoutScheduleInput>
  }

  export type DutyTemplateUpdateManyWithWhereWithoutScheduleInput = {
    where: DutyTemplateScalarWhereInput
    data: XOR<DutyTemplateUpdateManyMutationInput, DutyTemplateUncheckedUpdateManyWithoutScheduleInput>
  }

  export type DutyTemplateScalarWhereInput = {
    AND?: DutyTemplateScalarWhereInput | DutyTemplateScalarWhereInput[]
    OR?: DutyTemplateScalarWhereInput[]
    NOT?: DutyTemplateScalarWhereInput | DutyTemplateScalarWhereInput[]
    id?: BigIntFilter<"DutyTemplate"> | bigint | number
    name?: StringNullableFilter<"DutyTemplate"> | string | null
    startTime?: DateTimeFilter<"DutyTemplate"> | Date | string
    endTime?: DateTimeFilter<"DutyTemplate"> | Date | string
    dutyType?: EnumDutyTypeFilter<"DutyTemplate"> | $Enums.DutyType
    vehicleBlockTemplateId?: BigIntNullableFilter<"DutyTemplate"> | bigint | number | null
    driverRunTemplateId?: BigIntNullableFilter<"DutyTemplate"> | bigint | number | null
    scheduleId?: BigIntFilter<"DutyTemplate"> | bigint | number
    createdAt?: DateTimeFilter<"DutyTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"DutyTemplate"> | Date | string
  }

  export type VehicleBlockTemplateUpsertWithWhereUniqueWithoutScheduleInput = {
    where: VehicleBlockTemplateWhereUniqueInput
    update: XOR<VehicleBlockTemplateUpdateWithoutScheduleInput, VehicleBlockTemplateUncheckedUpdateWithoutScheduleInput>
    create: XOR<VehicleBlockTemplateCreateWithoutScheduleInput, VehicleBlockTemplateUncheckedCreateWithoutScheduleInput>
  }

  export type VehicleBlockTemplateUpdateWithWhereUniqueWithoutScheduleInput = {
    where: VehicleBlockTemplateWhereUniqueInput
    data: XOR<VehicleBlockTemplateUpdateWithoutScheduleInput, VehicleBlockTemplateUncheckedUpdateWithoutScheduleInput>
  }

  export type VehicleBlockTemplateUpdateManyWithWhereWithoutScheduleInput = {
    where: VehicleBlockTemplateScalarWhereInput
    data: XOR<VehicleBlockTemplateUpdateManyMutationInput, VehicleBlockTemplateUncheckedUpdateManyWithoutScheduleInput>
  }

  export type VehicleBlockTemplateScalarWhereInput = {
    AND?: VehicleBlockTemplateScalarWhereInput | VehicleBlockTemplateScalarWhereInput[]
    OR?: VehicleBlockTemplateScalarWhereInput[]
    NOT?: VehicleBlockTemplateScalarWhereInput | VehicleBlockTemplateScalarWhereInput[]
    id?: BigIntFilter<"VehicleBlockTemplate"> | bigint | number
    scheduleId?: BigIntFilter<"VehicleBlockTemplate"> | bigint | number
    code?: StringFilter<"VehicleBlockTemplate"> | string
    color?: StringFilter<"VehicleBlockTemplate"> | string
  }

  export type DriverRunTemplateUpsertWithWhereUniqueWithoutScheduleInput = {
    where: DriverRunTemplateWhereUniqueInput
    update: XOR<DriverRunTemplateUpdateWithoutScheduleInput, DriverRunTemplateUncheckedUpdateWithoutScheduleInput>
    create: XOR<DriverRunTemplateCreateWithoutScheduleInput, DriverRunTemplateUncheckedCreateWithoutScheduleInput>
  }

  export type DriverRunTemplateUpdateWithWhereUniqueWithoutScheduleInput = {
    where: DriverRunTemplateWhereUniqueInput
    data: XOR<DriverRunTemplateUpdateWithoutScheduleInput, DriverRunTemplateUncheckedUpdateWithoutScheduleInput>
  }

  export type DriverRunTemplateUpdateManyWithWhereWithoutScheduleInput = {
    where: DriverRunTemplateScalarWhereInput
    data: XOR<DriverRunTemplateUpdateManyMutationInput, DriverRunTemplateUncheckedUpdateManyWithoutScheduleInput>
  }

  export type DriverRunTemplateScalarWhereInput = {
    AND?: DriverRunTemplateScalarWhereInput | DriverRunTemplateScalarWhereInput[]
    OR?: DriverRunTemplateScalarWhereInput[]
    NOT?: DriverRunTemplateScalarWhereInput | DriverRunTemplateScalarWhereInput[]
    id?: BigIntFilter<"DriverRunTemplate"> | bigint | number
    scheduleId?: BigIntFilter<"DriverRunTemplate"> | bigint | number
    code?: StringFilter<"DriverRunTemplate"> | string
    color?: StringFilter<"DriverRunTemplate"> | string
  }

  export type ServiceScheduleCreateWithoutVehicleBlockTemplatesInput = {
    id?: bigint | number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    dutyTemplates?: DutyTemplateCreateNestedManyWithoutScheduleInput
    driverRunTemplates?: DriverRunTemplateCreateNestedManyWithoutScheduleInput
  }

  export type ServiceScheduleUncheckedCreateWithoutVehicleBlockTemplatesInput = {
    id?: bigint | number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    dutyTemplates?: DutyTemplateUncheckedCreateNestedManyWithoutScheduleInput
    driverRunTemplates?: DriverRunTemplateUncheckedCreateNestedManyWithoutScheduleInput
  }

  export type ServiceScheduleCreateOrConnectWithoutVehicleBlockTemplatesInput = {
    where: ServiceScheduleWhereUniqueInput
    create: XOR<ServiceScheduleCreateWithoutVehicleBlockTemplatesInput, ServiceScheduleUncheckedCreateWithoutVehicleBlockTemplatesInput>
  }

  export type DutyTemplateCreateWithoutVehicleBlockTemplateInput = {
    id?: bigint | number
    name?: string | null
    startTime: Date | string
    endTime: Date | string
    dutyType: $Enums.DutyType
    createdAt?: Date | string
    updatedAt?: Date | string
    driverRunTemplate?: DriverRunTemplateCreateNestedOneWithoutDutyTemplateInput
    schedule: ServiceScheduleCreateNestedOneWithoutDutyTemplatesInput
  }

  export type DutyTemplateUncheckedCreateWithoutVehicleBlockTemplateInput = {
    id?: bigint | number
    name?: string | null
    startTime: Date | string
    endTime: Date | string
    dutyType: $Enums.DutyType
    driverRunTemplateId?: bigint | number | null
    scheduleId: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DutyTemplateCreateOrConnectWithoutVehicleBlockTemplateInput = {
    where: DutyTemplateWhereUniqueInput
    create: XOR<DutyTemplateCreateWithoutVehicleBlockTemplateInput, DutyTemplateUncheckedCreateWithoutVehicleBlockTemplateInput>
  }

  export type DutyTemplateCreateManyVehicleBlockTemplateInputEnvelope = {
    data: DutyTemplateCreateManyVehicleBlockTemplateInput | DutyTemplateCreateManyVehicleBlockTemplateInput[]
    skipDuplicates?: boolean
  }

  export type VehicleBlockCreateWithoutVehicleBlockTemplateInput = {
    id?: bigint | number
    code: string
    Duty?: DutyCreateNestedManyWithoutBlockInput
  }

  export type VehicleBlockUncheckedCreateWithoutVehicleBlockTemplateInput = {
    id?: bigint | number
    code: string
    Duty?: DutyUncheckedCreateNestedManyWithoutBlockInput
  }

  export type VehicleBlockCreateOrConnectWithoutVehicleBlockTemplateInput = {
    where: VehicleBlockWhereUniqueInput
    create: XOR<VehicleBlockCreateWithoutVehicleBlockTemplateInput, VehicleBlockUncheckedCreateWithoutVehicleBlockTemplateInput>
  }

  export type VehicleBlockCreateManyVehicleBlockTemplateInputEnvelope = {
    data: VehicleBlockCreateManyVehicleBlockTemplateInput | VehicleBlockCreateManyVehicleBlockTemplateInput[]
    skipDuplicates?: boolean
  }

  export type ServiceScheduleUpsertWithoutVehicleBlockTemplatesInput = {
    update: XOR<ServiceScheduleUpdateWithoutVehicleBlockTemplatesInput, ServiceScheduleUncheckedUpdateWithoutVehicleBlockTemplatesInput>
    create: XOR<ServiceScheduleCreateWithoutVehicleBlockTemplatesInput, ServiceScheduleUncheckedCreateWithoutVehicleBlockTemplatesInput>
    where?: ServiceScheduleWhereInput
  }

  export type ServiceScheduleUpdateToOneWithWhereWithoutVehicleBlockTemplatesInput = {
    where?: ServiceScheduleWhereInput
    data: XOR<ServiceScheduleUpdateWithoutVehicleBlockTemplatesInput, ServiceScheduleUncheckedUpdateWithoutVehicleBlockTemplatesInput>
  }

  export type ServiceScheduleUpdateWithoutVehicleBlockTemplatesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dutyTemplates?: DutyTemplateUpdateManyWithoutScheduleNestedInput
    driverRunTemplates?: DriverRunTemplateUpdateManyWithoutScheduleNestedInput
  }

  export type ServiceScheduleUncheckedUpdateWithoutVehicleBlockTemplatesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dutyTemplates?: DutyTemplateUncheckedUpdateManyWithoutScheduleNestedInput
    driverRunTemplates?: DriverRunTemplateUncheckedUpdateManyWithoutScheduleNestedInput
  }

  export type DutyTemplateUpsertWithWhereUniqueWithoutVehicleBlockTemplateInput = {
    where: DutyTemplateWhereUniqueInput
    update: XOR<DutyTemplateUpdateWithoutVehicleBlockTemplateInput, DutyTemplateUncheckedUpdateWithoutVehicleBlockTemplateInput>
    create: XOR<DutyTemplateCreateWithoutVehicleBlockTemplateInput, DutyTemplateUncheckedCreateWithoutVehicleBlockTemplateInput>
  }

  export type DutyTemplateUpdateWithWhereUniqueWithoutVehicleBlockTemplateInput = {
    where: DutyTemplateWhereUniqueInput
    data: XOR<DutyTemplateUpdateWithoutVehicleBlockTemplateInput, DutyTemplateUncheckedUpdateWithoutVehicleBlockTemplateInput>
  }

  export type DutyTemplateUpdateManyWithWhereWithoutVehicleBlockTemplateInput = {
    where: DutyTemplateScalarWhereInput
    data: XOR<DutyTemplateUpdateManyMutationInput, DutyTemplateUncheckedUpdateManyWithoutVehicleBlockTemplateInput>
  }

  export type VehicleBlockUpsertWithWhereUniqueWithoutVehicleBlockTemplateInput = {
    where: VehicleBlockWhereUniqueInput
    update: XOR<VehicleBlockUpdateWithoutVehicleBlockTemplateInput, VehicleBlockUncheckedUpdateWithoutVehicleBlockTemplateInput>
    create: XOR<VehicleBlockCreateWithoutVehicleBlockTemplateInput, VehicleBlockUncheckedCreateWithoutVehicleBlockTemplateInput>
  }

  export type VehicleBlockUpdateWithWhereUniqueWithoutVehicleBlockTemplateInput = {
    where: VehicleBlockWhereUniqueInput
    data: XOR<VehicleBlockUpdateWithoutVehicleBlockTemplateInput, VehicleBlockUncheckedUpdateWithoutVehicleBlockTemplateInput>
  }

  export type VehicleBlockUpdateManyWithWhereWithoutVehicleBlockTemplateInput = {
    where: VehicleBlockScalarWhereInput
    data: XOR<VehicleBlockUpdateManyMutationInput, VehicleBlockUncheckedUpdateManyWithoutVehicleBlockTemplateInput>
  }

  export type VehicleBlockScalarWhereInput = {
    AND?: VehicleBlockScalarWhereInput | VehicleBlockScalarWhereInput[]
    OR?: VehicleBlockScalarWhereInput[]
    NOT?: VehicleBlockScalarWhereInput | VehicleBlockScalarWhereInput[]
    id?: BigIntFilter<"VehicleBlock"> | bigint | number
    vehicleBlockTemplateId?: BigIntFilter<"VehicleBlock"> | bigint | number
    code?: StringFilter<"VehicleBlock"> | string
  }

  export type ServiceScheduleCreateWithoutDriverRunTemplatesInput = {
    id?: bigint | number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    dutyTemplates?: DutyTemplateCreateNestedManyWithoutScheduleInput
    vehicleBlockTemplates?: VehicleBlockTemplateCreateNestedManyWithoutScheduleInput
  }

  export type ServiceScheduleUncheckedCreateWithoutDriverRunTemplatesInput = {
    id?: bigint | number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    dutyTemplates?: DutyTemplateUncheckedCreateNestedManyWithoutScheduleInput
    vehicleBlockTemplates?: VehicleBlockTemplateUncheckedCreateNestedManyWithoutScheduleInput
  }

  export type ServiceScheduleCreateOrConnectWithoutDriverRunTemplatesInput = {
    where: ServiceScheduleWhereUniqueInput
    create: XOR<ServiceScheduleCreateWithoutDriverRunTemplatesInput, ServiceScheduleUncheckedCreateWithoutDriverRunTemplatesInput>
  }

  export type DutyTemplateCreateWithoutDriverRunTemplateInput = {
    id?: bigint | number
    name?: string | null
    startTime: Date | string
    endTime: Date | string
    dutyType: $Enums.DutyType
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicleBlockTemplate?: VehicleBlockTemplateCreateNestedOneWithoutDutyTemplateInput
    schedule: ServiceScheduleCreateNestedOneWithoutDutyTemplatesInput
  }

  export type DutyTemplateUncheckedCreateWithoutDriverRunTemplateInput = {
    id?: bigint | number
    name?: string | null
    startTime: Date | string
    endTime: Date | string
    dutyType: $Enums.DutyType
    vehicleBlockTemplateId?: bigint | number | null
    scheduleId: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DutyTemplateCreateOrConnectWithoutDriverRunTemplateInput = {
    where: DutyTemplateWhereUniqueInput
    create: XOR<DutyTemplateCreateWithoutDriverRunTemplateInput, DutyTemplateUncheckedCreateWithoutDriverRunTemplateInput>
  }

  export type DutyTemplateCreateManyDriverRunTemplateInputEnvelope = {
    data: DutyTemplateCreateManyDriverRunTemplateInput | DutyTemplateCreateManyDriverRunTemplateInput[]
    skipDuplicates?: boolean
  }

  export type DriverRunCreateWithoutDriverRunTemplateInput = {
    id?: bigint | number
    code: string
    Duty?: DutyCreateNestedManyWithoutRunInput
  }

  export type DriverRunUncheckedCreateWithoutDriverRunTemplateInput = {
    id?: bigint | number
    code: string
    Duty?: DutyUncheckedCreateNestedManyWithoutRunInput
  }

  export type DriverRunCreateOrConnectWithoutDriverRunTemplateInput = {
    where: DriverRunWhereUniqueInput
    create: XOR<DriverRunCreateWithoutDriverRunTemplateInput, DriverRunUncheckedCreateWithoutDriverRunTemplateInput>
  }

  export type DriverRunCreateManyDriverRunTemplateInputEnvelope = {
    data: DriverRunCreateManyDriverRunTemplateInput | DriverRunCreateManyDriverRunTemplateInput[]
    skipDuplicates?: boolean
  }

  export type ServiceScheduleUpsertWithoutDriverRunTemplatesInput = {
    update: XOR<ServiceScheduleUpdateWithoutDriverRunTemplatesInput, ServiceScheduleUncheckedUpdateWithoutDriverRunTemplatesInput>
    create: XOR<ServiceScheduleCreateWithoutDriverRunTemplatesInput, ServiceScheduleUncheckedCreateWithoutDriverRunTemplatesInput>
    where?: ServiceScheduleWhereInput
  }

  export type ServiceScheduleUpdateToOneWithWhereWithoutDriverRunTemplatesInput = {
    where?: ServiceScheduleWhereInput
    data: XOR<ServiceScheduleUpdateWithoutDriverRunTemplatesInput, ServiceScheduleUncheckedUpdateWithoutDriverRunTemplatesInput>
  }

  export type ServiceScheduleUpdateWithoutDriverRunTemplatesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dutyTemplates?: DutyTemplateUpdateManyWithoutScheduleNestedInput
    vehicleBlockTemplates?: VehicleBlockTemplateUpdateManyWithoutScheduleNestedInput
  }

  export type ServiceScheduleUncheckedUpdateWithoutDriverRunTemplatesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dutyTemplates?: DutyTemplateUncheckedUpdateManyWithoutScheduleNestedInput
    vehicleBlockTemplates?: VehicleBlockTemplateUncheckedUpdateManyWithoutScheduleNestedInput
  }

  export type DutyTemplateUpsertWithWhereUniqueWithoutDriverRunTemplateInput = {
    where: DutyTemplateWhereUniqueInput
    update: XOR<DutyTemplateUpdateWithoutDriverRunTemplateInput, DutyTemplateUncheckedUpdateWithoutDriverRunTemplateInput>
    create: XOR<DutyTemplateCreateWithoutDriverRunTemplateInput, DutyTemplateUncheckedCreateWithoutDriverRunTemplateInput>
  }

  export type DutyTemplateUpdateWithWhereUniqueWithoutDriverRunTemplateInput = {
    where: DutyTemplateWhereUniqueInput
    data: XOR<DutyTemplateUpdateWithoutDriverRunTemplateInput, DutyTemplateUncheckedUpdateWithoutDriverRunTemplateInput>
  }

  export type DutyTemplateUpdateManyWithWhereWithoutDriverRunTemplateInput = {
    where: DutyTemplateScalarWhereInput
    data: XOR<DutyTemplateUpdateManyMutationInput, DutyTemplateUncheckedUpdateManyWithoutDriverRunTemplateInput>
  }

  export type DriverRunUpsertWithWhereUniqueWithoutDriverRunTemplateInput = {
    where: DriverRunWhereUniqueInput
    update: XOR<DriverRunUpdateWithoutDriverRunTemplateInput, DriverRunUncheckedUpdateWithoutDriverRunTemplateInput>
    create: XOR<DriverRunCreateWithoutDriverRunTemplateInput, DriverRunUncheckedCreateWithoutDriverRunTemplateInput>
  }

  export type DriverRunUpdateWithWhereUniqueWithoutDriverRunTemplateInput = {
    where: DriverRunWhereUniqueInput
    data: XOR<DriverRunUpdateWithoutDriverRunTemplateInput, DriverRunUncheckedUpdateWithoutDriverRunTemplateInput>
  }

  export type DriverRunUpdateManyWithWhereWithoutDriverRunTemplateInput = {
    where: DriverRunScalarWhereInput
    data: XOR<DriverRunUpdateManyMutationInput, DriverRunUncheckedUpdateManyWithoutDriverRunTemplateInput>
  }

  export type DriverRunScalarWhereInput = {
    AND?: DriverRunScalarWhereInput | DriverRunScalarWhereInput[]
    OR?: DriverRunScalarWhereInput[]
    NOT?: DriverRunScalarWhereInput | DriverRunScalarWhereInput[]
    id?: BigIntFilter<"DriverRun"> | bigint | number
    driverRunTemplateId?: BigIntFilter<"DriverRun"> | bigint | number
    code?: StringFilter<"DriverRun"> | string
  }

  export type VehicleBlockTemplateCreateWithoutDutyTemplateInput = {
    id?: bigint | number
    code: string
    color: string
    schedule: ServiceScheduleCreateNestedOneWithoutVehicleBlockTemplatesInput
    VehicleBlock?: VehicleBlockCreateNestedManyWithoutVehicleBlockTemplateInput
  }

  export type VehicleBlockTemplateUncheckedCreateWithoutDutyTemplateInput = {
    id?: bigint | number
    scheduleId: bigint | number
    code: string
    color: string
    VehicleBlock?: VehicleBlockUncheckedCreateNestedManyWithoutVehicleBlockTemplateInput
  }

  export type VehicleBlockTemplateCreateOrConnectWithoutDutyTemplateInput = {
    where: VehicleBlockTemplateWhereUniqueInput
    create: XOR<VehicleBlockTemplateCreateWithoutDutyTemplateInput, VehicleBlockTemplateUncheckedCreateWithoutDutyTemplateInput>
  }

  export type DriverRunTemplateCreateWithoutDutyTemplateInput = {
    id?: bigint | number
    code: string
    color: string
    schedule: ServiceScheduleCreateNestedOneWithoutDriverRunTemplatesInput
    DriverRun?: DriverRunCreateNestedManyWithoutDriverRunTemplateInput
  }

  export type DriverRunTemplateUncheckedCreateWithoutDutyTemplateInput = {
    id?: bigint | number
    scheduleId: bigint | number
    code: string
    color: string
    DriverRun?: DriverRunUncheckedCreateNestedManyWithoutDriverRunTemplateInput
  }

  export type DriverRunTemplateCreateOrConnectWithoutDutyTemplateInput = {
    where: DriverRunTemplateWhereUniqueInput
    create: XOR<DriverRunTemplateCreateWithoutDutyTemplateInput, DriverRunTemplateUncheckedCreateWithoutDutyTemplateInput>
  }

  export type ServiceScheduleCreateWithoutDutyTemplatesInput = {
    id?: bigint | number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicleBlockTemplates?: VehicleBlockTemplateCreateNestedManyWithoutScheduleInput
    driverRunTemplates?: DriverRunTemplateCreateNestedManyWithoutScheduleInput
  }

  export type ServiceScheduleUncheckedCreateWithoutDutyTemplatesInput = {
    id?: bigint | number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicleBlockTemplates?: VehicleBlockTemplateUncheckedCreateNestedManyWithoutScheduleInput
    driverRunTemplates?: DriverRunTemplateUncheckedCreateNestedManyWithoutScheduleInput
  }

  export type ServiceScheduleCreateOrConnectWithoutDutyTemplatesInput = {
    where: ServiceScheduleWhereUniqueInput
    create: XOR<ServiceScheduleCreateWithoutDutyTemplatesInput, ServiceScheduleUncheckedCreateWithoutDutyTemplatesInput>
  }

  export type VehicleBlockTemplateUpsertWithoutDutyTemplateInput = {
    update: XOR<VehicleBlockTemplateUpdateWithoutDutyTemplateInput, VehicleBlockTemplateUncheckedUpdateWithoutDutyTemplateInput>
    create: XOR<VehicleBlockTemplateCreateWithoutDutyTemplateInput, VehicleBlockTemplateUncheckedCreateWithoutDutyTemplateInput>
    where?: VehicleBlockTemplateWhereInput
  }

  export type VehicleBlockTemplateUpdateToOneWithWhereWithoutDutyTemplateInput = {
    where?: VehicleBlockTemplateWhereInput
    data: XOR<VehicleBlockTemplateUpdateWithoutDutyTemplateInput, VehicleBlockTemplateUncheckedUpdateWithoutDutyTemplateInput>
  }

  export type VehicleBlockTemplateUpdateWithoutDutyTemplateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    schedule?: ServiceScheduleUpdateOneRequiredWithoutVehicleBlockTemplatesNestedInput
    VehicleBlock?: VehicleBlockUpdateManyWithoutVehicleBlockTemplateNestedInput
  }

  export type VehicleBlockTemplateUncheckedUpdateWithoutDutyTemplateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    scheduleId?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    VehicleBlock?: VehicleBlockUncheckedUpdateManyWithoutVehicleBlockTemplateNestedInput
  }

  export type DriverRunTemplateUpsertWithoutDutyTemplateInput = {
    update: XOR<DriverRunTemplateUpdateWithoutDutyTemplateInput, DriverRunTemplateUncheckedUpdateWithoutDutyTemplateInput>
    create: XOR<DriverRunTemplateCreateWithoutDutyTemplateInput, DriverRunTemplateUncheckedCreateWithoutDutyTemplateInput>
    where?: DriverRunTemplateWhereInput
  }

  export type DriverRunTemplateUpdateToOneWithWhereWithoutDutyTemplateInput = {
    where?: DriverRunTemplateWhereInput
    data: XOR<DriverRunTemplateUpdateWithoutDutyTemplateInput, DriverRunTemplateUncheckedUpdateWithoutDutyTemplateInput>
  }

  export type DriverRunTemplateUpdateWithoutDutyTemplateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    schedule?: ServiceScheduleUpdateOneRequiredWithoutDriverRunTemplatesNestedInput
    DriverRun?: DriverRunUpdateManyWithoutDriverRunTemplateNestedInput
  }

  export type DriverRunTemplateUncheckedUpdateWithoutDutyTemplateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    scheduleId?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    DriverRun?: DriverRunUncheckedUpdateManyWithoutDriverRunTemplateNestedInput
  }

  export type ServiceScheduleUpsertWithoutDutyTemplatesInput = {
    update: XOR<ServiceScheduleUpdateWithoutDutyTemplatesInput, ServiceScheduleUncheckedUpdateWithoutDutyTemplatesInput>
    create: XOR<ServiceScheduleCreateWithoutDutyTemplatesInput, ServiceScheduleUncheckedCreateWithoutDutyTemplatesInput>
    where?: ServiceScheduleWhereInput
  }

  export type ServiceScheduleUpdateToOneWithWhereWithoutDutyTemplatesInput = {
    where?: ServiceScheduleWhereInput
    data: XOR<ServiceScheduleUpdateWithoutDutyTemplatesInput, ServiceScheduleUncheckedUpdateWithoutDutyTemplatesInput>
  }

  export type ServiceScheduleUpdateWithoutDutyTemplatesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicleBlockTemplates?: VehicleBlockTemplateUpdateManyWithoutScheduleNestedInput
    driverRunTemplates?: DriverRunTemplateUpdateManyWithoutScheduleNestedInput
  }

  export type ServiceScheduleUncheckedUpdateWithoutDutyTemplatesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicleBlockTemplates?: VehicleBlockTemplateUncheckedUpdateManyWithoutScheduleNestedInput
    driverRunTemplates?: DriverRunTemplateUncheckedUpdateManyWithoutScheduleNestedInput
  }

  export type VehicleBlockTemplateCreateWithoutVehicleBlockInput = {
    id?: bigint | number
    code: string
    color: string
    schedule: ServiceScheduleCreateNestedOneWithoutVehicleBlockTemplatesInput
    DutyTemplate?: DutyTemplateCreateNestedManyWithoutVehicleBlockTemplateInput
  }

  export type VehicleBlockTemplateUncheckedCreateWithoutVehicleBlockInput = {
    id?: bigint | number
    scheduleId: bigint | number
    code: string
    color: string
    DutyTemplate?: DutyTemplateUncheckedCreateNestedManyWithoutVehicleBlockTemplateInput
  }

  export type VehicleBlockTemplateCreateOrConnectWithoutVehicleBlockInput = {
    where: VehicleBlockTemplateWhereUniqueInput
    create: XOR<VehicleBlockTemplateCreateWithoutVehicleBlockInput, VehicleBlockTemplateUncheckedCreateWithoutVehicleBlockInput>
  }

  export type DutyCreateWithoutBlockInput = {
    id?: bigint | number
    date: Date | string
    startTime: Date | string
    endTime: Date | string
    dutyTemplateId?: bigint | number | null
    dutyType: $Enums.DutyType
    run?: DriverRunCreateNestedOneWithoutDutyInput
    driver?: DriverCreateNestedOneWithoutDutyInput
    vehicle?: VehicleCreateNestedOneWithoutDutyInput
    tripDuties?: TripDutyCreateNestedManyWithoutDutyInput
    washingDuties?: WashingDutyCreateNestedManyWithoutDutyInput
    maintenanceDuties?: MaintenanceDutyCreateNestedManyWithoutDutyInput
  }

  export type DutyUncheckedCreateWithoutBlockInput = {
    id?: bigint | number
    date: Date | string
    startTime: Date | string
    endTime: Date | string
    driverId?: bigint | number | null
    vehicleId?: bigint | number | null
    dutyTemplateId?: bigint | number | null
    runId?: bigint | number | null
    dutyType: $Enums.DutyType
    tripDuties?: TripDutyUncheckedCreateNestedManyWithoutDutyInput
    washingDuties?: WashingDutyUncheckedCreateNestedManyWithoutDutyInput
    maintenanceDuties?: MaintenanceDutyUncheckedCreateNestedManyWithoutDutyInput
  }

  export type DutyCreateOrConnectWithoutBlockInput = {
    where: DutyWhereUniqueInput
    create: XOR<DutyCreateWithoutBlockInput, DutyUncheckedCreateWithoutBlockInput>
  }

  export type DutyCreateManyBlockInputEnvelope = {
    data: DutyCreateManyBlockInput | DutyCreateManyBlockInput[]
    skipDuplicates?: boolean
  }

  export type VehicleBlockTemplateUpsertWithoutVehicleBlockInput = {
    update: XOR<VehicleBlockTemplateUpdateWithoutVehicleBlockInput, VehicleBlockTemplateUncheckedUpdateWithoutVehicleBlockInput>
    create: XOR<VehicleBlockTemplateCreateWithoutVehicleBlockInput, VehicleBlockTemplateUncheckedCreateWithoutVehicleBlockInput>
    where?: VehicleBlockTemplateWhereInput
  }

  export type VehicleBlockTemplateUpdateToOneWithWhereWithoutVehicleBlockInput = {
    where?: VehicleBlockTemplateWhereInput
    data: XOR<VehicleBlockTemplateUpdateWithoutVehicleBlockInput, VehicleBlockTemplateUncheckedUpdateWithoutVehicleBlockInput>
  }

  export type VehicleBlockTemplateUpdateWithoutVehicleBlockInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    schedule?: ServiceScheduleUpdateOneRequiredWithoutVehicleBlockTemplatesNestedInput
    DutyTemplate?: DutyTemplateUpdateManyWithoutVehicleBlockTemplateNestedInput
  }

  export type VehicleBlockTemplateUncheckedUpdateWithoutVehicleBlockInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    scheduleId?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    DutyTemplate?: DutyTemplateUncheckedUpdateManyWithoutVehicleBlockTemplateNestedInput
  }

  export type DutyUpsertWithWhereUniqueWithoutBlockInput = {
    where: DutyWhereUniqueInput
    update: XOR<DutyUpdateWithoutBlockInput, DutyUncheckedUpdateWithoutBlockInput>
    create: XOR<DutyCreateWithoutBlockInput, DutyUncheckedCreateWithoutBlockInput>
  }

  export type DutyUpdateWithWhereUniqueWithoutBlockInput = {
    where: DutyWhereUniqueInput
    data: XOR<DutyUpdateWithoutBlockInput, DutyUncheckedUpdateWithoutBlockInput>
  }

  export type DutyUpdateManyWithWhereWithoutBlockInput = {
    where: DutyScalarWhereInput
    data: XOR<DutyUpdateManyMutationInput, DutyUncheckedUpdateManyWithoutBlockInput>
  }

  export type DriverRunTemplateCreateWithoutDriverRunInput = {
    id?: bigint | number
    code: string
    color: string
    schedule: ServiceScheduleCreateNestedOneWithoutDriverRunTemplatesInput
    DutyTemplate?: DutyTemplateCreateNestedManyWithoutDriverRunTemplateInput
  }

  export type DriverRunTemplateUncheckedCreateWithoutDriverRunInput = {
    id?: bigint | number
    scheduleId: bigint | number
    code: string
    color: string
    DutyTemplate?: DutyTemplateUncheckedCreateNestedManyWithoutDriverRunTemplateInput
  }

  export type DriverRunTemplateCreateOrConnectWithoutDriverRunInput = {
    where: DriverRunTemplateWhereUniqueInput
    create: XOR<DriverRunTemplateCreateWithoutDriverRunInput, DriverRunTemplateUncheckedCreateWithoutDriverRunInput>
  }

  export type DutyCreateWithoutRunInput = {
    id?: bigint | number
    date: Date | string
    startTime: Date | string
    endTime: Date | string
    dutyTemplateId?: bigint | number | null
    dutyType: $Enums.DutyType
    block?: VehicleBlockCreateNestedOneWithoutDutyInput
    driver?: DriverCreateNestedOneWithoutDutyInput
    vehicle?: VehicleCreateNestedOneWithoutDutyInput
    tripDuties?: TripDutyCreateNestedManyWithoutDutyInput
    washingDuties?: WashingDutyCreateNestedManyWithoutDutyInput
    maintenanceDuties?: MaintenanceDutyCreateNestedManyWithoutDutyInput
  }

  export type DutyUncheckedCreateWithoutRunInput = {
    id?: bigint | number
    date: Date | string
    startTime: Date | string
    endTime: Date | string
    driverId?: bigint | number | null
    vehicleId?: bigint | number | null
    dutyTemplateId?: bigint | number | null
    blockId?: bigint | number | null
    dutyType: $Enums.DutyType
    tripDuties?: TripDutyUncheckedCreateNestedManyWithoutDutyInput
    washingDuties?: WashingDutyUncheckedCreateNestedManyWithoutDutyInput
    maintenanceDuties?: MaintenanceDutyUncheckedCreateNestedManyWithoutDutyInput
  }

  export type DutyCreateOrConnectWithoutRunInput = {
    where: DutyWhereUniqueInput
    create: XOR<DutyCreateWithoutRunInput, DutyUncheckedCreateWithoutRunInput>
  }

  export type DutyCreateManyRunInputEnvelope = {
    data: DutyCreateManyRunInput | DutyCreateManyRunInput[]
    skipDuplicates?: boolean
  }

  export type DriverRunTemplateUpsertWithoutDriverRunInput = {
    update: XOR<DriverRunTemplateUpdateWithoutDriverRunInput, DriverRunTemplateUncheckedUpdateWithoutDriverRunInput>
    create: XOR<DriverRunTemplateCreateWithoutDriverRunInput, DriverRunTemplateUncheckedCreateWithoutDriverRunInput>
    where?: DriverRunTemplateWhereInput
  }

  export type DriverRunTemplateUpdateToOneWithWhereWithoutDriverRunInput = {
    where?: DriverRunTemplateWhereInput
    data: XOR<DriverRunTemplateUpdateWithoutDriverRunInput, DriverRunTemplateUncheckedUpdateWithoutDriverRunInput>
  }

  export type DriverRunTemplateUpdateWithoutDriverRunInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    schedule?: ServiceScheduleUpdateOneRequiredWithoutDriverRunTemplatesNestedInput
    DutyTemplate?: DutyTemplateUpdateManyWithoutDriverRunTemplateNestedInput
  }

  export type DriverRunTemplateUncheckedUpdateWithoutDriverRunInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    scheduleId?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    DutyTemplate?: DutyTemplateUncheckedUpdateManyWithoutDriverRunTemplateNestedInput
  }

  export type DutyUpsertWithWhereUniqueWithoutRunInput = {
    where: DutyWhereUniqueInput
    update: XOR<DutyUpdateWithoutRunInput, DutyUncheckedUpdateWithoutRunInput>
    create: XOR<DutyCreateWithoutRunInput, DutyUncheckedCreateWithoutRunInput>
  }

  export type DutyUpdateWithWhereUniqueWithoutRunInput = {
    where: DutyWhereUniqueInput
    data: XOR<DutyUpdateWithoutRunInput, DutyUncheckedUpdateWithoutRunInput>
  }

  export type DutyUpdateManyWithWhereWithoutRunInput = {
    where: DutyScalarWhereInput
    data: XOR<DutyUpdateManyMutationInput, DutyUncheckedUpdateManyWithoutRunInput>
  }

  export type VehicleBlockCreateWithoutDutyInput = {
    id?: bigint | number
    code: string
    vehicleBlockTemplate: VehicleBlockTemplateCreateNestedOneWithoutVehicleBlockInput
  }

  export type VehicleBlockUncheckedCreateWithoutDutyInput = {
    id?: bigint | number
    vehicleBlockTemplateId: bigint | number
    code: string
  }

  export type VehicleBlockCreateOrConnectWithoutDutyInput = {
    where: VehicleBlockWhereUniqueInput
    create: XOR<VehicleBlockCreateWithoutDutyInput, VehicleBlockUncheckedCreateWithoutDutyInput>
  }

  export type DriverRunCreateWithoutDutyInput = {
    id?: bigint | number
    code: string
    driverRunTemplate: DriverRunTemplateCreateNestedOneWithoutDriverRunInput
  }

  export type DriverRunUncheckedCreateWithoutDutyInput = {
    id?: bigint | number
    driverRunTemplateId: bigint | number
    code: string
  }

  export type DriverRunCreateOrConnectWithoutDutyInput = {
    where: DriverRunWhereUniqueInput
    create: XOR<DriverRunCreateWithoutDutyInput, DriverRunUncheckedCreateWithoutDutyInput>
  }

  export type DriverCreateWithoutDutyInput = {
    id?: bigint | number
    licenseExpiry?: Date | string | null
    trips?: TripCreateNestedManyWithoutDriverInput
    shifts?: ShiftCreateNestedManyWithoutDriverInput
    user: UserCreateNestedOneWithoutDriversInput
  }

  export type DriverUncheckedCreateWithoutDutyInput = {
    id?: bigint | number
    userId: bigint | number
    licenseExpiry?: Date | string | null
    trips?: TripUncheckedCreateNestedManyWithoutDriverInput
    shifts?: ShiftUncheckedCreateNestedManyWithoutDriverInput
  }

  export type DriverCreateOrConnectWithoutDutyInput = {
    where: DriverWhereUniqueInput
    create: XOR<DriverCreateWithoutDutyInput, DriverUncheckedCreateWithoutDutyInput>
  }

  export type VehicleCreateWithoutDutyInput = {
    id?: bigint | number
    plateNo: string
    fleetNo: string
    model: VehicleModelCreateNestedOneWithoutVehiclesInput
    trips?: TripCreateNestedManyWithoutVehicleInput
    shifts?: ShiftCreateNestedManyWithoutVehicleInput
    telemetry?: VehicleTelemetryCreateNestedManyWithoutVehicleInput
    telemetryHistory?: VehicleTelemetryHistoryCreateNestedManyWithoutVehicleInput
  }

  export type VehicleUncheckedCreateWithoutDutyInput = {
    id?: bigint | number
    plateNo: string
    fleetNo: string
    modelId: bigint | number
    trips?: TripUncheckedCreateNestedManyWithoutVehicleInput
    shifts?: ShiftUncheckedCreateNestedManyWithoutVehicleInput
    telemetry?: VehicleTelemetryUncheckedCreateNestedManyWithoutVehicleInput
    telemetryHistory?: VehicleTelemetryHistoryUncheckedCreateNestedManyWithoutVehicleInput
  }

  export type VehicleCreateOrConnectWithoutDutyInput = {
    where: VehicleWhereUniqueInput
    create: XOR<VehicleCreateWithoutDutyInput, VehicleUncheckedCreateWithoutDutyInput>
  }

  export type TripDutyCreateWithoutDutyInput = {
    id?: bigint | number
    route: RouteCreateNestedOneWithoutTripDutyInput
  }

  export type TripDutyUncheckedCreateWithoutDutyInput = {
    id?: bigint | number
    routeId: bigint | number
  }

  export type TripDutyCreateOrConnectWithoutDutyInput = {
    where: TripDutyWhereUniqueInput
    create: XOR<TripDutyCreateWithoutDutyInput, TripDutyUncheckedCreateWithoutDutyInput>
  }

  export type TripDutyCreateManyDutyInputEnvelope = {
    data: TripDutyCreateManyDutyInput | TripDutyCreateManyDutyInput[]
    skipDuplicates?: boolean
  }

  export type WashingDutyCreateWithoutDutyInput = {
    id?: bigint | number
  }

  export type WashingDutyUncheckedCreateWithoutDutyInput = {
    id?: bigint | number
  }

  export type WashingDutyCreateOrConnectWithoutDutyInput = {
    where: WashingDutyWhereUniqueInput
    create: XOR<WashingDutyCreateWithoutDutyInput, WashingDutyUncheckedCreateWithoutDutyInput>
  }

  export type WashingDutyCreateManyDutyInputEnvelope = {
    data: WashingDutyCreateManyDutyInput | WashingDutyCreateManyDutyInput[]
    skipDuplicates?: boolean
  }

  export type MaintenanceDutyCreateWithoutDutyInput = {
    id?: bigint | number
  }

  export type MaintenanceDutyUncheckedCreateWithoutDutyInput = {
    id?: bigint | number
  }

  export type MaintenanceDutyCreateOrConnectWithoutDutyInput = {
    where: MaintenanceDutyWhereUniqueInput
    create: XOR<MaintenanceDutyCreateWithoutDutyInput, MaintenanceDutyUncheckedCreateWithoutDutyInput>
  }

  export type MaintenanceDutyCreateManyDutyInputEnvelope = {
    data: MaintenanceDutyCreateManyDutyInput | MaintenanceDutyCreateManyDutyInput[]
    skipDuplicates?: boolean
  }

  export type VehicleBlockUpsertWithoutDutyInput = {
    update: XOR<VehicleBlockUpdateWithoutDutyInput, VehicleBlockUncheckedUpdateWithoutDutyInput>
    create: XOR<VehicleBlockCreateWithoutDutyInput, VehicleBlockUncheckedCreateWithoutDutyInput>
    where?: VehicleBlockWhereInput
  }

  export type VehicleBlockUpdateToOneWithWhereWithoutDutyInput = {
    where?: VehicleBlockWhereInput
    data: XOR<VehicleBlockUpdateWithoutDutyInput, VehicleBlockUncheckedUpdateWithoutDutyInput>
  }

  export type VehicleBlockUpdateWithoutDutyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    vehicleBlockTemplate?: VehicleBlockTemplateUpdateOneRequiredWithoutVehicleBlockNestedInput
  }

  export type VehicleBlockUncheckedUpdateWithoutDutyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    vehicleBlockTemplateId?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
  }

  export type DriverRunUpsertWithoutDutyInput = {
    update: XOR<DriverRunUpdateWithoutDutyInput, DriverRunUncheckedUpdateWithoutDutyInput>
    create: XOR<DriverRunCreateWithoutDutyInput, DriverRunUncheckedCreateWithoutDutyInput>
    where?: DriverRunWhereInput
  }

  export type DriverRunUpdateToOneWithWhereWithoutDutyInput = {
    where?: DriverRunWhereInput
    data: XOR<DriverRunUpdateWithoutDutyInput, DriverRunUncheckedUpdateWithoutDutyInput>
  }

  export type DriverRunUpdateWithoutDutyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    driverRunTemplate?: DriverRunTemplateUpdateOneRequiredWithoutDriverRunNestedInput
  }

  export type DriverRunUncheckedUpdateWithoutDutyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    driverRunTemplateId?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
  }

  export type DriverUpsertWithoutDutyInput = {
    update: XOR<DriverUpdateWithoutDutyInput, DriverUncheckedUpdateWithoutDutyInput>
    create: XOR<DriverCreateWithoutDutyInput, DriverUncheckedCreateWithoutDutyInput>
    where?: DriverWhereInput
  }

  export type DriverUpdateToOneWithWhereWithoutDutyInput = {
    where?: DriverWhereInput
    data: XOR<DriverUpdateWithoutDutyInput, DriverUncheckedUpdateWithoutDutyInput>
  }

  export type DriverUpdateWithoutDutyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    licenseExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trips?: TripUpdateManyWithoutDriverNestedInput
    shifts?: ShiftUpdateManyWithoutDriverNestedInput
    user?: UserUpdateOneRequiredWithoutDriversNestedInput
  }

  export type DriverUncheckedUpdateWithoutDutyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: BigIntFieldUpdateOperationsInput | bigint | number
    licenseExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trips?: TripUncheckedUpdateManyWithoutDriverNestedInput
    shifts?: ShiftUncheckedUpdateManyWithoutDriverNestedInput
  }

  export type VehicleUpsertWithoutDutyInput = {
    update: XOR<VehicleUpdateWithoutDutyInput, VehicleUncheckedUpdateWithoutDutyInput>
    create: XOR<VehicleCreateWithoutDutyInput, VehicleUncheckedCreateWithoutDutyInput>
    where?: VehicleWhereInput
  }

  export type VehicleUpdateToOneWithWhereWithoutDutyInput = {
    where?: VehicleWhereInput
    data: XOR<VehicleUpdateWithoutDutyInput, VehicleUncheckedUpdateWithoutDutyInput>
  }

  export type VehicleUpdateWithoutDutyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    plateNo?: StringFieldUpdateOperationsInput | string
    fleetNo?: StringFieldUpdateOperationsInput | string
    model?: VehicleModelUpdateOneRequiredWithoutVehiclesNestedInput
    trips?: TripUpdateManyWithoutVehicleNestedInput
    shifts?: ShiftUpdateManyWithoutVehicleNestedInput
    telemetry?: VehicleTelemetryUpdateManyWithoutVehicleNestedInput
    telemetryHistory?: VehicleTelemetryHistoryUpdateManyWithoutVehicleNestedInput
  }

  export type VehicleUncheckedUpdateWithoutDutyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    plateNo?: StringFieldUpdateOperationsInput | string
    fleetNo?: StringFieldUpdateOperationsInput | string
    modelId?: BigIntFieldUpdateOperationsInput | bigint | number
    trips?: TripUncheckedUpdateManyWithoutVehicleNestedInput
    shifts?: ShiftUncheckedUpdateManyWithoutVehicleNestedInput
    telemetry?: VehicleTelemetryUncheckedUpdateManyWithoutVehicleNestedInput
    telemetryHistory?: VehicleTelemetryHistoryUncheckedUpdateManyWithoutVehicleNestedInput
  }

  export type TripDutyUpsertWithWhereUniqueWithoutDutyInput = {
    where: TripDutyWhereUniqueInput
    update: XOR<TripDutyUpdateWithoutDutyInput, TripDutyUncheckedUpdateWithoutDutyInput>
    create: XOR<TripDutyCreateWithoutDutyInput, TripDutyUncheckedCreateWithoutDutyInput>
  }

  export type TripDutyUpdateWithWhereUniqueWithoutDutyInput = {
    where: TripDutyWhereUniqueInput
    data: XOR<TripDutyUpdateWithoutDutyInput, TripDutyUncheckedUpdateWithoutDutyInput>
  }

  export type TripDutyUpdateManyWithWhereWithoutDutyInput = {
    where: TripDutyScalarWhereInput
    data: XOR<TripDutyUpdateManyMutationInput, TripDutyUncheckedUpdateManyWithoutDutyInput>
  }

  export type WashingDutyUpsertWithWhereUniqueWithoutDutyInput = {
    where: WashingDutyWhereUniqueInput
    update: XOR<WashingDutyUpdateWithoutDutyInput, WashingDutyUncheckedUpdateWithoutDutyInput>
    create: XOR<WashingDutyCreateWithoutDutyInput, WashingDutyUncheckedCreateWithoutDutyInput>
  }

  export type WashingDutyUpdateWithWhereUniqueWithoutDutyInput = {
    where: WashingDutyWhereUniqueInput
    data: XOR<WashingDutyUpdateWithoutDutyInput, WashingDutyUncheckedUpdateWithoutDutyInput>
  }

  export type WashingDutyUpdateManyWithWhereWithoutDutyInput = {
    where: WashingDutyScalarWhereInput
    data: XOR<WashingDutyUpdateManyMutationInput, WashingDutyUncheckedUpdateManyWithoutDutyInput>
  }

  export type WashingDutyScalarWhereInput = {
    AND?: WashingDutyScalarWhereInput | WashingDutyScalarWhereInput[]
    OR?: WashingDutyScalarWhereInput[]
    NOT?: WashingDutyScalarWhereInput | WashingDutyScalarWhereInput[]
    id?: BigIntFilter<"WashingDuty"> | bigint | number
    dutyId?: BigIntFilter<"WashingDuty"> | bigint | number
  }

  export type MaintenanceDutyUpsertWithWhereUniqueWithoutDutyInput = {
    where: MaintenanceDutyWhereUniqueInput
    update: XOR<MaintenanceDutyUpdateWithoutDutyInput, MaintenanceDutyUncheckedUpdateWithoutDutyInput>
    create: XOR<MaintenanceDutyCreateWithoutDutyInput, MaintenanceDutyUncheckedCreateWithoutDutyInput>
  }

  export type MaintenanceDutyUpdateWithWhereUniqueWithoutDutyInput = {
    where: MaintenanceDutyWhereUniqueInput
    data: XOR<MaintenanceDutyUpdateWithoutDutyInput, MaintenanceDutyUncheckedUpdateWithoutDutyInput>
  }

  export type MaintenanceDutyUpdateManyWithWhereWithoutDutyInput = {
    where: MaintenanceDutyScalarWhereInput
    data: XOR<MaintenanceDutyUpdateManyMutationInput, MaintenanceDutyUncheckedUpdateManyWithoutDutyInput>
  }

  export type MaintenanceDutyScalarWhereInput = {
    AND?: MaintenanceDutyScalarWhereInput | MaintenanceDutyScalarWhereInput[]
    OR?: MaintenanceDutyScalarWhereInput[]
    NOT?: MaintenanceDutyScalarWhereInput | MaintenanceDutyScalarWhereInput[]
    id?: BigIntFilter<"MaintenanceDuty"> | bigint | number
    dutyId?: BigIntFilter<"MaintenanceDuty"> | bigint | number
  }

  export type DutyCreateWithoutTripDutiesInput = {
    id?: bigint | number
    date: Date | string
    startTime: Date | string
    endTime: Date | string
    dutyTemplateId?: bigint | number | null
    dutyType: $Enums.DutyType
    block?: VehicleBlockCreateNestedOneWithoutDutyInput
    run?: DriverRunCreateNestedOneWithoutDutyInput
    driver?: DriverCreateNestedOneWithoutDutyInput
    vehicle?: VehicleCreateNestedOneWithoutDutyInput
    washingDuties?: WashingDutyCreateNestedManyWithoutDutyInput
    maintenanceDuties?: MaintenanceDutyCreateNestedManyWithoutDutyInput
  }

  export type DutyUncheckedCreateWithoutTripDutiesInput = {
    id?: bigint | number
    date: Date | string
    startTime: Date | string
    endTime: Date | string
    driverId?: bigint | number | null
    vehicleId?: bigint | number | null
    dutyTemplateId?: bigint | number | null
    blockId?: bigint | number | null
    runId?: bigint | number | null
    dutyType: $Enums.DutyType
    washingDuties?: WashingDutyUncheckedCreateNestedManyWithoutDutyInput
    maintenanceDuties?: MaintenanceDutyUncheckedCreateNestedManyWithoutDutyInput
  }

  export type DutyCreateOrConnectWithoutTripDutiesInput = {
    where: DutyWhereUniqueInput
    create: XOR<DutyCreateWithoutTripDutiesInput, DutyUncheckedCreateWithoutTripDutiesInput>
  }

  export type RouteCreateWithoutTripDutyInput = {
    id?: bigint | number
    name: string
    code: string
    isActive?: boolean
    totalEstimatedDuration: number
    routeStops?: RouteStopCreateNestedManyWithoutRouteInput
    trips?: TripCreateNestedManyWithoutRouteInput
  }

  export type RouteUncheckedCreateWithoutTripDutyInput = {
    id?: bigint | number
    name: string
    code: string
    isActive?: boolean
    totalEstimatedDuration: number
    routeStops?: RouteStopUncheckedCreateNestedManyWithoutRouteInput
    trips?: TripUncheckedCreateNestedManyWithoutRouteInput
  }

  export type RouteCreateOrConnectWithoutTripDutyInput = {
    where: RouteWhereUniqueInput
    create: XOR<RouteCreateWithoutTripDutyInput, RouteUncheckedCreateWithoutTripDutyInput>
  }

  export type DutyUpsertWithoutTripDutiesInput = {
    update: XOR<DutyUpdateWithoutTripDutiesInput, DutyUncheckedUpdateWithoutTripDutiesInput>
    create: XOR<DutyCreateWithoutTripDutiesInput, DutyUncheckedCreateWithoutTripDutiesInput>
    where?: DutyWhereInput
  }

  export type DutyUpdateToOneWithWhereWithoutTripDutiesInput = {
    where?: DutyWhereInput
    data: XOR<DutyUpdateWithoutTripDutiesInput, DutyUncheckedUpdateWithoutTripDutiesInput>
  }

  export type DutyUpdateWithoutTripDutiesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    dutyTemplateId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    dutyType?: EnumDutyTypeFieldUpdateOperationsInput | $Enums.DutyType
    block?: VehicleBlockUpdateOneWithoutDutyNestedInput
    run?: DriverRunUpdateOneWithoutDutyNestedInput
    driver?: DriverUpdateOneWithoutDutyNestedInput
    vehicle?: VehicleUpdateOneWithoutDutyNestedInput
    washingDuties?: WashingDutyUpdateManyWithoutDutyNestedInput
    maintenanceDuties?: MaintenanceDutyUpdateManyWithoutDutyNestedInput
  }

  export type DutyUncheckedUpdateWithoutTripDutiesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    driverId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    vehicleId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    dutyTemplateId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    blockId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    runId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    dutyType?: EnumDutyTypeFieldUpdateOperationsInput | $Enums.DutyType
    washingDuties?: WashingDutyUncheckedUpdateManyWithoutDutyNestedInput
    maintenanceDuties?: MaintenanceDutyUncheckedUpdateManyWithoutDutyNestedInput
  }

  export type RouteUpsertWithoutTripDutyInput = {
    update: XOR<RouteUpdateWithoutTripDutyInput, RouteUncheckedUpdateWithoutTripDutyInput>
    create: XOR<RouteCreateWithoutTripDutyInput, RouteUncheckedCreateWithoutTripDutyInput>
    where?: RouteWhereInput
  }

  export type RouteUpdateToOneWithWhereWithoutTripDutyInput = {
    where?: RouteWhereInput
    data: XOR<RouteUpdateWithoutTripDutyInput, RouteUncheckedUpdateWithoutTripDutyInput>
  }

  export type RouteUpdateWithoutTripDutyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    totalEstimatedDuration?: IntFieldUpdateOperationsInput | number
    routeStops?: RouteStopUpdateManyWithoutRouteNestedInput
    trips?: TripUpdateManyWithoutRouteNestedInput
  }

  export type RouteUncheckedUpdateWithoutTripDutyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    totalEstimatedDuration?: IntFieldUpdateOperationsInput | number
    routeStops?: RouteStopUncheckedUpdateManyWithoutRouteNestedInput
    trips?: TripUncheckedUpdateManyWithoutRouteNestedInput
  }

  export type DutyCreateWithoutWashingDutiesInput = {
    id?: bigint | number
    date: Date | string
    startTime: Date | string
    endTime: Date | string
    dutyTemplateId?: bigint | number | null
    dutyType: $Enums.DutyType
    block?: VehicleBlockCreateNestedOneWithoutDutyInput
    run?: DriverRunCreateNestedOneWithoutDutyInput
    driver?: DriverCreateNestedOneWithoutDutyInput
    vehicle?: VehicleCreateNestedOneWithoutDutyInput
    tripDuties?: TripDutyCreateNestedManyWithoutDutyInput
    maintenanceDuties?: MaintenanceDutyCreateNestedManyWithoutDutyInput
  }

  export type DutyUncheckedCreateWithoutWashingDutiesInput = {
    id?: bigint | number
    date: Date | string
    startTime: Date | string
    endTime: Date | string
    driverId?: bigint | number | null
    vehicleId?: bigint | number | null
    dutyTemplateId?: bigint | number | null
    blockId?: bigint | number | null
    runId?: bigint | number | null
    dutyType: $Enums.DutyType
    tripDuties?: TripDutyUncheckedCreateNestedManyWithoutDutyInput
    maintenanceDuties?: MaintenanceDutyUncheckedCreateNestedManyWithoutDutyInput
  }

  export type DutyCreateOrConnectWithoutWashingDutiesInput = {
    where: DutyWhereUniqueInput
    create: XOR<DutyCreateWithoutWashingDutiesInput, DutyUncheckedCreateWithoutWashingDutiesInput>
  }

  export type DutyUpsertWithoutWashingDutiesInput = {
    update: XOR<DutyUpdateWithoutWashingDutiesInput, DutyUncheckedUpdateWithoutWashingDutiesInput>
    create: XOR<DutyCreateWithoutWashingDutiesInput, DutyUncheckedCreateWithoutWashingDutiesInput>
    where?: DutyWhereInput
  }

  export type DutyUpdateToOneWithWhereWithoutWashingDutiesInput = {
    where?: DutyWhereInput
    data: XOR<DutyUpdateWithoutWashingDutiesInput, DutyUncheckedUpdateWithoutWashingDutiesInput>
  }

  export type DutyUpdateWithoutWashingDutiesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    dutyTemplateId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    dutyType?: EnumDutyTypeFieldUpdateOperationsInput | $Enums.DutyType
    block?: VehicleBlockUpdateOneWithoutDutyNestedInput
    run?: DriverRunUpdateOneWithoutDutyNestedInput
    driver?: DriverUpdateOneWithoutDutyNestedInput
    vehicle?: VehicleUpdateOneWithoutDutyNestedInput
    tripDuties?: TripDutyUpdateManyWithoutDutyNestedInput
    maintenanceDuties?: MaintenanceDutyUpdateManyWithoutDutyNestedInput
  }

  export type DutyUncheckedUpdateWithoutWashingDutiesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    driverId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    vehicleId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    dutyTemplateId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    blockId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    runId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    dutyType?: EnumDutyTypeFieldUpdateOperationsInput | $Enums.DutyType
    tripDuties?: TripDutyUncheckedUpdateManyWithoutDutyNestedInput
    maintenanceDuties?: MaintenanceDutyUncheckedUpdateManyWithoutDutyNestedInput
  }

  export type DutyCreateWithoutMaintenanceDutiesInput = {
    id?: bigint | number
    date: Date | string
    startTime: Date | string
    endTime: Date | string
    dutyTemplateId?: bigint | number | null
    dutyType: $Enums.DutyType
    block?: VehicleBlockCreateNestedOneWithoutDutyInput
    run?: DriverRunCreateNestedOneWithoutDutyInput
    driver?: DriverCreateNestedOneWithoutDutyInput
    vehicle?: VehicleCreateNestedOneWithoutDutyInput
    tripDuties?: TripDutyCreateNestedManyWithoutDutyInput
    washingDuties?: WashingDutyCreateNestedManyWithoutDutyInput
  }

  export type DutyUncheckedCreateWithoutMaintenanceDutiesInput = {
    id?: bigint | number
    date: Date | string
    startTime: Date | string
    endTime: Date | string
    driverId?: bigint | number | null
    vehicleId?: bigint | number | null
    dutyTemplateId?: bigint | number | null
    blockId?: bigint | number | null
    runId?: bigint | number | null
    dutyType: $Enums.DutyType
    tripDuties?: TripDutyUncheckedCreateNestedManyWithoutDutyInput
    washingDuties?: WashingDutyUncheckedCreateNestedManyWithoutDutyInput
  }

  export type DutyCreateOrConnectWithoutMaintenanceDutiesInput = {
    where: DutyWhereUniqueInput
    create: XOR<DutyCreateWithoutMaintenanceDutiesInput, DutyUncheckedCreateWithoutMaintenanceDutiesInput>
  }

  export type DutyUpsertWithoutMaintenanceDutiesInput = {
    update: XOR<DutyUpdateWithoutMaintenanceDutiesInput, DutyUncheckedUpdateWithoutMaintenanceDutiesInput>
    create: XOR<DutyCreateWithoutMaintenanceDutiesInput, DutyUncheckedCreateWithoutMaintenanceDutiesInput>
    where?: DutyWhereInput
  }

  export type DutyUpdateToOneWithWhereWithoutMaintenanceDutiesInput = {
    where?: DutyWhereInput
    data: XOR<DutyUpdateWithoutMaintenanceDutiesInput, DutyUncheckedUpdateWithoutMaintenanceDutiesInput>
  }

  export type DutyUpdateWithoutMaintenanceDutiesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    dutyTemplateId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    dutyType?: EnumDutyTypeFieldUpdateOperationsInput | $Enums.DutyType
    block?: VehicleBlockUpdateOneWithoutDutyNestedInput
    run?: DriverRunUpdateOneWithoutDutyNestedInput
    driver?: DriverUpdateOneWithoutDutyNestedInput
    vehicle?: VehicleUpdateOneWithoutDutyNestedInput
    tripDuties?: TripDutyUpdateManyWithoutDutyNestedInput
    washingDuties?: WashingDutyUpdateManyWithoutDutyNestedInput
  }

  export type DutyUncheckedUpdateWithoutMaintenanceDutiesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    driverId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    vehicleId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    dutyTemplateId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    blockId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    runId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    dutyType?: EnumDutyTypeFieldUpdateOperationsInput | $Enums.DutyType
    tripDuties?: TripDutyUncheckedUpdateManyWithoutDutyNestedInput
    washingDuties?: WashingDutyUncheckedUpdateManyWithoutDutyNestedInput
  }

  export type UserRoleCreateManyUserInput = {
    id?: bigint | number
    roleId: bigint | number
  }

  export type UserActivationCreateManyUserInput = {
    id?: bigint | number
    activationCode: string
    expiresAt: Date | string
    isUsed?: boolean
    createdAt?: Date | string
  }

  export type UserAuthCreateManyUserInput = {
    id?: bigint | number
    userType: string
    provider: string
    identifier: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DriverCreateManyUserInput = {
    id?: bigint | number
    licenseExpiry?: Date | string | null
  }

  export type UserRoleUpdateWithoutUserInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserRoleUncheckedUpdateWithoutUserInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    roleId?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type UserRoleUncheckedUpdateManyWithoutUserInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    roleId?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type UserActivationUpdateWithoutUserInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    activationCode?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserActivationUncheckedUpdateWithoutUserInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    activationCode?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserActivationUncheckedUpdateManyWithoutUserInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    activationCode?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAuthUpdateWithoutUserInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    userType?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAuthUncheckedUpdateWithoutUserInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    userType?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAuthUncheckedUpdateManyWithoutUserInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    userType?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DriverUpdateWithoutUserInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    licenseExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trips?: TripUpdateManyWithoutDriverNestedInput
    shifts?: ShiftUpdateManyWithoutDriverNestedInput
    Duty?: DutyUpdateManyWithoutDriverNestedInput
  }

  export type DriverUncheckedUpdateWithoutUserInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    licenseExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trips?: TripUncheckedUpdateManyWithoutDriverNestedInput
    shifts?: ShiftUncheckedUpdateManyWithoutDriverNestedInput
    Duty?: DutyUncheckedUpdateManyWithoutDriverNestedInput
  }

  export type DriverUncheckedUpdateManyWithoutUserInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    licenseExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserRoleCreateManyRoleInput = {
    id?: bigint | number
    userId: bigint | number
  }

  export type UserRoleUpdateWithoutRoleInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user?: UserUpdateOneRequiredWithoutRolesNestedInput
  }

  export type UserRoleUncheckedUpdateWithoutRoleInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type UserRoleUncheckedUpdateManyWithoutRoleInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type TripCreateManyDriverInput = {
    id?: bigint | number
    routeId: bigint | number
    startTime: Date | string
    endTime?: Date | string | null
    startLocation: bigint | number
    endLocation?: bigint | number | null
    vehicleId: bigint | number
    averageSpeed?: Decimal | DecimalJsLike | number | string | null
    maxSpeed?: Decimal | DecimalJsLike | number | string | null
    totalDistance?: Decimal | DecimalJsLike | number | string | null
    totalDuration?: number | null
    idleTime?: number | null
    path?: string | null
  }

  export type ShiftCreateManyDriverInput = {
    id?: bigint | number
    startTime: Date | string
    endTime: Date | string
    vehicleId: bigint | number
  }

  export type DutyCreateManyDriverInput = {
    id?: bigint | number
    date: Date | string
    startTime: Date | string
    endTime: Date | string
    vehicleId?: bigint | number | null
    dutyTemplateId?: bigint | number | null
    blockId?: bigint | number | null
    runId?: bigint | number | null
    dutyType: $Enums.DutyType
  }

  export type TripUpdateWithoutDriverInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startLocation?: BigIntFieldUpdateOperationsInput | bigint | number
    endLocation?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    averageSpeed?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxSpeed?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalDistance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalDuration?: NullableIntFieldUpdateOperationsInput | number | null
    idleTime?: NullableIntFieldUpdateOperationsInput | number | null
    path?: NullableStringFieldUpdateOperationsInput | string | null
    route?: RouteUpdateOneRequiredWithoutTripsNestedInput
    vehicle?: VehicleUpdateOneRequiredWithoutTripsNestedInput
    tripStops?: TripStopUpdateManyWithoutTripNestedInput
  }

  export type TripUncheckedUpdateWithoutDriverInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    routeId?: BigIntFieldUpdateOperationsInput | bigint | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startLocation?: BigIntFieldUpdateOperationsInput | bigint | number
    endLocation?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    vehicleId?: BigIntFieldUpdateOperationsInput | bigint | number
    averageSpeed?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxSpeed?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalDistance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalDuration?: NullableIntFieldUpdateOperationsInput | number | null
    idleTime?: NullableIntFieldUpdateOperationsInput | number | null
    path?: NullableStringFieldUpdateOperationsInput | string | null
    tripStops?: TripStopUncheckedUpdateManyWithoutTripNestedInput
  }

  export type TripUncheckedUpdateManyWithoutDriverInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    routeId?: BigIntFieldUpdateOperationsInput | bigint | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startLocation?: BigIntFieldUpdateOperationsInput | bigint | number
    endLocation?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    vehicleId?: BigIntFieldUpdateOperationsInput | bigint | number
    averageSpeed?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxSpeed?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalDistance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalDuration?: NullableIntFieldUpdateOperationsInput | number | null
    idleTime?: NullableIntFieldUpdateOperationsInput | number | null
    path?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ShiftUpdateWithoutDriverInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicle?: VehicleUpdateOneRequiredWithoutShiftsNestedInput
  }

  export type ShiftUncheckedUpdateWithoutDriverInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicleId?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type ShiftUncheckedUpdateManyWithoutDriverInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicleId?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type DutyUpdateWithoutDriverInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    dutyTemplateId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    dutyType?: EnumDutyTypeFieldUpdateOperationsInput | $Enums.DutyType
    block?: VehicleBlockUpdateOneWithoutDutyNestedInput
    run?: DriverRunUpdateOneWithoutDutyNestedInput
    vehicle?: VehicleUpdateOneWithoutDutyNestedInput
    tripDuties?: TripDutyUpdateManyWithoutDutyNestedInput
    washingDuties?: WashingDutyUpdateManyWithoutDutyNestedInput
    maintenanceDuties?: MaintenanceDutyUpdateManyWithoutDutyNestedInput
  }

  export type DutyUncheckedUpdateWithoutDriverInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicleId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    dutyTemplateId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    blockId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    runId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    dutyType?: EnumDutyTypeFieldUpdateOperationsInput | $Enums.DutyType
    tripDuties?: TripDutyUncheckedUpdateManyWithoutDutyNestedInput
    washingDuties?: WashingDutyUncheckedUpdateManyWithoutDutyNestedInput
    maintenanceDuties?: MaintenanceDutyUncheckedUpdateManyWithoutDutyNestedInput
  }

  export type DutyUncheckedUpdateManyWithoutDriverInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicleId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    dutyTemplateId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    blockId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    runId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    dutyType?: EnumDutyTypeFieldUpdateOperationsInput | $Enums.DutyType
  }

  export type VehicleCreateManyModelInput = {
    id?: bigint | number
    plateNo: string
    fleetNo: string
  }

  export type VehicleUpdateWithoutModelInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    plateNo?: StringFieldUpdateOperationsInput | string
    fleetNo?: StringFieldUpdateOperationsInput | string
    trips?: TripUpdateManyWithoutVehicleNestedInput
    shifts?: ShiftUpdateManyWithoutVehicleNestedInput
    telemetry?: VehicleTelemetryUpdateManyWithoutVehicleNestedInput
    telemetryHistory?: VehicleTelemetryHistoryUpdateManyWithoutVehicleNestedInput
    Duty?: DutyUpdateManyWithoutVehicleNestedInput
  }

  export type VehicleUncheckedUpdateWithoutModelInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    plateNo?: StringFieldUpdateOperationsInput | string
    fleetNo?: StringFieldUpdateOperationsInput | string
    trips?: TripUncheckedUpdateManyWithoutVehicleNestedInput
    shifts?: ShiftUncheckedUpdateManyWithoutVehicleNestedInput
    telemetry?: VehicleTelemetryUncheckedUpdateManyWithoutVehicleNestedInput
    telemetryHistory?: VehicleTelemetryHistoryUncheckedUpdateManyWithoutVehicleNestedInput
    Duty?: DutyUncheckedUpdateManyWithoutVehicleNestedInput
  }

  export type VehicleUncheckedUpdateManyWithoutModelInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    plateNo?: StringFieldUpdateOperationsInput | string
    fleetNo?: StringFieldUpdateOperationsInput | string
  }

  export type TripCreateManyVehicleInput = {
    id?: bigint | number
    routeId: bigint | number
    startTime: Date | string
    endTime?: Date | string | null
    startLocation: bigint | number
    endLocation?: bigint | number | null
    driverId: bigint | number
    averageSpeed?: Decimal | DecimalJsLike | number | string | null
    maxSpeed?: Decimal | DecimalJsLike | number | string | null
    totalDistance?: Decimal | DecimalJsLike | number | string | null
    totalDuration?: number | null
    idleTime?: number | null
    path?: string | null
  }

  export type ShiftCreateManyVehicleInput = {
    id?: bigint | number
    startTime: Date | string
    endTime: Date | string
    driverId: bigint | number
  }

  export type VehicleTelemetryCreateManyVehicleInput = {
    id?: bigint | number
    lat: Decimal | DecimalJsLike | number | string
    lon: Decimal | DecimalJsLike | number | string
    speed?: Decimal | DecimalJsLike | number | string | null
    ignition: boolean
    trackedOn?: Date | string
  }

  export type VehicleTelemetryHistoryCreateManyVehicleInput = {
    id?: bigint | number
    lat: Decimal | DecimalJsLike | number | string
    lon: Decimal | DecimalJsLike | number | string
    speed?: Decimal | DecimalJsLike | number | string | null
    ignition: boolean
    trackedOn: Date | string
  }

  export type DutyCreateManyVehicleInput = {
    id?: bigint | number
    date: Date | string
    startTime: Date | string
    endTime: Date | string
    driverId?: bigint | number | null
    dutyTemplateId?: bigint | number | null
    blockId?: bigint | number | null
    runId?: bigint | number | null
    dutyType: $Enums.DutyType
  }

  export type TripUpdateWithoutVehicleInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startLocation?: BigIntFieldUpdateOperationsInput | bigint | number
    endLocation?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    averageSpeed?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxSpeed?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalDistance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalDuration?: NullableIntFieldUpdateOperationsInput | number | null
    idleTime?: NullableIntFieldUpdateOperationsInput | number | null
    path?: NullableStringFieldUpdateOperationsInput | string | null
    route?: RouteUpdateOneRequiredWithoutTripsNestedInput
    driver?: DriverUpdateOneRequiredWithoutTripsNestedInput
    tripStops?: TripStopUpdateManyWithoutTripNestedInput
  }

  export type TripUncheckedUpdateWithoutVehicleInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    routeId?: BigIntFieldUpdateOperationsInput | bigint | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startLocation?: BigIntFieldUpdateOperationsInput | bigint | number
    endLocation?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    driverId?: BigIntFieldUpdateOperationsInput | bigint | number
    averageSpeed?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxSpeed?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalDistance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalDuration?: NullableIntFieldUpdateOperationsInput | number | null
    idleTime?: NullableIntFieldUpdateOperationsInput | number | null
    path?: NullableStringFieldUpdateOperationsInput | string | null
    tripStops?: TripStopUncheckedUpdateManyWithoutTripNestedInput
  }

  export type TripUncheckedUpdateManyWithoutVehicleInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    routeId?: BigIntFieldUpdateOperationsInput | bigint | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startLocation?: BigIntFieldUpdateOperationsInput | bigint | number
    endLocation?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    driverId?: BigIntFieldUpdateOperationsInput | bigint | number
    averageSpeed?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxSpeed?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalDistance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalDuration?: NullableIntFieldUpdateOperationsInput | number | null
    idleTime?: NullableIntFieldUpdateOperationsInput | number | null
    path?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ShiftUpdateWithoutVehicleInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    driver?: DriverUpdateOneRequiredWithoutShiftsNestedInput
  }

  export type ShiftUncheckedUpdateWithoutVehicleInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    driverId?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type ShiftUncheckedUpdateManyWithoutVehicleInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    driverId?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type VehicleTelemetryUpdateWithoutVehicleInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    lat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lon?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    speed?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ignition?: BoolFieldUpdateOperationsInput | boolean
    trackedOn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VehicleTelemetryUncheckedUpdateWithoutVehicleInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    lat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lon?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    speed?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ignition?: BoolFieldUpdateOperationsInput | boolean
    trackedOn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VehicleTelemetryUncheckedUpdateManyWithoutVehicleInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    lat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lon?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    speed?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ignition?: BoolFieldUpdateOperationsInput | boolean
    trackedOn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VehicleTelemetryHistoryUpdateWithoutVehicleInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    lat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lon?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    speed?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ignition?: BoolFieldUpdateOperationsInput | boolean
    trackedOn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VehicleTelemetryHistoryUncheckedUpdateWithoutVehicleInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    lat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lon?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    speed?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ignition?: BoolFieldUpdateOperationsInput | boolean
    trackedOn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VehicleTelemetryHistoryUncheckedUpdateManyWithoutVehicleInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    lat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lon?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    speed?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ignition?: BoolFieldUpdateOperationsInput | boolean
    trackedOn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DutyUpdateWithoutVehicleInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    dutyTemplateId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    dutyType?: EnumDutyTypeFieldUpdateOperationsInput | $Enums.DutyType
    block?: VehicleBlockUpdateOneWithoutDutyNestedInput
    run?: DriverRunUpdateOneWithoutDutyNestedInput
    driver?: DriverUpdateOneWithoutDutyNestedInput
    tripDuties?: TripDutyUpdateManyWithoutDutyNestedInput
    washingDuties?: WashingDutyUpdateManyWithoutDutyNestedInput
    maintenanceDuties?: MaintenanceDutyUpdateManyWithoutDutyNestedInput
  }

  export type DutyUncheckedUpdateWithoutVehicleInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    driverId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    dutyTemplateId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    blockId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    runId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    dutyType?: EnumDutyTypeFieldUpdateOperationsInput | $Enums.DutyType
    tripDuties?: TripDutyUncheckedUpdateManyWithoutDutyNestedInput
    washingDuties?: WashingDutyUncheckedUpdateManyWithoutDutyNestedInput
    maintenanceDuties?: MaintenanceDutyUncheckedUpdateManyWithoutDutyNestedInput
  }

  export type DutyUncheckedUpdateManyWithoutVehicleInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    driverId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    dutyTemplateId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    blockId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    runId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    dutyType?: EnumDutyTypeFieldUpdateOperationsInput | $Enums.DutyType
  }

  export type StopCreateManyLocationInput = {
    id?: bigint | number
    name: string
    code: string
  }

  export type StopUpdateWithoutLocationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    routeStops?: RouteStopUpdateManyWithoutStopNestedInput
    tripStops?: TripStopUpdateManyWithoutStopNestedInput
  }

  export type StopUncheckedUpdateWithoutLocationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    routeStops?: RouteStopUncheckedUpdateManyWithoutStopNestedInput
    tripStops?: TripStopUncheckedUpdateManyWithoutStopNestedInput
  }

  export type StopUncheckedUpdateManyWithoutLocationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
  }

  export type RouteStopCreateManyStopInput = {
    id?: bigint | number
    routeId: bigint | number
    stopOrder: number
    isActive?: boolean
    path?: string | null
    eta?: number | null
    waitTime?: number | null
  }

  export type TripStopCreateManyStopInput = {
    id?: bigint | number
    tripId: bigint | number
    stopOrder: number
    arrivalTime?: Date | string | null
    departureTime?: Date | string | null
    eta?: number | null
  }

  export type RouteStopUpdateWithoutStopInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    stopOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    path?: NullableStringFieldUpdateOperationsInput | string | null
    eta?: NullableIntFieldUpdateOperationsInput | number | null
    waitTime?: NullableIntFieldUpdateOperationsInput | number | null
    route?: RouteUpdateOneRequiredWithoutRouteStopsNestedInput
  }

  export type RouteStopUncheckedUpdateWithoutStopInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    routeId?: BigIntFieldUpdateOperationsInput | bigint | number
    stopOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    path?: NullableStringFieldUpdateOperationsInput | string | null
    eta?: NullableIntFieldUpdateOperationsInput | number | null
    waitTime?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RouteStopUncheckedUpdateManyWithoutStopInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    routeId?: BigIntFieldUpdateOperationsInput | bigint | number
    stopOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    path?: NullableStringFieldUpdateOperationsInput | string | null
    eta?: NullableIntFieldUpdateOperationsInput | number | null
    waitTime?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TripStopUpdateWithoutStopInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    stopOrder?: IntFieldUpdateOperationsInput | number
    arrivalTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departureTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eta?: NullableIntFieldUpdateOperationsInput | number | null
    trip?: TripUpdateOneRequiredWithoutTripStopsNestedInput
  }

  export type TripStopUncheckedUpdateWithoutStopInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tripId?: BigIntFieldUpdateOperationsInput | bigint | number
    stopOrder?: IntFieldUpdateOperationsInput | number
    arrivalTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departureTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eta?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TripStopUncheckedUpdateManyWithoutStopInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tripId?: BigIntFieldUpdateOperationsInput | bigint | number
    stopOrder?: IntFieldUpdateOperationsInput | number
    arrivalTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departureTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eta?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RouteStopCreateManyRouteInput = {
    id?: bigint | number
    stopId: bigint | number
    stopOrder: number
    isActive?: boolean
    path?: string | null
    eta?: number | null
    waitTime?: number | null
  }

  export type TripCreateManyRouteInput = {
    id?: bigint | number
    startTime: Date | string
    endTime?: Date | string | null
    startLocation: bigint | number
    endLocation?: bigint | number | null
    driverId: bigint | number
    vehicleId: bigint | number
    averageSpeed?: Decimal | DecimalJsLike | number | string | null
    maxSpeed?: Decimal | DecimalJsLike | number | string | null
    totalDistance?: Decimal | DecimalJsLike | number | string | null
    totalDuration?: number | null
    idleTime?: number | null
    path?: string | null
  }

  export type TripDutyCreateManyRouteInput = {
    id?: bigint | number
    dutyId: bigint | number
  }

  export type RouteStopUpdateWithoutRouteInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    stopOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    path?: NullableStringFieldUpdateOperationsInput | string | null
    eta?: NullableIntFieldUpdateOperationsInput | number | null
    waitTime?: NullableIntFieldUpdateOperationsInput | number | null
    stop?: StopUpdateOneRequiredWithoutRouteStopsNestedInput
  }

  export type RouteStopUncheckedUpdateWithoutRouteInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    stopId?: BigIntFieldUpdateOperationsInput | bigint | number
    stopOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    path?: NullableStringFieldUpdateOperationsInput | string | null
    eta?: NullableIntFieldUpdateOperationsInput | number | null
    waitTime?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RouteStopUncheckedUpdateManyWithoutRouteInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    stopId?: BigIntFieldUpdateOperationsInput | bigint | number
    stopOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    path?: NullableStringFieldUpdateOperationsInput | string | null
    eta?: NullableIntFieldUpdateOperationsInput | number | null
    waitTime?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TripUpdateWithoutRouteInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startLocation?: BigIntFieldUpdateOperationsInput | bigint | number
    endLocation?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    averageSpeed?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxSpeed?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalDistance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalDuration?: NullableIntFieldUpdateOperationsInput | number | null
    idleTime?: NullableIntFieldUpdateOperationsInput | number | null
    path?: NullableStringFieldUpdateOperationsInput | string | null
    driver?: DriverUpdateOneRequiredWithoutTripsNestedInput
    vehicle?: VehicleUpdateOneRequiredWithoutTripsNestedInput
    tripStops?: TripStopUpdateManyWithoutTripNestedInput
  }

  export type TripUncheckedUpdateWithoutRouteInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startLocation?: BigIntFieldUpdateOperationsInput | bigint | number
    endLocation?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    driverId?: BigIntFieldUpdateOperationsInput | bigint | number
    vehicleId?: BigIntFieldUpdateOperationsInput | bigint | number
    averageSpeed?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxSpeed?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalDistance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalDuration?: NullableIntFieldUpdateOperationsInput | number | null
    idleTime?: NullableIntFieldUpdateOperationsInput | number | null
    path?: NullableStringFieldUpdateOperationsInput | string | null
    tripStops?: TripStopUncheckedUpdateManyWithoutTripNestedInput
  }

  export type TripUncheckedUpdateManyWithoutRouteInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startLocation?: BigIntFieldUpdateOperationsInput | bigint | number
    endLocation?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    driverId?: BigIntFieldUpdateOperationsInput | bigint | number
    vehicleId?: BigIntFieldUpdateOperationsInput | bigint | number
    averageSpeed?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxSpeed?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalDistance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalDuration?: NullableIntFieldUpdateOperationsInput | number | null
    idleTime?: NullableIntFieldUpdateOperationsInput | number | null
    path?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TripDutyUpdateWithoutRouteInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    duty?: DutyUpdateOneRequiredWithoutTripDutiesNestedInput
  }

  export type TripDutyUncheckedUpdateWithoutRouteInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    dutyId?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type TripDutyUncheckedUpdateManyWithoutRouteInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    dutyId?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type TripStopCreateManyTripInput = {
    id?: bigint | number
    stopId: bigint | number
    stopOrder: number
    arrivalTime?: Date | string | null
    departureTime?: Date | string | null
    eta?: number | null
  }

  export type TripStopUpdateWithoutTripInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    stopOrder?: IntFieldUpdateOperationsInput | number
    arrivalTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departureTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eta?: NullableIntFieldUpdateOperationsInput | number | null
    stop?: StopUpdateOneRequiredWithoutTripStopsNestedInput
  }

  export type TripStopUncheckedUpdateWithoutTripInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    stopId?: BigIntFieldUpdateOperationsInput | bigint | number
    stopOrder?: IntFieldUpdateOperationsInput | number
    arrivalTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departureTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eta?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TripStopUncheckedUpdateManyWithoutTripInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    stopId?: BigIntFieldUpdateOperationsInput | bigint | number
    stopOrder?: IntFieldUpdateOperationsInput | number
    arrivalTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departureTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eta?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DutyTemplateCreateManyScheduleInput = {
    id?: bigint | number
    name?: string | null
    startTime: Date | string
    endTime: Date | string
    dutyType: $Enums.DutyType
    vehicleBlockTemplateId?: bigint | number | null
    driverRunTemplateId?: bigint | number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VehicleBlockTemplateCreateManyScheduleInput = {
    id?: bigint | number
    code: string
    color: string
  }

  export type DriverRunTemplateCreateManyScheduleInput = {
    id?: bigint | number
    code: string
    color: string
  }

  export type DutyTemplateUpdateWithoutScheduleInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    dutyType?: EnumDutyTypeFieldUpdateOperationsInput | $Enums.DutyType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicleBlockTemplate?: VehicleBlockTemplateUpdateOneWithoutDutyTemplateNestedInput
    driverRunTemplate?: DriverRunTemplateUpdateOneWithoutDutyTemplateNestedInput
  }

  export type DutyTemplateUncheckedUpdateWithoutScheduleInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    dutyType?: EnumDutyTypeFieldUpdateOperationsInput | $Enums.DutyType
    vehicleBlockTemplateId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    driverRunTemplateId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DutyTemplateUncheckedUpdateManyWithoutScheduleInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    dutyType?: EnumDutyTypeFieldUpdateOperationsInput | $Enums.DutyType
    vehicleBlockTemplateId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    driverRunTemplateId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VehicleBlockTemplateUpdateWithoutScheduleInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    DutyTemplate?: DutyTemplateUpdateManyWithoutVehicleBlockTemplateNestedInput
    VehicleBlock?: VehicleBlockUpdateManyWithoutVehicleBlockTemplateNestedInput
  }

  export type VehicleBlockTemplateUncheckedUpdateWithoutScheduleInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    DutyTemplate?: DutyTemplateUncheckedUpdateManyWithoutVehicleBlockTemplateNestedInput
    VehicleBlock?: VehicleBlockUncheckedUpdateManyWithoutVehicleBlockTemplateNestedInput
  }

  export type VehicleBlockTemplateUncheckedUpdateManyWithoutScheduleInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
  }

  export type DriverRunTemplateUpdateWithoutScheduleInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    DutyTemplate?: DutyTemplateUpdateManyWithoutDriverRunTemplateNestedInput
    DriverRun?: DriverRunUpdateManyWithoutDriverRunTemplateNestedInput
  }

  export type DriverRunTemplateUncheckedUpdateWithoutScheduleInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    DutyTemplate?: DutyTemplateUncheckedUpdateManyWithoutDriverRunTemplateNestedInput
    DriverRun?: DriverRunUncheckedUpdateManyWithoutDriverRunTemplateNestedInput
  }

  export type DriverRunTemplateUncheckedUpdateManyWithoutScheduleInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
  }

  export type DutyTemplateCreateManyVehicleBlockTemplateInput = {
    id?: bigint | number
    name?: string | null
    startTime: Date | string
    endTime: Date | string
    dutyType: $Enums.DutyType
    driverRunTemplateId?: bigint | number | null
    scheduleId: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VehicleBlockCreateManyVehicleBlockTemplateInput = {
    id?: bigint | number
    code: string
  }

  export type DutyTemplateUpdateWithoutVehicleBlockTemplateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    dutyType?: EnumDutyTypeFieldUpdateOperationsInput | $Enums.DutyType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    driverRunTemplate?: DriverRunTemplateUpdateOneWithoutDutyTemplateNestedInput
    schedule?: ServiceScheduleUpdateOneRequiredWithoutDutyTemplatesNestedInput
  }

  export type DutyTemplateUncheckedUpdateWithoutVehicleBlockTemplateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    dutyType?: EnumDutyTypeFieldUpdateOperationsInput | $Enums.DutyType
    driverRunTemplateId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    scheduleId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DutyTemplateUncheckedUpdateManyWithoutVehicleBlockTemplateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    dutyType?: EnumDutyTypeFieldUpdateOperationsInput | $Enums.DutyType
    driverRunTemplateId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    scheduleId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VehicleBlockUpdateWithoutVehicleBlockTemplateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    Duty?: DutyUpdateManyWithoutBlockNestedInput
  }

  export type VehicleBlockUncheckedUpdateWithoutVehicleBlockTemplateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    Duty?: DutyUncheckedUpdateManyWithoutBlockNestedInput
  }

  export type VehicleBlockUncheckedUpdateManyWithoutVehicleBlockTemplateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
  }

  export type DutyTemplateCreateManyDriverRunTemplateInput = {
    id?: bigint | number
    name?: string | null
    startTime: Date | string
    endTime: Date | string
    dutyType: $Enums.DutyType
    vehicleBlockTemplateId?: bigint | number | null
    scheduleId: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DriverRunCreateManyDriverRunTemplateInput = {
    id?: bigint | number
    code: string
  }

  export type DutyTemplateUpdateWithoutDriverRunTemplateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    dutyType?: EnumDutyTypeFieldUpdateOperationsInput | $Enums.DutyType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicleBlockTemplate?: VehicleBlockTemplateUpdateOneWithoutDutyTemplateNestedInput
    schedule?: ServiceScheduleUpdateOneRequiredWithoutDutyTemplatesNestedInput
  }

  export type DutyTemplateUncheckedUpdateWithoutDriverRunTemplateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    dutyType?: EnumDutyTypeFieldUpdateOperationsInput | $Enums.DutyType
    vehicleBlockTemplateId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    scheduleId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DutyTemplateUncheckedUpdateManyWithoutDriverRunTemplateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    dutyType?: EnumDutyTypeFieldUpdateOperationsInput | $Enums.DutyType
    vehicleBlockTemplateId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    scheduleId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DriverRunUpdateWithoutDriverRunTemplateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    Duty?: DutyUpdateManyWithoutRunNestedInput
  }

  export type DriverRunUncheckedUpdateWithoutDriverRunTemplateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    Duty?: DutyUncheckedUpdateManyWithoutRunNestedInput
  }

  export type DriverRunUncheckedUpdateManyWithoutDriverRunTemplateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
  }

  export type DutyCreateManyBlockInput = {
    id?: bigint | number
    date: Date | string
    startTime: Date | string
    endTime: Date | string
    driverId?: bigint | number | null
    vehicleId?: bigint | number | null
    dutyTemplateId?: bigint | number | null
    runId?: bigint | number | null
    dutyType: $Enums.DutyType
  }

  export type DutyUpdateWithoutBlockInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    dutyTemplateId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    dutyType?: EnumDutyTypeFieldUpdateOperationsInput | $Enums.DutyType
    run?: DriverRunUpdateOneWithoutDutyNestedInput
    driver?: DriverUpdateOneWithoutDutyNestedInput
    vehicle?: VehicleUpdateOneWithoutDutyNestedInput
    tripDuties?: TripDutyUpdateManyWithoutDutyNestedInput
    washingDuties?: WashingDutyUpdateManyWithoutDutyNestedInput
    maintenanceDuties?: MaintenanceDutyUpdateManyWithoutDutyNestedInput
  }

  export type DutyUncheckedUpdateWithoutBlockInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    driverId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    vehicleId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    dutyTemplateId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    runId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    dutyType?: EnumDutyTypeFieldUpdateOperationsInput | $Enums.DutyType
    tripDuties?: TripDutyUncheckedUpdateManyWithoutDutyNestedInput
    washingDuties?: WashingDutyUncheckedUpdateManyWithoutDutyNestedInput
    maintenanceDuties?: MaintenanceDutyUncheckedUpdateManyWithoutDutyNestedInput
  }

  export type DutyUncheckedUpdateManyWithoutBlockInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    driverId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    vehicleId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    dutyTemplateId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    runId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    dutyType?: EnumDutyTypeFieldUpdateOperationsInput | $Enums.DutyType
  }

  export type DutyCreateManyRunInput = {
    id?: bigint | number
    date: Date | string
    startTime: Date | string
    endTime: Date | string
    driverId?: bigint | number | null
    vehicleId?: bigint | number | null
    dutyTemplateId?: bigint | number | null
    blockId?: bigint | number | null
    dutyType: $Enums.DutyType
  }

  export type DutyUpdateWithoutRunInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    dutyTemplateId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    dutyType?: EnumDutyTypeFieldUpdateOperationsInput | $Enums.DutyType
    block?: VehicleBlockUpdateOneWithoutDutyNestedInput
    driver?: DriverUpdateOneWithoutDutyNestedInput
    vehicle?: VehicleUpdateOneWithoutDutyNestedInput
    tripDuties?: TripDutyUpdateManyWithoutDutyNestedInput
    washingDuties?: WashingDutyUpdateManyWithoutDutyNestedInput
    maintenanceDuties?: MaintenanceDutyUpdateManyWithoutDutyNestedInput
  }

  export type DutyUncheckedUpdateWithoutRunInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    driverId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    vehicleId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    dutyTemplateId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    blockId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    dutyType?: EnumDutyTypeFieldUpdateOperationsInput | $Enums.DutyType
    tripDuties?: TripDutyUncheckedUpdateManyWithoutDutyNestedInput
    washingDuties?: WashingDutyUncheckedUpdateManyWithoutDutyNestedInput
    maintenanceDuties?: MaintenanceDutyUncheckedUpdateManyWithoutDutyNestedInput
  }

  export type DutyUncheckedUpdateManyWithoutRunInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    driverId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    vehicleId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    dutyTemplateId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    blockId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    dutyType?: EnumDutyTypeFieldUpdateOperationsInput | $Enums.DutyType
  }

  export type TripDutyCreateManyDutyInput = {
    id?: bigint | number
    routeId: bigint | number
  }

  export type WashingDutyCreateManyDutyInput = {
    id?: bigint | number
  }

  export type MaintenanceDutyCreateManyDutyInput = {
    id?: bigint | number
  }

  export type TripDutyUpdateWithoutDutyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    route?: RouteUpdateOneRequiredWithoutTripDutyNestedInput
  }

  export type TripDutyUncheckedUpdateWithoutDutyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    routeId?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type TripDutyUncheckedUpdateManyWithoutDutyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    routeId?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type WashingDutyUpdateWithoutDutyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type WashingDutyUncheckedUpdateWithoutDutyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type WashingDutyUncheckedUpdateManyWithoutDutyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type MaintenanceDutyUpdateWithoutDutyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type MaintenanceDutyUncheckedUpdateWithoutDutyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type MaintenanceDutyUncheckedUpdateManyWithoutDutyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoleCountOutputTypeDefaultArgs instead
     */
    export type RoleCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoleCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DriverCountOutputTypeDefaultArgs instead
     */
    export type DriverCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DriverCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VehicleModelCountOutputTypeDefaultArgs instead
     */
    export type VehicleModelCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VehicleModelCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VehicleCountOutputTypeDefaultArgs instead
     */
    export type VehicleCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VehicleCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LocationCountOutputTypeDefaultArgs instead
     */
    export type LocationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LocationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StopCountOutputTypeDefaultArgs instead
     */
    export type StopCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StopCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RouteCountOutputTypeDefaultArgs instead
     */
    export type RouteCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RouteCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TripCountOutputTypeDefaultArgs instead
     */
    export type TripCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TripCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServiceScheduleCountOutputTypeDefaultArgs instead
     */
    export type ServiceScheduleCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServiceScheduleCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VehicleBlockTemplateCountOutputTypeDefaultArgs instead
     */
    export type VehicleBlockTemplateCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VehicleBlockTemplateCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DriverRunTemplateCountOutputTypeDefaultArgs instead
     */
    export type DriverRunTemplateCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DriverRunTemplateCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VehicleBlockCountOutputTypeDefaultArgs instead
     */
    export type VehicleBlockCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VehicleBlockCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DriverRunCountOutputTypeDefaultArgs instead
     */
    export type DriverRunCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DriverRunCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DutyCountOutputTypeDefaultArgs instead
     */
    export type DutyCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DutyCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserAuthDefaultArgs instead
     */
    export type UserAuthArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserAuthDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserActivationDefaultArgs instead
     */
    export type UserActivationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserActivationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoleDefaultArgs instead
     */
    export type RoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserRoleDefaultArgs instead
     */
    export type UserRoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserRoleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DriverDefaultArgs instead
     */
    export type DriverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DriverDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VehicleModelDefaultArgs instead
     */
    export type VehicleModelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VehicleModelDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VehicleDefaultArgs instead
     */
    export type VehicleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VehicleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LocationDefaultArgs instead
     */
    export type LocationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LocationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StopDefaultArgs instead
     */
    export type StopArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StopDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RouteDefaultArgs instead
     */
    export type RouteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RouteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RouteStopDefaultArgs instead
     */
    export type RouteStopArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RouteStopDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TripDefaultArgs instead
     */
    export type TripArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TripDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TripStopDefaultArgs instead
     */
    export type TripStopArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TripStopDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VehicleTelemetryDefaultArgs instead
     */
    export type VehicleTelemetryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VehicleTelemetryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VehicleTelemetryHistoryDefaultArgs instead
     */
    export type VehicleTelemetryHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VehicleTelemetryHistoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ShiftDefaultArgs instead
     */
    export type ShiftArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ShiftDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServiceScheduleDefaultArgs instead
     */
    export type ServiceScheduleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServiceScheduleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VehicleBlockTemplateDefaultArgs instead
     */
    export type VehicleBlockTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VehicleBlockTemplateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DriverRunTemplateDefaultArgs instead
     */
    export type DriverRunTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DriverRunTemplateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DutyTemplateDefaultArgs instead
     */
    export type DutyTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DutyTemplateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VehicleBlockDefaultArgs instead
     */
    export type VehicleBlockArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VehicleBlockDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DriverRunDefaultArgs instead
     */
    export type DriverRunArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DriverRunDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DutyDefaultArgs instead
     */
    export type DutyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DutyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TripDutyDefaultArgs instead
     */
    export type TripDutyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TripDutyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WashingDutyDefaultArgs instead
     */
    export type WashingDutyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WashingDutyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MaintenanceDutyDefaultArgs instead
     */
    export type MaintenanceDutyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MaintenanceDutyDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}