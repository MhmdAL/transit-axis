{"ast":null,"code":"// OpenRouteService configuration\n// You can get a free API key from https://openrouteservice.org/dev/#/signup\nconst ORS_API_KEY = process.env.REACT_APP_ORS_API_KEY || '5b3ce3597851110001cf6248a1c7d8b8b4c94c5fb8b0b4e5e5b5b5b5'; // Demo key (limited usage)\nconst ORS_BASE_URL = 'https://api.openrouteservice.org/v2/directions';\n\n// Simple cache to avoid duplicate requests\nconst routeCache = new Map();\nconst CACHE_DURATION = 5 * 60 * 1000; // 5 minutes\n\nexport class RoutingService {\n  /**\n   * Calculate route between multiple waypoints using OpenRouteService\n   * @param waypoints Array of coordinates in order\n   * @param signal Optional AbortSignal for request cancellation\n   * @returns Promise with route coordinates and metadata\n   */\n  static async calculateRoute(waypoints, signal) {\n    if (waypoints.length < 2) {\n      return null;\n    }\n\n    // Create cache key from waypoints\n    const cacheKey = waypoints.map(w => `${w.lat.toFixed(6)},${w.lng.toFixed(6)}`).join('|');\n\n    // Check cache first\n    const cached = routeCache.get(cacheKey);\n    if (cached) {\n      console.log('Using cached route');\n      return cached;\n    }\n    try {\n      // Convert coordinates to ORS format [lng, lat]\n      const coordinates = waypoints.map(point => [point.lng, point.lat]);\n      const requestBody = {\n        coordinates: coordinates,\n        format: 'json',\n        geometry_format: 'geojson'\n      };\n      const response = await fetch(`${ORS_BASE_URL}/driving-car/json`, {\n        method: 'POST',\n        headers: {\n          'Accept': 'application/json, application/geo+json, application/gpx+xml, img/png; charset=utf-8',\n          'Authorization': ORS_API_KEY,\n          'Content-Type': 'application/json; charset=utf-8'\n        },\n        body: JSON.stringify(requestBody),\n        signal // Add AbortSignal to the fetch request\n      });\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const data = await response.json();\n      if (data.routes && data.routes.length > 0) {\n        const route = data.routes[0];\n\n        // Extract coordinates from the route geometry\n        const routeCoordinates = route.geometry.coordinates.map(coord => ({\n          lng: coord[0],\n          lat: coord[1]\n        }));\n        return {\n          coordinates: routeCoordinates,\n          distance: route.summary.distance,\n          duration: route.summary.duration\n        };\n      }\n      return null;\n    } catch (error) {\n      console.error('Error calculating route:', error);\n\n      // Fallback to straight line if routing fails\n      return {\n        coordinates: waypoints,\n        distance: 0,\n        duration: 0\n      };\n    }\n  }\n\n  /**\n   * Calculate distance between two points (Haversine formula)\n   * Used as fallback when routing service is unavailable\n   */\n  static calculateStraightLineDistance(point1, point2) {\n    const R = 6371e3; // Earth's radius in meters\n    const φ1 = point1.lat * Math.PI / 180;\n    const φ2 = point2.lat * Math.PI / 180;\n    const Δφ = (point2.lat - point1.lat) * Math.PI / 180;\n    const Δλ = (point2.lng - point1.lng) * Math.PI / 180;\n    const a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) + Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ / 2) * Math.sin(Δλ / 2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n    return R * c; // Distance in meters\n  }\n\n  /**\n   * Format distance for display\n   */\n  static formatDistance(meters) {\n    if (meters < 1000) {\n      return `${Math.round(meters)} m`;\n    }\n    return `${(meters / 1000).toFixed(1)} km`;\n  }\n\n  /**\n   * Format duration for display\n   */\n  static formatDuration(seconds) {\n    const hours = Math.floor(seconds / 3600);\n    const minutes = Math.floor(seconds % 3600 / 60);\n    if (hours > 0) {\n      return `${hours}h ${minutes}m`;\n    }\n    return `${minutes}m`;\n  }\n}","map":{"version":3,"names":["ORS_API_KEY","process","env","REACT_APP_ORS_API_KEY","ORS_BASE_URL","routeCache","Map","CACHE_DURATION","RoutingService","calculateRoute","waypoints","signal","length","cacheKey","map","w","lat","toFixed","lng","join","cached","get","console","log","coordinates","point","requestBody","format","geometry_format","response","fetch","method","headers","body","JSON","stringify","ok","Error","status","data","json","routes","route","routeCoordinates","geometry","coord","distance","summary","duration","error","calculateStraightLineDistance","point1","point2","R","φ1","Math","PI","φ2","Δφ","Δλ","a","sin","cos","c","atan2","sqrt","formatDistance","meters","round","formatDuration","seconds","hours","floor","minutes"],"sources":["/home/mhmdal/Projects/moveo/src/services/routingService.ts"],"sourcesContent":["// OpenRouteService configuration\n// You can get a free API key from https://openrouteservice.org/dev/#/signup\nconst ORS_API_KEY = process.env.REACT_APP_ORS_API_KEY || '5b3ce3597851110001cf6248a1c7d8b8b4c94c5fb8b0b4e5e5b5b5b5'; // Demo key (limited usage)\nconst ORS_BASE_URL = 'https://api.openrouteservice.org/v2/directions';\n\n// Simple cache to avoid duplicate requests\nconst routeCache = new Map<string, RouteResponse>();\nconst CACHE_DURATION = 5 * 60 * 1000; // 5 minutes\n\nexport interface RouteCoordinate {\n  lat: number;\n  lng: number;\n}\n\nexport interface RouteResponse {\n  coordinates: RouteCoordinate[];\n  distance: number; // in meters\n  duration: number; // in seconds\n}\n\nexport class RoutingService {\n  /**\n   * Calculate route between multiple waypoints using OpenRouteService\n   * @param waypoints Array of coordinates in order\n   * @param signal Optional AbortSignal for request cancellation\n   * @returns Promise with route coordinates and metadata\n   */\n  static async calculateRoute(waypoints: RouteCoordinate[], signal?: AbortSignal): Promise<RouteResponse | null> {\n    if (waypoints.length < 2) {\n      return null;\n    }\n\n    // Create cache key from waypoints\n    const cacheKey = waypoints.map(w => `${w.lat.toFixed(6)},${w.lng.toFixed(6)}`).join('|');\n    \n    // Check cache first\n    const cached = routeCache.get(cacheKey);\n    if (cached) {\n      console.log('Using cached route');\n      return cached;\n    }\n\n    try {\n      // Convert coordinates to ORS format [lng, lat]\n      const coordinates = waypoints.map(point => [point.lng, point.lat]);\n\n      const requestBody = {\n        coordinates: coordinates,\n        format: 'json',\n        geometry_format: 'geojson'\n      };\n\n      const response = await fetch(`${ORS_BASE_URL}/driving-car/json`, {\n        method: 'POST',\n        headers: {\n          'Accept': 'application/json, application/geo+json, application/gpx+xml, img/png; charset=utf-8',\n          'Authorization': ORS_API_KEY,\n          'Content-Type': 'application/json; charset=utf-8'\n        },\n        body: JSON.stringify(requestBody),\n        signal // Add AbortSignal to the fetch request\n      });\n\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      const data = await response.json();\n\n      if (data.routes && data.routes.length > 0) {\n        const route = data.routes[0];\n        \n        // Extract coordinates from the route geometry\n        const routeCoordinates: RouteCoordinate[] = route.geometry.coordinates.map(\n          (coord: [number, number]) => ({\n            lng: coord[0],\n            lat: coord[1]\n          })\n        );\n\n        return {\n          coordinates: routeCoordinates,\n          distance: route.summary.distance,\n          duration: route.summary.duration\n        };\n      }\n\n      return null;\n    } catch (error) {\n      console.error('Error calculating route:', error);\n      \n      // Fallback to straight line if routing fails\n      return {\n        coordinates: waypoints,\n        distance: 0,\n        duration: 0\n      };\n    }\n  }\n\n  /**\n   * Calculate distance between two points (Haversine formula)\n   * Used as fallback when routing service is unavailable\n   */\n  static calculateStraightLineDistance(point1: RouteCoordinate, point2: RouteCoordinate): number {\n    const R = 6371e3; // Earth's radius in meters\n    const φ1 = point1.lat * Math.PI / 180;\n    const φ2 = point2.lat * Math.PI / 180;\n    const Δφ = (point2.lat - point1.lat) * Math.PI / 180;\n    const Δλ = (point2.lng - point1.lng) * Math.PI / 180;\n\n    const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +\n              Math.cos(φ1) * Math.cos(φ2) *\n              Math.sin(Δλ/2) * Math.sin(Δλ/2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));\n\n    return R * c; // Distance in meters\n  }\n\n  /**\n   * Format distance for display\n   */\n  static formatDistance(meters: number): string {\n    if (meters < 1000) {\n      return `${Math.round(meters)} m`;\n    }\n    return `${(meters / 1000).toFixed(1)} km`;\n  }\n\n  /**\n   * Format duration for display\n   */\n  static formatDuration(seconds: number): string {\n    const hours = Math.floor(seconds / 3600);\n    const minutes = Math.floor((seconds % 3600) / 60);\n    \n    if (hours > 0) {\n      return `${hours}h ${minutes}m`;\n    }\n    return `${minutes}m`;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}