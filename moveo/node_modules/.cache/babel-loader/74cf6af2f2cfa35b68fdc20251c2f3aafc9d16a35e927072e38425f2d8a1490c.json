{"ast":null,"code":"// OpenRouteService configuration\n// You can get a free API key from https://openrouteservice.org/dev/#/signup\nconst ORS_API_KEY = process.env.REACT_APP_ORS_API_KEY || '5b3ce3597851110001cf6248a1c7d8b8b4c94c5fb8b0b4e5e5b5b5b5'; // Demo key (limited usage)\nconst ORS_BASE_URL = 'https://api.openrouteservice.org/v2/directions';\nexport class RoutingService {\n  /**\n   * Calculate route between multiple waypoints using OpenRouteService\n   * @param waypoints Array of coordinates in order\n   * @param signal Optional AbortSignal for request cancellation\n   * @returns Promise with route coordinates and metadata\n   */\n  static async calculateRoute(waypoints, signal) {\n    if (waypoints.length < 2) {\n      return null;\n    }\n    try {\n      // Convert coordinates to ORS format [lng, lat]\n      const coordinates = waypoints.map(point => [point.lng, point.lat]);\n      const requestBody = {\n        coordinates: coordinates,\n        format: 'json',\n        geometry_format: 'geojson'\n      };\n      const response = await fetch(`${ORS_BASE_URL}/driving-car/json`, {\n        method: 'POST',\n        headers: {\n          'Accept': 'application/json, application/geo+json, application/gpx+xml, img/png; charset=utf-8',\n          'Authorization': ORS_API_KEY,\n          'Content-Type': 'application/json; charset=utf-8'\n        },\n        body: JSON.stringify(requestBody),\n        signal // Add AbortSignal to the fetch request\n      });\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const data = await response.json();\n      if (data.routes && data.routes.length > 0) {\n        const route = data.routes[0];\n\n        // Extract coordinates from the route geometry\n        const routeCoordinates = route.geometry.coordinates.map(coord => ({\n          lng: coord[0],\n          lat: coord[1]\n        }));\n        const result = {\n          coordinates: routeCoordinates,\n          distance: route.summary.distance,\n          duration: route.summary.duration\n        };\n\n        // Cache the result\n        routeCache.set(cacheKey, result);\n\n        // Clean up old cache entries after some time\n        setTimeout(() => {\n          routeCache.delete(cacheKey);\n        }, CACHE_DURATION);\n        return result;\n      }\n      return null;\n    } catch (error) {\n      console.error('Error calculating route:', error);\n\n      // Fallback to straight line if routing fails\n      return {\n        coordinates: waypoints,\n        distance: 0,\n        duration: 0\n      };\n    }\n  }\n\n  /**\n   * Calculate distance between two points (Haversine formula)\n   * Used as fallback when routing service is unavailable\n   */\n  static calculateStraightLineDistance(point1, point2) {\n    const R = 6371e3; // Earth's radius in meters\n    const φ1 = point1.lat * Math.PI / 180;\n    const φ2 = point2.lat * Math.PI / 180;\n    const Δφ = (point2.lat - point1.lat) * Math.PI / 180;\n    const Δλ = (point2.lng - point1.lng) * Math.PI / 180;\n    const a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) + Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ / 2) * Math.sin(Δλ / 2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n    return R * c; // Distance in meters\n  }\n\n  /**\n   * Format distance for display\n   */\n  static formatDistance(meters) {\n    if (meters < 1000) {\n      return `${Math.round(meters)} m`;\n    }\n    return `${(meters / 1000).toFixed(1)} km`;\n  }\n\n  /**\n   * Format duration for display\n   */\n  static formatDuration(seconds) {\n    const hours = Math.floor(seconds / 3600);\n    const minutes = Math.floor(seconds % 3600 / 60);\n    if (hours > 0) {\n      return `${hours}h ${minutes}m`;\n    }\n    return `${minutes}m`;\n  }\n}","map":{"version":3,"names":["ORS_API_KEY","process","env","REACT_APP_ORS_API_KEY","ORS_BASE_URL","RoutingService","calculateRoute","waypoints","signal","length","coordinates","map","point","lng","lat","requestBody","format","geometry_format","response","fetch","method","headers","body","JSON","stringify","ok","Error","status","data","json","routes","route","routeCoordinates","geometry","coord","result","distance","summary","duration","routeCache","set","cacheKey","setTimeout","delete","CACHE_DURATION","error","console","calculateStraightLineDistance","point1","point2","R","φ1","Math","PI","φ2","Δφ","Δλ","a","sin","cos","c","atan2","sqrt","formatDistance","meters","round","toFixed","formatDuration","seconds","hours","floor","minutes"],"sources":["/home/mhmdal/Projects/moveo/src/services/routingService.ts"],"sourcesContent":["// OpenRouteService configuration\n// You can get a free API key from https://openrouteservice.org/dev/#/signup\nconst ORS_API_KEY = process.env.REACT_APP_ORS_API_KEY || '5b3ce3597851110001cf6248a1c7d8b8b4c94c5fb8b0b4e5e5b5b5b5'; // Demo key (limited usage)\nconst ORS_BASE_URL = 'https://api.openrouteservice.org/v2/directions';\n\nexport interface RouteCoordinate {\n  lat: number;\n  lng: number;\n}\n\nexport interface RouteResponse {\n  coordinates: RouteCoordinate[];\n  distance: number; // in meters\n  duration: number; // in seconds\n}\n\nexport class RoutingService {\n  /**\n   * Calculate route between multiple waypoints using OpenRouteService\n   * @param waypoints Array of coordinates in order\n   * @param signal Optional AbortSignal for request cancellation\n   * @returns Promise with route coordinates and metadata\n   */\n  static async calculateRoute(waypoints: RouteCoordinate[], signal?: AbortSignal): Promise<RouteResponse | null> {\n    if (waypoints.length < 2) {\n      return null;\n    }\n\n    try {\n      // Convert coordinates to ORS format [lng, lat]\n      const coordinates = waypoints.map(point => [point.lng, point.lat]);\n\n      const requestBody = {\n        coordinates: coordinates,\n        format: 'json',\n        geometry_format: 'geojson'\n      };\n\n      const response = await fetch(`${ORS_BASE_URL}/driving-car/json`, {\n        method: 'POST',\n        headers: {\n          'Accept': 'application/json, application/geo+json, application/gpx+xml, img/png; charset=utf-8',\n          'Authorization': ORS_API_KEY,\n          'Content-Type': 'application/json; charset=utf-8'\n        },\n        body: JSON.stringify(requestBody),\n        signal // Add AbortSignal to the fetch request\n      });\n\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      const data = await response.json();\n\n      if (data.routes && data.routes.length > 0) {\n        const route = data.routes[0];\n        \n        // Extract coordinates from the route geometry\n        const routeCoordinates: RouteCoordinate[] = route.geometry.coordinates.map(\n          (coord: [number, number]) => ({\n            lng: coord[0],\n            lat: coord[1]\n          })\n        );\n\n        const result = {\n          coordinates: routeCoordinates,\n          distance: route.summary.distance,\n          duration: route.summary.duration\n        };\n\n        // Cache the result\n        routeCache.set(cacheKey, result);\n        \n        // Clean up old cache entries after some time\n        setTimeout(() => {\n          routeCache.delete(cacheKey);\n        }, CACHE_DURATION);\n\n        return result;\n      }\n\n      return null;\n    } catch (error) {\n      console.error('Error calculating route:', error);\n      \n      // Fallback to straight line if routing fails\n      return {\n        coordinates: waypoints,\n        distance: 0,\n        duration: 0\n      };\n    }\n  }\n\n  /**\n   * Calculate distance between two points (Haversine formula)\n   * Used as fallback when routing service is unavailable\n   */\n  static calculateStraightLineDistance(point1: RouteCoordinate, point2: RouteCoordinate): number {\n    const R = 6371e3; // Earth's radius in meters\n    const φ1 = point1.lat * Math.PI / 180;\n    const φ2 = point2.lat * Math.PI / 180;\n    const Δφ = (point2.lat - point1.lat) * Math.PI / 180;\n    const Δλ = (point2.lng - point1.lng) * Math.PI / 180;\n\n    const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +\n              Math.cos(φ1) * Math.cos(φ2) *\n              Math.sin(Δλ/2) * Math.sin(Δλ/2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));\n\n    return R * c; // Distance in meters\n  }\n\n  /**\n   * Format distance for display\n   */\n  static formatDistance(meters: number): string {\n    if (meters < 1000) {\n      return `${Math.round(meters)} m`;\n    }\n    return `${(meters / 1000).toFixed(1)} km`;\n  }\n\n  /**\n   * Format duration for display\n   */\n  static formatDuration(seconds: number): string {\n    const hours = Math.floor(seconds / 3600);\n    const minutes = Math.floor((seconds % 3600) / 60);\n    \n    if (hours > 0) {\n      return `${hours}h ${minutes}m`;\n    }\n    return `${minutes}m`;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}