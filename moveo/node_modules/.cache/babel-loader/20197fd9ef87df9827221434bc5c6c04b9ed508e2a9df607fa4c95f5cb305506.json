{"ast":null,"code":"// OpenRouteService configuration\n// You can get a free API key from https://openrouteservice.org/dev/#/signup\nconst ORS_API_KEY = process.env.REACT_APP_ORS_API_KEY || 'eyJvcmciOiI1YjNjZTM1OTc4NTExMTAwMDFjZjYyNDgiLCJpZCI6IjFiNjEwZDUxYmQ0YzQ0NWE4N2EzOGExZDVkNWZiMzA4IiwiaCI6Im11cm11cjY0In0='; // Demo key (limited usage)\nconst ORS_BASE_URL = 'https://api.openrouteservice.org/v2/directions';\nexport class RoutingService {\n  /**\n   * Calculate route between multiple waypoints using OpenRouteService\n   * @param waypoints Array of coordinates in order\n   * @param signal Optional AbortSignal for request cancellation\n   * @returns Promise with route coordinates and metadata\n   */\n  static async calculateRoute(waypoints, signal) {\n    if (waypoints.length < 2) {\n      return null;\n    }\n    try {\n      // Convert coordinates to ORS format [lng, lat]\n      const coordinates = waypoints.map(point => [point.lng, point.lat]);\n      const requestBody = {\n        coordinates: coordinates,\n        format: \"geojson\"\n      };\n      const response = await fetch(`${ORS_BASE_URL}/driving-car?api_key=${ORS_API_KEY}`, {\n        method: 'POST',\n        headers: {\n          'Accept': 'application/json, application/geo+json, application/gpx+xml, img/png; charset=utf-8',\n          'Content-Type': 'application/json; charset=utf-8'\n        },\n        body: JSON.stringify(requestBody),\n        signal // Add AbortSignal to the fetch request\n      });\n      if (!response.ok) {\n        const errorText = await response.text();\n        console.error('ORS API Error:', response.status, errorText);\n        throw new Error(`HTTP error! status: ${response.status} - ${errorText}`);\n      }\n      const data = await response.json();\n\n      // Debug: log the response structure\n      console.log('ORS API Response:', JSON.stringify(data, null, 2));\n      if (data.routes && data.routes.length > 0) {\n        const route = data.routes[0];\n\n        // Debug: log the route structure\n        console.log('Route structure:', JSON.stringify(route, null, 2));\n\n        // Check if geometry exists and what format it's in\n        if (!route.geometry) {\n          console.error('No geometry found in route');\n          return null;\n        }\n        let routeCoordinates = [];\n\n        // Handle different possible geometry formats\n        if (route.geometry.coordinates && Array.isArray(route.geometry.coordinates)) {\n          // GeoJSON format with coordinate array\n          routeCoordinates = route.geometry.coordinates.map(coord => ({\n            lng: coord[0],\n            lat: coord[1]\n          }));\n        } else if (typeof route.geometry === 'string') {\n          var _route$summary, _route$summary2;\n          // Encoded polyline format - we need to decode it\n          console.error('Encoded polyline detected - need to implement decoder');\n          // For now, fallback to straight line\n          return {\n            coordinates: waypoints,\n            distance: ((_route$summary = route.summary) === null || _route$summary === void 0 ? void 0 : _route$summary.distance) || 0,\n            duration: ((_route$summary2 = route.summary) === null || _route$summary2 === void 0 ? void 0 : _route$summary2.duration) || 0\n          };\n        } else {\n          console.error('Unknown geometry format:', route.geometry);\n          return null;\n        }\n        return {\n          coordinates: routeCoordinates,\n          distance: route.summary.distance,\n          duration: route.summary.duration\n        };\n      }\n      return null;\n    } catch (error) {\n      console.error('Error calculating route:', error);\n\n      // Fallback to straight line if routing fails\n      return {\n        coordinates: waypoints,\n        distance: 0,\n        duration: 0\n      };\n    }\n  }\n\n  /**\n   * Calculate distance between two points (Haversine formula)\n   * Used as fallback when routing service is unavailable\n   */\n  static calculateStraightLineDistance(point1, point2) {\n    const R = 6371e3; // Earth's radius in meters\n    const φ1 = point1.lat * Math.PI / 180;\n    const φ2 = point2.lat * Math.PI / 180;\n    const Δφ = (point2.lat - point1.lat) * Math.PI / 180;\n    const Δλ = (point2.lng - point1.lng) * Math.PI / 180;\n    const a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) + Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ / 2) * Math.sin(Δλ / 2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n    return R * c; // Distance in meters\n  }\n\n  /**\n   * Format distance for display\n   */\n  static formatDistance(meters) {\n    if (meters < 1000) {\n      return `${Math.round(meters)} m`;\n    }\n    return `${(meters / 1000).toFixed(1)} km`;\n  }\n\n  /**\n   * Format duration for display\n   */\n  static formatDuration(seconds) {\n    const hours = Math.floor(seconds / 3600);\n    const minutes = Math.floor(seconds % 3600 / 60);\n    if (hours > 0) {\n      return `${hours}h ${minutes}m`;\n    }\n    return `${minutes}m`;\n  }\n}","map":{"version":3,"names":["ORS_API_KEY","process","env","REACT_APP_ORS_API_KEY","ORS_BASE_URL","RoutingService","calculateRoute","waypoints","signal","length","coordinates","map","point","lng","lat","requestBody","format","response","fetch","method","headers","body","JSON","stringify","ok","errorText","text","console","error","status","Error","data","json","log","routes","route","geometry","routeCoordinates","Array","isArray","coord","_route$summary","_route$summary2","distance","summary","duration","calculateStraightLineDistance","point1","point2","R","φ1","Math","PI","φ2","Δφ","Δλ","a","sin","cos","c","atan2","sqrt","formatDistance","meters","round","toFixed","formatDuration","seconds","hours","floor","minutes"],"sources":["/home/mhmdal/Projects/moveo/src/services/routingService.ts"],"sourcesContent":["// OpenRouteService configuration\n// You can get a free API key from https://openrouteservice.org/dev/#/signup\nconst ORS_API_KEY = process.env.REACT_APP_ORS_API_KEY || 'eyJvcmciOiI1YjNjZTM1OTc4NTExMTAwMDFjZjYyNDgiLCJpZCI6IjFiNjEwZDUxYmQ0YzQ0NWE4N2EzOGExZDVkNWZiMzA4IiwiaCI6Im11cm11cjY0In0='; // Demo key (limited usage)\nconst ORS_BASE_URL = 'https://api.openrouteservice.org/v2/directions';\n\nexport interface RouteCoordinate {\n  lat: number;\n  lng: number;\n}\n\nexport interface RouteResponse {\n  coordinates: RouteCoordinate[];\n  distance: number; // in meters\n  duration: number; // in seconds\n}\n\nexport class RoutingService {\n  /**\n   * Calculate route between multiple waypoints using OpenRouteService\n   * @param waypoints Array of coordinates in order\n   * @param signal Optional AbortSignal for request cancellation\n   * @returns Promise with route coordinates and metadata\n   */\n  static async calculateRoute(waypoints: RouteCoordinate[], signal?: AbortSignal): Promise<RouteResponse | null> {\n    if (waypoints.length < 2) {\n      return null;\n    }\n\n    try {\n      // Convert coordinates to ORS format [lng, lat]\n      const coordinates = waypoints.map(point => [point.lng, point.lat]);\n\n      const requestBody = {\n        coordinates: coordinates,\n        format: \"geojson\"\n      };\n\n      const response = await fetch(`${ORS_BASE_URL}/driving-car?api_key=${ORS_API_KEY}`, {\n        method: 'POST',\n        headers: {\n          'Accept': 'application/json, application/geo+json, application/gpx+xml, img/png; charset=utf-8',\n          'Content-Type': 'application/json; charset=utf-8'\n        },\n        body: JSON.stringify(requestBody),\n        signal // Add AbortSignal to the fetch request\n      });\n\n      if (!response.ok) {\n        const errorText = await response.text();\n        console.error('ORS API Error:', response.status, errorText);\n        throw new Error(`HTTP error! status: ${response.status} - ${errorText}`);\n      }\n\n      const data = await response.json();\n      \n      // Debug: log the response structure\n      console.log('ORS API Response:', JSON.stringify(data, null, 2));\n\n      if (data.routes && data.routes.length > 0) {\n        const route = data.routes[0];\n        \n        // Debug: log the route structure\n        console.log('Route structure:', JSON.stringify(route, null, 2));\n        \n        // Check if geometry exists and what format it's in\n        if (!route.geometry) {\n          console.error('No geometry found in route');\n          return null;\n        }\n        \n        let routeCoordinates: RouteCoordinate[] = [];\n        \n        // Handle different possible geometry formats\n        if (route.geometry.coordinates && Array.isArray(route.geometry.coordinates)) {\n          // GeoJSON format with coordinate array\n          routeCoordinates = route.geometry.coordinates.map(\n            (coord: [number, number]) => ({\n              lng: coord[0],\n              lat: coord[1]\n            })\n          );\n        } else if (typeof route.geometry === 'string') {\n          // Encoded polyline format - we need to decode it\n          console.error('Encoded polyline detected - need to implement decoder');\n          // For now, fallback to straight line\n          return {\n            coordinates: waypoints,\n            distance: route.summary?.distance || 0,\n            duration: route.summary?.duration || 0\n          };\n        } else {\n          console.error('Unknown geometry format:', route.geometry);\n          return null;\n        }\n\n        return {\n          coordinates: routeCoordinates,\n          distance: route.summary.distance,\n          duration: route.summary.duration\n        };\n      }\n\n      return null;\n    } catch (error) {\n      console.error('Error calculating route:', error);\n      \n      // Fallback to straight line if routing fails\n      return {\n        coordinates: waypoints,\n        distance: 0,\n        duration: 0\n      };\n    }\n  }\n\n  /**\n   * Calculate distance between two points (Haversine formula)\n   * Used as fallback when routing service is unavailable\n   */\n  static calculateStraightLineDistance(point1: RouteCoordinate, point2: RouteCoordinate): number {\n    const R = 6371e3; // Earth's radius in meters\n    const φ1 = point1.lat * Math.PI / 180;\n    const φ2 = point2.lat * Math.PI / 180;\n    const Δφ = (point2.lat - point1.lat) * Math.PI / 180;\n    const Δλ = (point2.lng - point1.lng) * Math.PI / 180;\n\n    const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +\n              Math.cos(φ1) * Math.cos(φ2) *\n              Math.sin(Δλ/2) * Math.sin(Δλ/2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));\n\n    return R * c; // Distance in meters\n  }\n\n  /**\n   * Format distance for display\n   */\n  static formatDistance(meters: number): string {\n    if (meters < 1000) {\n      return `${Math.round(meters)} m`;\n    }\n    return `${(meters / 1000).toFixed(1)} km`;\n  }\n\n  /**\n   * Format duration for display\n   */\n  static formatDuration(seconds: number): string {\n    const hours = Math.floor(seconds / 3600);\n    const minutes = Math.floor((seconds % 3600) / 60);\n    \n    if (hours > 0) {\n      return `${hours}h ${minutes}m`;\n    }\n    return `${minutes}m`;\n  }\n}\n"],"mappings":"AAAA;AACA;AACA,MAAMA,WAAW,GAAGC,OAAO,CAACC,GAAG,CAACC,qBAAqB,IAAI,0HAA0H,CAAC,CAAC;AACrL,MAAMC,YAAY,GAAG,gDAAgD;AAarE,OAAO,MAAMC,cAAc,CAAC;EAC1B;AACF;AACA;AACA;AACA;AACA;EACE,aAAaC,cAAcA,CAACC,SAA4B,EAAEC,MAAoB,EAAiC;IAC7G,IAAID,SAAS,CAACE,MAAM,GAAG,CAAC,EAAE;MACxB,OAAO,IAAI;IACb;IAEA,IAAI;MACF;MACA,MAAMC,WAAW,GAAGH,SAAS,CAACI,GAAG,CAACC,KAAK,IAAI,CAACA,KAAK,CAACC,GAAG,EAAED,KAAK,CAACE,GAAG,CAAC,CAAC;MAElE,MAAMC,WAAW,GAAG;QAClBL,WAAW,EAAEA,WAAW;QACxBM,MAAM,EAAE;MACV,CAAC;MAED,MAAMC,QAAQ,GAAG,MAAMC,KAAK,CAAC,GAAGd,YAAY,wBAAwBJ,WAAW,EAAE,EAAE;QACjFmB,MAAM,EAAE,MAAM;QACdC,OAAO,EAAE;UACP,QAAQ,EAAE,qFAAqF;UAC/F,cAAc,EAAE;QAClB,CAAC;QACDC,IAAI,EAAEC,IAAI,CAACC,SAAS,CAACR,WAAW,CAAC;QACjCP,MAAM,CAAC;MACT,CAAC,CAAC;MAEF,IAAI,CAACS,QAAQ,CAACO,EAAE,EAAE;QAChB,MAAMC,SAAS,GAAG,MAAMR,QAAQ,CAACS,IAAI,CAAC,CAAC;QACvCC,OAAO,CAACC,KAAK,CAAC,gBAAgB,EAAEX,QAAQ,CAACY,MAAM,EAAEJ,SAAS,CAAC;QAC3D,MAAM,IAAIK,KAAK,CAAC,uBAAuBb,QAAQ,CAACY,MAAM,MAAMJ,SAAS,EAAE,CAAC;MAC1E;MAEA,MAAMM,IAAI,GAAG,MAAMd,QAAQ,CAACe,IAAI,CAAC,CAAC;;MAElC;MACAL,OAAO,CAACM,GAAG,CAAC,mBAAmB,EAAEX,IAAI,CAACC,SAAS,CAACQ,IAAI,EAAE,IAAI,EAAE,CAAC,CAAC,CAAC;MAE/D,IAAIA,IAAI,CAACG,MAAM,IAAIH,IAAI,CAACG,MAAM,CAACzB,MAAM,GAAG,CAAC,EAAE;QACzC,MAAM0B,KAAK,GAAGJ,IAAI,CAACG,MAAM,CAAC,CAAC,CAAC;;QAE5B;QACAP,OAAO,CAACM,GAAG,CAAC,kBAAkB,EAAEX,IAAI,CAACC,SAAS,CAACY,KAAK,EAAE,IAAI,EAAE,CAAC,CAAC,CAAC;;QAE/D;QACA,IAAI,CAACA,KAAK,CAACC,QAAQ,EAAE;UACnBT,OAAO,CAACC,KAAK,CAAC,4BAA4B,CAAC;UAC3C,OAAO,IAAI;QACb;QAEA,IAAIS,gBAAmC,GAAG,EAAE;;QAE5C;QACA,IAAIF,KAAK,CAACC,QAAQ,CAAC1B,WAAW,IAAI4B,KAAK,CAACC,OAAO,CAACJ,KAAK,CAACC,QAAQ,CAAC1B,WAAW,CAAC,EAAE;UAC3E;UACA2B,gBAAgB,GAAGF,KAAK,CAACC,QAAQ,CAAC1B,WAAW,CAACC,GAAG,CAC9C6B,KAAuB,KAAM;YAC5B3B,GAAG,EAAE2B,KAAK,CAAC,CAAC,CAAC;YACb1B,GAAG,EAAE0B,KAAK,CAAC,CAAC;UACd,CAAC,CACH,CAAC;QACH,CAAC,MAAM,IAAI,OAAOL,KAAK,CAACC,QAAQ,KAAK,QAAQ,EAAE;UAAA,IAAAK,cAAA,EAAAC,eAAA;UAC7C;UACAf,OAAO,CAACC,KAAK,CAAC,uDAAuD,CAAC;UACtE;UACA,OAAO;YACLlB,WAAW,EAAEH,SAAS;YACtBoC,QAAQ,EAAE,EAAAF,cAAA,GAAAN,KAAK,CAACS,OAAO,cAAAH,cAAA,uBAAbA,cAAA,CAAeE,QAAQ,KAAI,CAAC;YACtCE,QAAQ,EAAE,EAAAH,eAAA,GAAAP,KAAK,CAACS,OAAO,cAAAF,eAAA,uBAAbA,eAAA,CAAeG,QAAQ,KAAI;UACvC,CAAC;QACH,CAAC,MAAM;UACLlB,OAAO,CAACC,KAAK,CAAC,0BAA0B,EAAEO,KAAK,CAACC,QAAQ,CAAC;UACzD,OAAO,IAAI;QACb;QAEA,OAAO;UACL1B,WAAW,EAAE2B,gBAAgB;UAC7BM,QAAQ,EAAER,KAAK,CAACS,OAAO,CAACD,QAAQ;UAChCE,QAAQ,EAAEV,KAAK,CAACS,OAAO,CAACC;QAC1B,CAAC;MACH;MAEA,OAAO,IAAI;IACb,CAAC,CAAC,OAAOjB,KAAK,EAAE;MACdD,OAAO,CAACC,KAAK,CAAC,0BAA0B,EAAEA,KAAK,CAAC;;MAEhD;MACA,OAAO;QACLlB,WAAW,EAAEH,SAAS;QACtBoC,QAAQ,EAAE,CAAC;QACXE,QAAQ,EAAE;MACZ,CAAC;IACH;EACF;;EAEA;AACF;AACA;AACA;EACE,OAAOC,6BAA6BA,CAACC,MAAuB,EAAEC,MAAuB,EAAU;IAC7F,MAAMC,CAAC,GAAG,MAAM,CAAC,CAAC;IAClB,MAAMC,EAAE,GAAGH,MAAM,CAACjC,GAAG,GAAGqC,IAAI,CAACC,EAAE,GAAG,GAAG;IACrC,MAAMC,EAAE,GAAGL,MAAM,CAAClC,GAAG,GAAGqC,IAAI,CAACC,EAAE,GAAG,GAAG;IACrC,MAAME,EAAE,GAAG,CAACN,MAAM,CAAClC,GAAG,GAAGiC,MAAM,CAACjC,GAAG,IAAIqC,IAAI,CAACC,EAAE,GAAG,GAAG;IACpD,MAAMG,EAAE,GAAG,CAACP,MAAM,CAACnC,GAAG,GAAGkC,MAAM,CAAClC,GAAG,IAAIsC,IAAI,CAACC,EAAE,GAAG,GAAG;IAEpD,MAAMI,CAAC,GAAGL,IAAI,CAACM,GAAG,CAACH,EAAE,GAAC,CAAC,CAAC,GAAGH,IAAI,CAACM,GAAG,CAACH,EAAE,GAAC,CAAC,CAAC,GAC/BH,IAAI,CAACO,GAAG,CAACR,EAAE,CAAC,GAAGC,IAAI,CAACO,GAAG,CAACL,EAAE,CAAC,GAC3BF,IAAI,CAACM,GAAG,CAACF,EAAE,GAAC,CAAC,CAAC,GAAGJ,IAAI,CAACM,GAAG,CAACF,EAAE,GAAC,CAAC,CAAC;IACzC,MAAMI,CAAC,GAAG,CAAC,GAAGR,IAAI,CAACS,KAAK,CAACT,IAAI,CAACU,IAAI,CAACL,CAAC,CAAC,EAAEL,IAAI,CAACU,IAAI,CAAC,CAAC,GAACL,CAAC,CAAC,CAAC;IAEtD,OAAOP,CAAC,GAAGU,CAAC,CAAC,CAAC;EAChB;;EAEA;AACF;AACA;EACE,OAAOG,cAAcA,CAACC,MAAc,EAAU;IAC5C,IAAIA,MAAM,GAAG,IAAI,EAAE;MACjB,OAAO,GAAGZ,IAAI,CAACa,KAAK,CAACD,MAAM,CAAC,IAAI;IAClC;IACA,OAAO,GAAG,CAACA,MAAM,GAAG,IAAI,EAAEE,OAAO,CAAC,CAAC,CAAC,KAAK;EAC3C;;EAEA;AACF;AACA;EACE,OAAOC,cAAcA,CAACC,OAAe,EAAU;IAC7C,MAAMC,KAAK,GAAGjB,IAAI,CAACkB,KAAK,CAACF,OAAO,GAAG,IAAI,CAAC;IACxC,MAAMG,OAAO,GAAGnB,IAAI,CAACkB,KAAK,CAAEF,OAAO,GAAG,IAAI,GAAI,EAAE,CAAC;IAEjD,IAAIC,KAAK,GAAG,CAAC,EAAE;MACb,OAAO,GAAGA,KAAK,KAAKE,OAAO,GAAG;IAChC;IACA,OAAO,GAAGA,OAAO,GAAG;EACtB;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}