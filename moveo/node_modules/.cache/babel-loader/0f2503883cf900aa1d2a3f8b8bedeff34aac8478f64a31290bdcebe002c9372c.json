{"ast":null,"code":"import polyline from '@mapbox/polyline';\n\n// OpenRouteService configuration\n// You can get a free API key from https://openrouteservice.org/dev/#/signup\nconst ORS_API_KEY = process.env.REACT_APP_ORS_API_KEY || 'eyJvcmciOiI1YjNjZTM1OTc4NTExMTAwMDFjZjYyNDgiLCJpZCI6IjFiNjEwZDUxYmQ0YzQ0NWE4N2EzOGExZDVkNWZiMzA4IiwiaCI6Im11cm11cjY0In0='; // Demo key (limited usage)\nconst ORS_BASE_URL = 'https://api.openrouteservice.org/v2/directions';\nexport class RoutingService {\n  /**\n   * Calculate route between multiple waypoints using OpenRouteService\n   * @param waypoints Array of coordinates in order\n   * @param signal Optional AbortSignal for request cancellation\n   * @returns Promise with route coordinates and metadata\n   */\n  static async calculateRoute(waypoints, signal) {\n    if (waypoints.length < 2) {\n      return null;\n    }\n    try {\n      // Convert coordinates to ORS format [lng, lat]\n      const coordinates = waypoints.map(point => [point.lng, point.lat]);\n      const requestBody = {\n        coordinates: coordinates\n      };\n      const response = await fetch(`${ORS_BASE_URL}/driving-car?api_key=${ORS_API_KEY}`, {\n        method: 'POST',\n        headers: {\n          'Accept': 'application/json, application/geo+json, application/gpx+xml, img/png; charset=utf-8',\n          'Content-Type': 'application/json; charset=utf-8'\n        },\n        body: JSON.stringify(requestBody),\n        signal // Add AbortSignal to the fetch request\n      });\n      if (!response.ok) {\n        const errorText = await response.text();\n        console.error('ORS API Error:', response.status, errorText);\n        throw new Error(`HTTP error! status: ${response.status} - ${errorText}`);\n      }\n      const data = await response.json();\n\n      // Debug: log the response structure\n      // console.log('ORS API Response:', JSON.stringify(data, null, 2));\n\n      if (data.routes && data.routes.length > 0) {\n        const route = data.routes[0];\n\n        // Check if geometry exists and what format it's in\n        if (!route.geometry) {\n          console.error('No geometry found in route');\n          return null;\n        }\n        let routeCoordinates = [];\n\n        // Handle different possible geometry formats\n        if (route.geometry.coordinates && Array.isArray(route.geometry.coordinates)) {\n          // GeoJSON format with coordinate array\n          routeCoordinates = route.geometry.coordinates.map(coord => ({\n            lng: coord[0],\n            lat: coord[1]\n          }));\n        } else if (typeof route.geometry === 'string') {\n          // Encoded polyline format - decode it\n          // console.log('Decoding polyline:', route.geometry);\n          try {\n            const decodedCoords = polyline.decode(route.geometry);\n            routeCoordinates = decodedCoords.map(coord => ({\n              lat: coord[0],\n              // polyline.decode returns [lat, lng]\n              lng: coord[1]\n            }));\n            // console.log('Successfully decoded', routeCoordinates.length, 'coordinates');\n          } catch (error) {\n            var _route$summary, _route$summary2;\n            console.error('Failed to decode polyline:', error);\n            // Fallback to straight line\n            return {\n              coordinates: waypoints,\n              distance: ((_route$summary = route.summary) === null || _route$summary === void 0 ? void 0 : _route$summary.distance) || 0,\n              duration: ((_route$summary2 = route.summary) === null || _route$summary2 === void 0 ? void 0 : _route$summary2.duration) || 0,\n              geometry: route.geometry\n            };\n          }\n        } else {\n          console.error('Unknown geometry format:', route.geometry);\n          return null;\n        }\n        return {\n          coordinates: routeCoordinates,\n          distance: route.summary.distance,\n          duration: route.summary.duration,\n          geometry: route.geometry // Include the raw encoded polyline\n        };\n      }\n      return null;\n    } catch (error) {\n      console.error('Error calculating route:', error);\n\n      // Fallback to straight line if routing fails\n      return {\n        coordinates: waypoints,\n        distance: 0,\n        duration: 0,\n        geometry: undefined\n      };\n    }\n  }\n\n  /**\n   * Calculate distance between two points (Haversine formula)\n   * Used as fallback when routing service is unavailable\n   */\n  static calculateStraightLineDistance(point1, point2) {\n    const R = 6371e3; // Earth's radius in meters\n    const φ1 = point1.lat * Math.PI / 180;\n    const φ2 = point2.lat * Math.PI / 180;\n    const Δφ = (point2.lat - point1.lat) * Math.PI / 180;\n    const Δλ = (point2.lng - point1.lng) * Math.PI / 180;\n    const a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) + Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ / 2) * Math.sin(Δλ / 2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n    return R * c; // Distance in meters\n  }\n\n  /**\n   * Format distance for display\n   */\n  static formatDistance(meters) {\n    if (meters < 1000) {\n      return `${Math.round(meters)} m`;\n    }\n    return `${(meters / 1000).toFixed(1)} km`;\n  }\n\n  /**\n   * Format duration for display\n   */\n  static formatDuration(seconds) {\n    const hours = Math.floor(seconds / 3600);\n    const minutes = Math.floor(seconds % 3600 / 60);\n    if (hours > 0) {\n      return `${hours}h ${minutes}m`;\n    }\n    return `${minutes}m`;\n  }\n}","map":{"version":3,"names":["polyline","ORS_API_KEY","process","env","REACT_APP_ORS_API_KEY","ORS_BASE_URL","RoutingService","calculateRoute","waypoints","signal","length","coordinates","map","point","lng","lat","requestBody","response","fetch","method","headers","body","JSON","stringify","ok","errorText","text","console","error","status","Error","data","json","routes","route","geometry","routeCoordinates","Array","isArray","coord","decodedCoords","decode","_route$summary","_route$summary2","distance","summary","duration","undefined","calculateStraightLineDistance","point1","point2","R","φ1","Math","PI","φ2","Δφ","Δλ","a","sin","cos","c","atan2","sqrt","formatDistance","meters","round","toFixed","formatDuration","seconds","hours","floor","minutes"],"sources":["/home/mhmdal/Projects/moveo-master/moveo/src/services/routingService.ts"],"sourcesContent":["import polyline from '@mapbox/polyline';\n\n// OpenRouteService configuration\n// You can get a free API key from https://openrouteservice.org/dev/#/signup\nconst ORS_API_KEY = process.env.REACT_APP_ORS_API_KEY || 'eyJvcmciOiI1YjNjZTM1OTc4NTExMTAwMDFjZjYyNDgiLCJpZCI6IjFiNjEwZDUxYmQ0YzQ0NWE4N2EzOGExZDVkNWZiMzA4IiwiaCI6Im11cm11cjY0In0='; // Demo key (limited usage)\nconst ORS_BASE_URL = 'https://api.openrouteservice.org/v2/directions';\n\nexport interface RouteCoordinate {\n  lat: number;\n  lng: number;\n}\n\nexport interface RouteResponse {\n  coordinates: RouteCoordinate[];\n  distance: number; // in meters\n  duration: number; // in seconds\n  geometry?: string; // raw encoded polyline from ORS\n}\n\nexport class RoutingService {\n  /**\n   * Calculate route between multiple waypoints using OpenRouteService\n   * @param waypoints Array of coordinates in order\n   * @param signal Optional AbortSignal for request cancellation\n   * @returns Promise with route coordinates and metadata\n   */\n  static async calculateRoute(waypoints: RouteCoordinate[], signal?: AbortSignal): Promise<RouteResponse | null> {\n    if (waypoints.length < 2) {\n      return null;\n    }\n\n    try {\n      // Convert coordinates to ORS format [lng, lat]\n      const coordinates = waypoints.map(point => [point.lng, point.lat]);\n\n      const requestBody = {\n        coordinates: coordinates\n      };\n\n      const response = await fetch(`${ORS_BASE_URL}/driving-car?api_key=${ORS_API_KEY}`, {\n        method: 'POST',\n        headers: {\n          'Accept': 'application/json, application/geo+json, application/gpx+xml, img/png; charset=utf-8',\n          'Content-Type': 'application/json; charset=utf-8'\n        },\n        body: JSON.stringify(requestBody),\n        signal // Add AbortSignal to the fetch request\n      });\n\n      if (!response.ok) {\n        const errorText = await response.text();\n        console.error('ORS API Error:', response.status, errorText);\n        throw new Error(`HTTP error! status: ${response.status} - ${errorText}`);\n      }\n\n      const data = await response.json();\n      \n      // Debug: log the response structure\n      // console.log('ORS API Response:', JSON.stringify(data, null, 2));\n\n      if (data.routes && data.routes.length > 0) {\n        const route = data.routes[0];\n                \n        // Check if geometry exists and what format it's in\n        if (!route.geometry) {\n          console.error('No geometry found in route');\n          return null;\n        }\n        \n        let routeCoordinates: RouteCoordinate[] = [];\n        \n        // Handle different possible geometry formats\n        if (route.geometry.coordinates && Array.isArray(route.geometry.coordinates)) {\n          // GeoJSON format with coordinate array\n          routeCoordinates = route.geometry.coordinates.map(\n            (coord: [number, number]) => ({\n              lng: coord[0],\n              lat: coord[1]\n            })\n          );\n        } else if (typeof route.geometry === 'string') {\n          // Encoded polyline format - decode it\n          // console.log('Decoding polyline:', route.geometry);\n          try {\n            const decodedCoords = polyline.decode(route.geometry);\n            routeCoordinates = decodedCoords.map(\n              (coord: [number, number]) => ({\n                lat: coord[0], // polyline.decode returns [lat, lng]\n                lng: coord[1]\n              })\n            );\n            // console.log('Successfully decoded', routeCoordinates.length, 'coordinates');\n          } catch (error) {\n            console.error('Failed to decode polyline:', error);\n            // Fallback to straight line\n            return {\n              coordinates: waypoints,\n              distance: route.summary?.distance || 0,\n              duration: route.summary?.duration || 0,\n              geometry: route.geometry\n            };\n          }\n        } else {\n          console.error('Unknown geometry format:', route.geometry);\n          return null;\n        }\n\n        return {\n          coordinates: routeCoordinates,\n          distance: route.summary.distance,\n          duration: route.summary.duration,\n          geometry: route.geometry // Include the raw encoded polyline\n        };\n      }\n\n      return null;\n    } catch (error) {\n      console.error('Error calculating route:', error);\n      \n      // Fallback to straight line if routing fails\n      return {\n        coordinates: waypoints,\n        distance: 0,\n        duration: 0,\n        geometry: undefined\n      };\n    }\n  }\n\n  /**\n   * Calculate distance between two points (Haversine formula)\n   * Used as fallback when routing service is unavailable\n   */\n  static calculateStraightLineDistance(point1: RouteCoordinate, point2: RouteCoordinate): number {\n    const R = 6371e3; // Earth's radius in meters\n    const φ1 = point1.lat * Math.PI / 180;\n    const φ2 = point2.lat * Math.PI / 180;\n    const Δφ = (point2.lat - point1.lat) * Math.PI / 180;\n    const Δλ = (point2.lng - point1.lng) * Math.PI / 180;\n\n    const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +\n              Math.cos(φ1) * Math.cos(φ2) *\n              Math.sin(Δλ/2) * Math.sin(Δλ/2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));\n\n    return R * c; // Distance in meters\n  }\n\n  /**\n   * Format distance for display\n   */\n  static formatDistance(meters: number): string {\n    if (meters < 1000) {\n      return `${Math.round(meters)} m`;\n    }\n    return `${(meters / 1000).toFixed(1)} km`;\n  }\n\n  /**\n   * Format duration for display\n   */\n  static formatDuration(seconds: number): string {\n    const hours = Math.floor(seconds / 3600);\n    const minutes = Math.floor((seconds % 3600) / 60);\n    \n    if (hours > 0) {\n      return `${hours}h ${minutes}m`;\n    }\n    return `${minutes}m`;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}