{"ast":null,"code":"import polyline from'@mapbox/polyline';// OpenRouteService configuration\n// You can get a free API key from https://openrouteservice.org/dev/#/signup\nconst ORS_API_KEY=process.env.REACT_APP_ORS_API_KEY||'eyJvcmciOiI1YjNjZTM1OTc4NTExMTAwMDFjZjYyNDgiLCJpZCI6IjFiNjEwZDUxYmQ0YzQ0NWE4N2EzOGExZDVkNWZiMzA4IiwiaCI6Im11cm11cjY0In0=';// Demo key (limited usage)\nconst ORS_BASE_URL='https://api.openrouteservice.org/v2/directions';export class RoutingService{/**\n   * Calculate route between multiple waypoints using OpenRouteService\n   * @param waypoints Array of coordinates in order\n   * @param signal Optional AbortSignal for request cancellation\n   * @returns Promise with route coordinates and metadata\n   */static async calculateRoute(waypoints,signal){if(waypoints.length<2){return null;}try{// Convert coordinates to ORS format [lng, lat]\nconst coordinates=waypoints.map(point=>[point.lng,point.lat]);const requestBody={coordinates:coordinates};const response=await fetch(\"\".concat(ORS_BASE_URL,\"/driving-car?api_key=\").concat(ORS_API_KEY),{method:'POST',headers:{'Accept':'application/json, application/geo+json, application/gpx+xml, img/png; charset=utf-8','Content-Type':'application/json; charset=utf-8'},body:JSON.stringify(requestBody),signal// Add AbortSignal to the fetch request\n});if(!response.ok){const errorText=await response.text();console.error('ORS API Error:',response.status,errorText);throw new Error(\"HTTP error! status: \".concat(response.status,\" - \").concat(errorText));}const data=await response.json();// Debug: log the response structure\nconsole.log('ORS API Response:',JSON.stringify(data,null,2));if(data.routes&&data.routes.length>0){const route=data.routes[0];// Check if geometry exists and what format it's in\nif(!route.geometry){console.error('No geometry found in route');return null;}let routeCoordinates=[];// Handle different possible geometry formats\nif(route.geometry.coordinates&&Array.isArray(route.geometry.coordinates)){// GeoJSON format with coordinate array\nrouteCoordinates=route.geometry.coordinates.map(coord=>({lng:coord[0],lat:coord[1]}));}else if(typeof route.geometry==='string'){// Encoded polyline format - decode it\nconsole.log('Decoding polyline:',route.geometry);try{const decodedCoords=polyline.decode(route.geometry);routeCoordinates=decodedCoords.map(coord=>({lat:coord[0],// polyline.decode returns [lat, lng]\nlng:coord[1]}));console.log('Successfully decoded',routeCoordinates.length,'coordinates');}catch(error){var _route$summary,_route$summary2;console.error('Failed to decode polyline:',error);// Fallback to straight line\nreturn{coordinates:waypoints,distance:((_route$summary=route.summary)===null||_route$summary===void 0?void 0:_route$summary.distance)||0,duration:((_route$summary2=route.summary)===null||_route$summary2===void 0?void 0:_route$summary2.duration)||0};}}else{console.error('Unknown geometry format:',route.geometry);return null;}return{coordinates:routeCoordinates,distance:route.summary.distance,duration:route.summary.duration};}return null;}catch(error){console.error('Error calculating route:',error);// Fallback to straight line if routing fails\nreturn{coordinates:waypoints,distance:0,duration:0};}}/**\n   * Calculate distance between two points (Haversine formula)\n   * Used as fallback when routing service is unavailable\n   */static calculateStraightLineDistance(point1,point2){const R=6371e3;// Earth's radius in meters\nconst φ1=point1.lat*Math.PI/180;const φ2=point2.lat*Math.PI/180;const Δφ=(point2.lat-point1.lat)*Math.PI/180;const Δλ=(point2.lng-point1.lng)*Math.PI/180;const a=Math.sin(Δφ/2)*Math.sin(Δφ/2)+Math.cos(φ1)*Math.cos(φ2)*Math.sin(Δλ/2)*Math.sin(Δλ/2);const c=2*Math.atan2(Math.sqrt(a),Math.sqrt(1-a));return R*c;// Distance in meters\n}/**\n   * Format distance for display\n   */static formatDistance(meters){if(meters<1000){return\"\".concat(Math.round(meters),\" m\");}return\"\".concat((meters/1000).toFixed(1),\" km\");}/**\n   * Format duration for display\n   */static formatDuration(seconds){const hours=Math.floor(seconds/3600);const minutes=Math.floor(seconds%3600/60);if(hours>0){return\"\".concat(hours,\"h \").concat(minutes,\"m\");}return\"\".concat(minutes,\"m\");}}","map":{"version":3,"names":["polyline","ORS_API_KEY","process","env","REACT_APP_ORS_API_KEY","ORS_BASE_URL","RoutingService","calculateRoute","waypoints","signal","length","coordinates","map","point","lng","lat","requestBody","response","fetch","concat","method","headers","body","JSON","stringify","ok","errorText","text","console","error","status","Error","data","json","log","routes","route","geometry","routeCoordinates","Array","isArray","coord","decodedCoords","decode","_route$summary","_route$summary2","distance","summary","duration","calculateStraightLineDistance","point1","point2","R","φ1","Math","PI","φ2","Δφ","Δλ","a","sin","cos","c","atan2","sqrt","formatDistance","meters","round","toFixed","formatDuration","seconds","hours","floor","minutes"],"sources":["/home/mhmdal/Projects/moveo-master/moveo/src/services/routingService.ts"],"sourcesContent":["import polyline from '@mapbox/polyline';\n\n// OpenRouteService configuration\n// You can get a free API key from https://openrouteservice.org/dev/#/signup\nconst ORS_API_KEY = process.env.REACT_APP_ORS_API_KEY || 'eyJvcmciOiI1YjNjZTM1OTc4NTExMTAwMDFjZjYyNDgiLCJpZCI6IjFiNjEwZDUxYmQ0YzQ0NWE4N2EzOGExZDVkNWZiMzA4IiwiaCI6Im11cm11cjY0In0='; // Demo key (limited usage)\nconst ORS_BASE_URL = 'https://api.openrouteservice.org/v2/directions';\n\nexport interface RouteCoordinate {\n  lat: number;\n  lng: number;\n}\n\nexport interface RouteResponse {\n  coordinates: RouteCoordinate[];\n  distance: number; // in meters\n  duration: number; // in seconds\n}\n\nexport class RoutingService {\n  /**\n   * Calculate route between multiple waypoints using OpenRouteService\n   * @param waypoints Array of coordinates in order\n   * @param signal Optional AbortSignal for request cancellation\n   * @returns Promise with route coordinates and metadata\n   */\n  static async calculateRoute(waypoints: RouteCoordinate[], signal?: AbortSignal): Promise<RouteResponse | null> {\n    if (waypoints.length < 2) {\n      return null;\n    }\n\n    try {\n      // Convert coordinates to ORS format [lng, lat]\n      const coordinates = waypoints.map(point => [point.lng, point.lat]);\n\n      const requestBody = {\n        coordinates: coordinates\n      };\n\n      const response = await fetch(`${ORS_BASE_URL}/driving-car?api_key=${ORS_API_KEY}`, {\n        method: 'POST',\n        headers: {\n          'Accept': 'application/json, application/geo+json, application/gpx+xml, img/png; charset=utf-8',\n          'Content-Type': 'application/json; charset=utf-8'\n        },\n        body: JSON.stringify(requestBody),\n        signal // Add AbortSignal to the fetch request\n      });\n\n      if (!response.ok) {\n        const errorText = await response.text();\n        console.error('ORS API Error:', response.status, errorText);\n        throw new Error(`HTTP error! status: ${response.status} - ${errorText}`);\n      }\n\n      const data = await response.json();\n      \n      // Debug: log the response structure\n      console.log('ORS API Response:', JSON.stringify(data, null, 2));\n\n      if (data.routes && data.routes.length > 0) {\n        const route = data.routes[0];\n                \n        // Check if geometry exists and what format it's in\n        if (!route.geometry) {\n          console.error('No geometry found in route');\n          return null;\n        }\n        \n        let routeCoordinates: RouteCoordinate[] = [];\n        \n        // Handle different possible geometry formats\n        if (route.geometry.coordinates && Array.isArray(route.geometry.coordinates)) {\n          // GeoJSON format with coordinate array\n          routeCoordinates = route.geometry.coordinates.map(\n            (coord: [number, number]) => ({\n              lng: coord[0],\n              lat: coord[1]\n            })\n          );\n        } else if (typeof route.geometry === 'string') {\n          // Encoded polyline format - decode it\n          console.log('Decoding polyline:', route.geometry);\n          try {\n            const decodedCoords = polyline.decode(route.geometry);\n            routeCoordinates = decodedCoords.map(\n              (coord: [number, number]) => ({\n                lat: coord[0], // polyline.decode returns [lat, lng]\n                lng: coord[1]\n              })\n            );\n            console.log('Successfully decoded', routeCoordinates.length, 'coordinates');\n          } catch (error) {\n            console.error('Failed to decode polyline:', error);\n            // Fallback to straight line\n            return {\n              coordinates: waypoints,\n              distance: route.summary?.distance || 0,\n              duration: route.summary?.duration || 0\n            };\n          }\n        } else {\n          console.error('Unknown geometry format:', route.geometry);\n          return null;\n        }\n\n        return {\n          coordinates: routeCoordinates,\n          distance: route.summary.distance,\n          duration: route.summary.duration\n        };\n      }\n\n      return null;\n    } catch (error) {\n      console.error('Error calculating route:', error);\n      \n      // Fallback to straight line if routing fails\n      return {\n        coordinates: waypoints,\n        distance: 0,\n        duration: 0\n      };\n    }\n  }\n\n  /**\n   * Calculate distance between two points (Haversine formula)\n   * Used as fallback when routing service is unavailable\n   */\n  static calculateStraightLineDistance(point1: RouteCoordinate, point2: RouteCoordinate): number {\n    const R = 6371e3; // Earth's radius in meters\n    const φ1 = point1.lat * Math.PI / 180;\n    const φ2 = point2.lat * Math.PI / 180;\n    const Δφ = (point2.lat - point1.lat) * Math.PI / 180;\n    const Δλ = (point2.lng - point1.lng) * Math.PI / 180;\n\n    const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +\n              Math.cos(φ1) * Math.cos(φ2) *\n              Math.sin(Δλ/2) * Math.sin(Δλ/2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));\n\n    return R * c; // Distance in meters\n  }\n\n  /**\n   * Format distance for display\n   */\n  static formatDistance(meters: number): string {\n    if (meters < 1000) {\n      return `${Math.round(meters)} m`;\n    }\n    return `${(meters / 1000).toFixed(1)} km`;\n  }\n\n  /**\n   * Format duration for display\n   */\n  static formatDuration(seconds: number): string {\n    const hours = Math.floor(seconds / 3600);\n    const minutes = Math.floor((seconds % 3600) / 60);\n    \n    if (hours > 0) {\n      return `${hours}h ${minutes}m`;\n    }\n    return `${minutes}m`;\n  }\n}\n"],"mappings":"AAAA,MAAO,CAAAA,QAAQ,KAAM,kBAAkB,CAEvC;AACA;AACA,KAAM,CAAAC,WAAW,CAAGC,OAAO,CAACC,GAAG,CAACC,qBAAqB,EAAI,0HAA0H,CAAE;AACrL,KAAM,CAAAC,YAAY,CAAG,gDAAgD,CAarE,MAAO,MAAM,CAAAC,cAAe,CAC1B;AACF;AACA;AACA;AACA;AACA,KACE,YAAa,CAAAC,cAAcA,CAACC,SAA4B,CAAEC,MAAoB,CAAiC,CAC7G,GAAID,SAAS,CAACE,MAAM,CAAG,CAAC,CAAE,CACxB,MAAO,KAAI,CACb,CAEA,GAAI,CACF;AACA,KAAM,CAAAC,WAAW,CAAGH,SAAS,CAACI,GAAG,CAACC,KAAK,EAAI,CAACA,KAAK,CAACC,GAAG,CAAED,KAAK,CAACE,GAAG,CAAC,CAAC,CAElE,KAAM,CAAAC,WAAW,CAAG,CAClBL,WAAW,CAAEA,WACf,CAAC,CAED,KAAM,CAAAM,QAAQ,CAAG,KAAM,CAAAC,KAAK,IAAAC,MAAA,CAAId,YAAY,0BAAAc,MAAA,CAAwBlB,WAAW,EAAI,CACjFmB,MAAM,CAAE,MAAM,CACdC,OAAO,CAAE,CACP,QAAQ,CAAE,qFAAqF,CAC/F,cAAc,CAAE,iCAClB,CAAC,CACDC,IAAI,CAAEC,IAAI,CAACC,SAAS,CAACR,WAAW,CAAC,CACjCP,MAAO;AACT,CAAC,CAAC,CAEF,GAAI,CAACQ,QAAQ,CAACQ,EAAE,CAAE,CAChB,KAAM,CAAAC,SAAS,CAAG,KAAM,CAAAT,QAAQ,CAACU,IAAI,CAAC,CAAC,CACvCC,OAAO,CAACC,KAAK,CAAC,gBAAgB,CAAEZ,QAAQ,CAACa,MAAM,CAAEJ,SAAS,CAAC,CAC3D,KAAM,IAAI,CAAAK,KAAK,wBAAAZ,MAAA,CAAwBF,QAAQ,CAACa,MAAM,QAAAX,MAAA,CAAMO,SAAS,CAAE,CAAC,CAC1E,CAEA,KAAM,CAAAM,IAAI,CAAG,KAAM,CAAAf,QAAQ,CAACgB,IAAI,CAAC,CAAC,CAElC;AACAL,OAAO,CAACM,GAAG,CAAC,mBAAmB,CAAEX,IAAI,CAACC,SAAS,CAACQ,IAAI,CAAE,IAAI,CAAE,CAAC,CAAC,CAAC,CAE/D,GAAIA,IAAI,CAACG,MAAM,EAAIH,IAAI,CAACG,MAAM,CAACzB,MAAM,CAAG,CAAC,CAAE,CACzC,KAAM,CAAA0B,KAAK,CAAGJ,IAAI,CAACG,MAAM,CAAC,CAAC,CAAC,CAE5B;AACA,GAAI,CAACC,KAAK,CAACC,QAAQ,CAAE,CACnBT,OAAO,CAACC,KAAK,CAAC,4BAA4B,CAAC,CAC3C,MAAO,KAAI,CACb,CAEA,GAAI,CAAAS,gBAAmC,CAAG,EAAE,CAE5C;AACA,GAAIF,KAAK,CAACC,QAAQ,CAAC1B,WAAW,EAAI4B,KAAK,CAACC,OAAO,CAACJ,KAAK,CAACC,QAAQ,CAAC1B,WAAW,CAAC,CAAE,CAC3E;AACA2B,gBAAgB,CAAGF,KAAK,CAACC,QAAQ,CAAC1B,WAAW,CAACC,GAAG,CAC9C6B,KAAuB,GAAM,CAC5B3B,GAAG,CAAE2B,KAAK,CAAC,CAAC,CAAC,CACb1B,GAAG,CAAE0B,KAAK,CAAC,CAAC,CACd,CAAC,CACH,CAAC,CACH,CAAC,IAAM,IAAI,MAAO,CAAAL,KAAK,CAACC,QAAQ,GAAK,QAAQ,CAAE,CAC7C;AACAT,OAAO,CAACM,GAAG,CAAC,oBAAoB,CAAEE,KAAK,CAACC,QAAQ,CAAC,CACjD,GAAI,CACF,KAAM,CAAAK,aAAa,CAAG1C,QAAQ,CAAC2C,MAAM,CAACP,KAAK,CAACC,QAAQ,CAAC,CACrDC,gBAAgB,CAAGI,aAAa,CAAC9B,GAAG,CACjC6B,KAAuB,GAAM,CAC5B1B,GAAG,CAAE0B,KAAK,CAAC,CAAC,CAAC,CAAE;AACf3B,GAAG,CAAE2B,KAAK,CAAC,CAAC,CACd,CAAC,CACH,CAAC,CACDb,OAAO,CAACM,GAAG,CAAC,sBAAsB,CAAEI,gBAAgB,CAAC5B,MAAM,CAAE,aAAa,CAAC,CAC7E,CAAE,MAAOmB,KAAK,CAAE,KAAAe,cAAA,CAAAC,eAAA,CACdjB,OAAO,CAACC,KAAK,CAAC,4BAA4B,CAAEA,KAAK,CAAC,CAClD;AACA,MAAO,CACLlB,WAAW,CAAEH,SAAS,CACtBsC,QAAQ,CAAE,EAAAF,cAAA,CAAAR,KAAK,CAACW,OAAO,UAAAH,cAAA,iBAAbA,cAAA,CAAeE,QAAQ,GAAI,CAAC,CACtCE,QAAQ,CAAE,EAAAH,eAAA,CAAAT,KAAK,CAACW,OAAO,UAAAF,eAAA,iBAAbA,eAAA,CAAeG,QAAQ,GAAI,CACvC,CAAC,CACH,CACF,CAAC,IAAM,CACLpB,OAAO,CAACC,KAAK,CAAC,0BAA0B,CAAEO,KAAK,CAACC,QAAQ,CAAC,CACzD,MAAO,KAAI,CACb,CAEA,MAAO,CACL1B,WAAW,CAAE2B,gBAAgB,CAC7BQ,QAAQ,CAAEV,KAAK,CAACW,OAAO,CAACD,QAAQ,CAChCE,QAAQ,CAAEZ,KAAK,CAACW,OAAO,CAACC,QAC1B,CAAC,CACH,CAEA,MAAO,KAAI,CACb,CAAE,MAAOnB,KAAK,CAAE,CACdD,OAAO,CAACC,KAAK,CAAC,0BAA0B,CAAEA,KAAK,CAAC,CAEhD;AACA,MAAO,CACLlB,WAAW,CAAEH,SAAS,CACtBsC,QAAQ,CAAE,CAAC,CACXE,QAAQ,CAAE,CACZ,CAAC,CACH,CACF,CAEA;AACF;AACA;AACA,KACE,MAAO,CAAAC,6BAA6BA,CAACC,MAAuB,CAAEC,MAAuB,CAAU,CAC7F,KAAM,CAAAC,CAAC,CAAG,MAAM,CAAE;AAClB,KAAM,CAAAC,EAAE,CAAGH,MAAM,CAACnC,GAAG,CAAGuC,IAAI,CAACC,EAAE,CAAG,GAAG,CACrC,KAAM,CAAAC,EAAE,CAAGL,MAAM,CAACpC,GAAG,CAAGuC,IAAI,CAACC,EAAE,CAAG,GAAG,CACrC,KAAM,CAAAE,EAAE,CAAG,CAACN,MAAM,CAACpC,GAAG,CAAGmC,MAAM,CAACnC,GAAG,EAAIuC,IAAI,CAACC,EAAE,CAAG,GAAG,CACpD,KAAM,CAAAG,EAAE,CAAG,CAACP,MAAM,CAACrC,GAAG,CAAGoC,MAAM,CAACpC,GAAG,EAAIwC,IAAI,CAACC,EAAE,CAAG,GAAG,CAEpD,KAAM,CAAAI,CAAC,CAAGL,IAAI,CAACM,GAAG,CAACH,EAAE,CAAC,CAAC,CAAC,CAAGH,IAAI,CAACM,GAAG,CAACH,EAAE,CAAC,CAAC,CAAC,CAC/BH,IAAI,CAACO,GAAG,CAACR,EAAE,CAAC,CAAGC,IAAI,CAACO,GAAG,CAACL,EAAE,CAAC,CAC3BF,IAAI,CAACM,GAAG,CAACF,EAAE,CAAC,CAAC,CAAC,CAAGJ,IAAI,CAACM,GAAG,CAACF,EAAE,CAAC,CAAC,CAAC,CACzC,KAAM,CAAAI,CAAC,CAAG,CAAC,CAAGR,IAAI,CAACS,KAAK,CAACT,IAAI,CAACU,IAAI,CAACL,CAAC,CAAC,CAAEL,IAAI,CAACU,IAAI,CAAC,CAAC,CAACL,CAAC,CAAC,CAAC,CAEtD,MAAO,CAAAP,CAAC,CAAGU,CAAC,CAAE;AAChB,CAEA;AACF;AACA,KACE,MAAO,CAAAG,cAAcA,CAACC,MAAc,CAAU,CAC5C,GAAIA,MAAM,CAAG,IAAI,CAAE,CACjB,SAAA/C,MAAA,CAAUmC,IAAI,CAACa,KAAK,CAACD,MAAM,CAAC,OAC9B,CACA,SAAA/C,MAAA,CAAU,CAAC+C,MAAM,CAAG,IAAI,EAAEE,OAAO,CAAC,CAAC,CAAC,QACtC,CAEA;AACF;AACA,KACE,MAAO,CAAAC,cAAcA,CAACC,OAAe,CAAU,CAC7C,KAAM,CAAAC,KAAK,CAAGjB,IAAI,CAACkB,KAAK,CAACF,OAAO,CAAG,IAAI,CAAC,CACxC,KAAM,CAAAG,OAAO,CAAGnB,IAAI,CAACkB,KAAK,CAAEF,OAAO,CAAG,IAAI,CAAI,EAAE,CAAC,CAEjD,GAAIC,KAAK,CAAG,CAAC,CAAE,CACb,SAAApD,MAAA,CAAUoD,KAAK,OAAApD,MAAA,CAAKsD,OAAO,MAC7B,CACA,SAAAtD,MAAA,CAAUsD,OAAO,MACnB,CACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}