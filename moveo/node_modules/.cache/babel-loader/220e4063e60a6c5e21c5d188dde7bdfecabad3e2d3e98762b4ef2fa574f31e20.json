{"ast":null,"code":"import Openrouteservice from 'openrouteservice-js';\n\n// OpenRouteService configuration\n// You can get a free API key from https://openrouteservice.org/dev/#/signup\nconst ORS_API_KEY = process.env.REACT_APP_ORS_API_KEY || '5b3ce3597851110001cf6248a1c7d8b8b4c94c5fb8b0b4e5e5b5b5b5'; // Demo key (limited usage)\n\nconst ors = new Openrouteservice.Directions({\n  api_key: ORS_API_KEY\n});\nexport class RoutingService {\n  /**\n   * Calculate route between multiple waypoints using OpenRouteService\n   * @param waypoints Array of coordinates in order\n   * @returns Promise with route coordinates and metadata\n   */\n  static async calculateRoute(waypoints) {\n    if (waypoints.length < 2) {\n      return null;\n    }\n    try {\n      // Convert coordinates to ORS format [lng, lat]\n      const coordinates = waypoints.map(point => [point.lng, point.lat]);\n      const response = await ors.calculate({\n        coordinates: coordinates,\n        profile: 'driving-car',\n        // Options: driving-car, driving-hgv, cycling-regular, foot-walking\n        format: 'json',\n        geometry_format: 'geojson'\n      });\n      if (response.routes && response.routes.length > 0) {\n        const route = response.routes[0];\n\n        // Extract coordinates from the route geometry\n        const routeCoordinates = route.geometry.coordinates.map(coord => ({\n          lng: coord[0],\n          lat: coord[1]\n        }));\n        return {\n          coordinates: routeCoordinates,\n          distance: route.summary.distance,\n          duration: route.summary.duration\n        };\n      }\n      return null;\n    } catch (error) {\n      console.error('Error calculating route:', error);\n\n      // Fallback to straight line if routing fails\n      return {\n        coordinates: waypoints,\n        distance: 0,\n        duration: 0\n      };\n    }\n  }\n\n  /**\n   * Calculate distance between two points (Haversine formula)\n   * Used as fallback when routing service is unavailable\n   */\n  static calculateStraightLineDistance(point1, point2) {\n    const R = 6371e3; // Earth's radius in meters\n    const φ1 = point1.lat * Math.PI / 180;\n    const φ2 = point2.lat * Math.PI / 180;\n    const Δφ = (point2.lat - point1.lat) * Math.PI / 180;\n    const Δλ = (point2.lng - point1.lng) * Math.PI / 180;\n    const a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) + Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ / 2) * Math.sin(Δλ / 2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n    return R * c; // Distance in meters\n  }\n\n  /**\n   * Format distance for display\n   */\n  static formatDistance(meters) {\n    if (meters < 1000) {\n      return `${Math.round(meters)} m`;\n    }\n    return `${(meters / 1000).toFixed(1)} km`;\n  }\n\n  /**\n   * Format duration for display\n   */\n  static formatDuration(seconds) {\n    const hours = Math.floor(seconds / 3600);\n    const minutes = Math.floor(seconds % 3600 / 60);\n    if (hours > 0) {\n      return `${hours}h ${minutes}m`;\n    }\n    return `${minutes}m`;\n  }\n}","map":{"version":3,"names":["Openrouteservice","ORS_API_KEY","process","env","REACT_APP_ORS_API_KEY","ors","Directions","api_key","RoutingService","calculateRoute","waypoints","length","coordinates","map","point","lng","lat","response","calculate","profile","format","geometry_format","routes","route","routeCoordinates","geometry","coord","distance","summary","duration","error","console","calculateStraightLineDistance","point1","point2","R","φ1","Math","PI","φ2","Δφ","Δλ","a","sin","cos","c","atan2","sqrt","formatDistance","meters","round","toFixed","formatDuration","seconds","hours","floor","minutes"],"sources":["/home/mhmdal/Projects/moveo/src/services/routingService.ts"],"sourcesContent":["import Openrouteservice from 'openrouteservice-js';\n\n// OpenRouteService configuration\n// You can get a free API key from https://openrouteservice.org/dev/#/signup\nconst ORS_API_KEY = process.env.REACT_APP_ORS_API_KEY || '5b3ce3597851110001cf6248a1c7d8b8b4c94c5fb8b0b4e5e5b5b5b5'; // Demo key (limited usage)\n\nconst ors = new Openrouteservice.Directions({\n  api_key: ORS_API_KEY\n});\n\nexport interface RouteCoordinate {\n  lat: number;\n  lng: number;\n}\n\nexport interface RouteResponse {\n  coordinates: RouteCoordinate[];\n  distance: number; // in meters\n  duration: number; // in seconds\n}\n\nexport class RoutingService {\n  /**\n   * Calculate route between multiple waypoints using OpenRouteService\n   * @param waypoints Array of coordinates in order\n   * @returns Promise with route coordinates and metadata\n   */\n  static async calculateRoute(waypoints: RouteCoordinate[]): Promise<RouteResponse | null> {\n    if (waypoints.length < 2) {\n      return null;\n    }\n\n    try {\n      // Convert coordinates to ORS format [lng, lat]\n      const coordinates = waypoints.map(point => [point.lng, point.lat]);\n\n      const response = await ors.calculate({\n        coordinates: coordinates,\n        profile: 'driving-car', // Options: driving-car, driving-hgv, cycling-regular, foot-walking\n        format: 'json',\n        geometry_format: 'geojson'\n      });\n\n      if (response.routes && response.routes.length > 0) {\n        const route = response.routes[0];\n        \n        // Extract coordinates from the route geometry\n        const routeCoordinates: RouteCoordinate[] = route.geometry.coordinates.map(\n          (coord: [number, number]) => ({\n            lng: coord[0],\n            lat: coord[1]\n          })\n        );\n\n        return {\n          coordinates: routeCoordinates,\n          distance: route.summary.distance,\n          duration: route.summary.duration\n        };\n      }\n\n      return null;\n    } catch (error) {\n      console.error('Error calculating route:', error);\n      \n      // Fallback to straight line if routing fails\n      return {\n        coordinates: waypoints,\n        distance: 0,\n        duration: 0\n      };\n    }\n  }\n\n  /**\n   * Calculate distance between two points (Haversine formula)\n   * Used as fallback when routing service is unavailable\n   */\n  static calculateStraightLineDistance(point1: RouteCoordinate, point2: RouteCoordinate): number {\n    const R = 6371e3; // Earth's radius in meters\n    const φ1 = point1.lat * Math.PI / 180;\n    const φ2 = point2.lat * Math.PI / 180;\n    const Δφ = (point2.lat - point1.lat) * Math.PI / 180;\n    const Δλ = (point2.lng - point1.lng) * Math.PI / 180;\n\n    const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +\n              Math.cos(φ1) * Math.cos(φ2) *\n              Math.sin(Δλ/2) * Math.sin(Δλ/2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));\n\n    return R * c; // Distance in meters\n  }\n\n  /**\n   * Format distance for display\n   */\n  static formatDistance(meters: number): string {\n    if (meters < 1000) {\n      return `${Math.round(meters)} m`;\n    }\n    return `${(meters / 1000).toFixed(1)} km`;\n  }\n\n  /**\n   * Format duration for display\n   */\n  static formatDuration(seconds: number): string {\n    const hours = Math.floor(seconds / 3600);\n    const minutes = Math.floor((seconds % 3600) / 60);\n    \n    if (hours > 0) {\n      return `${hours}h ${minutes}m`;\n    }\n    return `${minutes}m`;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}